<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello! CytQ</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://imlzq.com/"/>
  <updated>2018-02-12T09:53:46.970Z</updated>
  <id>http://imlzq.com/</id>
  
  <author>
    <name>CytQ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>栈溢出</title>
    <link href="http://imlzq.com/2018/02/01/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://imlzq.com/2018/02/01/栈溢出/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2018-02-12T09:53:46.970Z</updated>
    
    <content type="html"><![CDATA[<p>windows 栈溢出</p><a id="more"></a>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">#define PASSWORD "1234567"</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">verify_password</span><span class="params">(<span class="keyword">char</span> *password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">44</span>];</span><br><span class="line">ret = strcmp(password, PASSWORD);</span><br><span class="line">strcpy(buff, password);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> password[<span class="number">1024</span>];</span><br><span class="line">FILE *fp;</span><br><span class="line"></span><br><span class="line">LoadLibrary(<span class="string">"user32.dll"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!(fp= fopen(<span class="string">"C://Users//CytQ//Desktop//password.txt"</span>, <span class="string">"rw+"</span>)))</span><br><span class="line">&#123;</span><br><span class="line">exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">fscanf(fp, <span class="string">"%s"</span>, password);</span><br><span class="line"></span><br><span class="line">flag = verify_password(password);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"Failed\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"pass\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(fp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PASSWORD.TXT: IN HEX</p><p><img src="http://bos.nj.bpc.baidu.com/v1/agroup/e0742c48617627b8f81bed1f048b804019d349b3" alt="PASSWORD.TXT"></p><p>HEX IS : 33 DB 53 68 C6 F4 DD 01 68 C6 F4 DD 01 8B C4 53 50 50 53 B8 AE FE 96 75 FF D0</p><p>MessageBoxA IN USER32.DLL  ABSOLUTELY ADDRESS: 0X7596feae</p><p><img src="http://bos.nj.bpc.baidu.com/v1/agroup/b2d4e4b6c30d21c83a666bd6e67b6f862552e118" alt="RESULT"></p><p>AND THEN, CRASH</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;windows 栈溢出&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>x86汇编示例、代码梳理和演示</title>
    <link href="http://imlzq.com/2018/01/30/x86%E6%B1%87%E7%BC%96%E7%A4%BA%E4%BE%8B%E3%80%81%E4%BB%A3%E7%A0%81%E6%A2%B3%E7%90%86%E5%92%8C%E6%BC%94%E7%A4%BA/"/>
    <id>http://imlzq.com/2018/01/30/x86汇编示例、代码梳理和演示/</id>
    <published>2018-01-29T16:00:00.000Z</published>
    <updated>2018-04-04T02:30:15.842Z</updated>
    
    <content type="html"><![CDATA[<p>x86跟ARM在一些指令集上有区别，但是大致逻辑一直。下面是以一个有栈溢出漏洞的vc6.0编写的C程序做示例。</p><a id="more"></a>    <p><strong>C中，函数调用的逻辑为：</strong></p><p>##1. 函数参数入栈##<br>如func(int a, int b, int c)<br>会将三个参数从右到左依次入栈。也就是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push c</span><br><span class="line">push b</span><br><span class="line">push a</span><br></pre></td></tr></table></figure></p><p>##2.函数的返回地址入栈##<br>让程序知道执行完当前程序后怎么处理下一步。在汇编中的表现形式和3合并</p><p>##3.代码区跳转##<br>跳转到被调用函数的入口地址，方便执行。<br>它和2的表现为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 函数地址</span><br></pre></td></tr></table></figure></p><p>##4.栈帧调整##<br>这里会有3步</p><pre><code>1. 保存当前的栈帧：push ebp2. 设置新栈帧的底部：move ebp, esp3. 抬高esp，也就是分配栈帧空间： sub esp, xx</code></pre><p>##5. 【本函数调用完后】降低栈帧，释放空间##<br>add esp, xx</p><p><strong>这样也就完成了一个函数的整体调用，具体的看下面的截图和其中的注释</strong></p><blockquote><p>对于下面的局部变量申明，有一点需要注意的。<br>比如第一张图，var_444 = -444h，这个负号是因为它比当前的ebp先入栈。对于当前函数来说，高于ebp是正数，低于的就是负数。ebp可以理解为0这个基线，-444h就能找到它的指定位置</p></blockquote><p><img src="http://bos.nj.bpc.baidu.com/v1/agroup/3ccc297a5046230c0a2a2833f5eac13e28464aa1" alt="x86汇编1"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/67b739dbe7196b2b63df67c16a5281a842d3c0c2" alt="x86汇编2"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/1c27973a000662e8ff0cb4d636da661eec1c70dd" alt="x86汇编3"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/f7d7dd01054ec84e5505ecc96a496b3ecc8cbaa3" alt="x86汇编4"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/14e5790bbe380bcd7eb7674ee1a3ec5db3a7a139" alt="x86汇编5"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/52c078db92a32c0de0d7ed69f5b098a5d33cd938" alt="x86汇编6"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/9db03478a7c26d09e292d5de2ccaee55fba888e1" alt="x86汇编7"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/1bea2f9369aa419f2e49f5e324c9028f5aea8491" alt="x86汇编8"></p><p>对于verify_password函数来说，它的栈帧为（从下到上）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buff[<span class="number">0</span>~<span class="number">3</span>]</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">4</span>~<span class="number">7</span>]</span><br><span class="line"><span class="keyword">int</span> ret</span><br><span class="line">上一个栈帧的EBP</span><br><span class="line">verify_password函数的返回地址</span><br><span class="line">形参password</span><br></pre></td></tr></table></figure></p><p>此时的EBP指针指向”上一个栈帧的EBP”, ESP指向”char buff[0~3]”。</p><p>##绕过密码检测##<br>对于ret来说，int值为4个字节，所以只需要在strcpy时让buff越界四位，那么buff[8]，buff[9], buff[10], buff[11]就会覆盖ret的值。这里有个tips，对于字符串而言，末尾会自动加入一个NULL结束符，所以只要我们输入任意的8个字符，如12345678，就能通过这个密码程序（正确的密码是1234567）。<br>ret的值其实来源于strcmp的返回值，根据字符串的串顺序，如果password&gt;1234567如12345678），那么ret=0x00000001，这个时候我们就可以用NULL覆盖的方法让它变为0x00000000。而如果password&lt;1234567（如12345668），函数返回-1，此时ret=0xFFFFFF00，这时候用NULL就覆盖不了了</p><p>下图为输入1234567后栈顶保存的数据，它指向0018FB44这个地址，而这个地址的内容为（ASCII码）31,32,33,34,35,36,37。也就是数字的1234567.最后的00，是存放字符串的NULL的<br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/751d9617eecf24590d26c53e20cecb53d6b48ec8" alt="图片"></p><p><img src="http://bos.nj.bpc.baidu.com/v1/agroup/cc3d43d6bcea77d2a5d5d621d0edd619ff520561" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;x86跟ARM在一些指令集上有区别，但是大致逻辑一直。下面是以一个有栈溢出漏洞的vc6.0编写的C程序做示例。&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="汇编" scheme="http://imlzq.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编基础及个人理解</title>
    <link href="http://imlzq.com/2017/11/07/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%8F%8A%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <id>http://imlzq.com/2017/11/07/汇编基础及个人理解/</id>
    <published>2017-11-07T10:53:38.000Z</published>
    <updated>2018-02-12T04:20:27.653Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要介绍汇编、计算机组成原理等基本内容，属于基础篇。方便其他人快速查阅。<br>每一段的基础介绍都参杂一些个人理解</p><a id="more"></a>    <p>#基于ARM的体系结构</p><p>##冯诺依曼体系</p><p>###定义<br>冯诺依曼体系：数据和指令都存储再一个存储器中的计算机。<br>这种结构的计算机系统由中央处理器单元（CPU）和一个存储器组成。</p><p>存储器拥有数据和指令，可以根据所给的地址对它进行读写。<br>CPU有几个可以存放内部使用值的内部寄存器。<br>程序计数器器（PC）：存放指令再存储器中地址的寄存器。完成一个取指令操作后，PC = PC + 1.这里的1指的是一个单位，也就是一条指令的长度 ÷ 寻址粒度。因为X86的指令长度不一样，所以每次增加的量会变化。</p><p>###流程<br>CPU先从存储器中取出指令，然后对指令进行译码，最后执行。PC并不直接决定机器下一步要做什么，它只是间接地指向了存储器中的指令。<br><strong>因此，只要改变了存储器中的指令，就能改变CPU所做的事情。</strong></p><p>冯诺依曼体系认为：程序只是一种（特殊）的数据，它可以像数据一样被处理，因此可以和数据一起被存储在同一个存储器中。数据总线和地址总线共用。</p><p>##哈佛体系</p><p>###定义<br>哈佛体系为数据和程序分别提供了独立的存储器（即将冯诺依曼体系里的数据和程序指令拆开）。</p><p>###流程<br>CPU先从程序存储器中取出指令，译码，拿到数据存储器的地址，然后执行。</p><p>它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问。与两个存储器相对应的是系统的4条总线：程序的数据总线与地址总线，数据的数据总线与地址总线。这种分离的程序总线和数据总线允许在一个机器周期内同时获得指令字（来自程序存储器）和操作数（来自数据存储器），从而提高了执行速度，使数据的吞吐率提高了1倍。又由于程序和数据存储器在两个分开的物理空间中，因此取指和执行能完全重叠。CPU首先到程序指令存储器中读取程序指令内容，解码后得到数据地址，再到相应的数据存储器中读取数据，并进行下一步的操作（通常是执行）。</p><p>##总结<br>上面的这两种体系都属于存储器体系，前者是将程序指令和数据放在一块，后者是拆分。<br>哈佛体系的速度快是显而易见的，但我认为这两者都有点理想模型的意思。在实际的使用中，都允许存在一些例外。</p><p>拿哈佛体系来说，它效率高，但设计复杂。如果我们要动态加载程序，那么就需要从外存中读取一段程序然后加载到RAM，如果这个程序在数据内存中，我们就需要一种机制将数据内存再传输到程序内存中，这就增加了设备复杂度。到RAM，如果这个程序在数据内存中，我们就需要一种机制将数据内存再传输到程序内存中，这就增加了设备复杂度。此外，此外，，绝对不允许CPU/DSP读取程序内存来当作数据，这也是不现实的，程序一般都有只读数据区和静态数据区，烧写程序的时候会当作程序的一部分烧进ROM中，如果为了把程序和数据分开，而需要设置两块ROM，再把其中一块ROM和RAM通过复用器接起来，结构就太复杂了就太复杂了，更不用说每次烧写都要分开烧两块ROM。实际上即使是DSP通常也允许从程序内存的总线上读取一些数据。</p><p>#ARM寄存器</p><p><strong>未完待续</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要介绍汇编、计算机组成原理等基本内容，属于基础篇。方便其他人快速查阅。&lt;br&gt;每一段的基础介绍都参杂一些个人理解&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="汇编" scheme="http://imlzq.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>802.11协议簇及KRACK攻击</title>
    <link href="http://imlzq.com/2017/11/07/802.11%E5%8D%8F%E8%AE%AE%E7%B0%87%E5%8F%8AKRACK%E6%94%BB%E5%87%BB/"/>
    <id>http://imlzq.com/2017/11/07/802.11协议簇及KRACK攻击/</id>
    <published>2017-11-06T16:00:00.000Z</published>
    <updated>2018-02-12T04:20:37.698Z</updated>
    
    <content type="html"><![CDATA[<p>最近暴露的KRACK攻击可以理解为钻了协议的空子，故本文就对其内部原理及实现做大致的剖析。因802.11协议簇所涉极广，暂做部分解析。详情可参考：<a href="https://zhuanlan.zhihu.com/dot11" target="_blank" rel="noopener">知乎：无线技术大讲堂</a>， <a href="https://en.wikipedia.org/wiki/IEEE_802.11" target="_blank" rel="noopener">维基百科</a></p><p>顺便学习一下wifi相关协议</p><a id="more"></a>    <p>#802.11协议簇</p><blockquote><p>无线局域网络(Wireless local network)是一种数据传输的系统，采用分布式无线电广播ISM (Industrial, Scientific, Medical) 频段将一个区域里面(如学校，家庭)的两个或者多个支持无线协议的设备连接起来的系统。进行无线射频传输的协议有多种，但是目前无线局域网络最为广泛使用的标准是IEEE 802.11协议标准</p></blockquote><p>802.11协议在1997年提出，之后的版本均在其上做修改及完善。<br>修改内容包括：</p><ul><li>IEEE 802.11，1997年，原始标准（2Mbit/s，工作在2.4GHz）。</li><li>IEEE802.11a，1999年，物理层补充（54Mbit/s，工作在5GHz）。</li><li>IEEE 802.11b，1999年，物理层补充（11Mbit/s工作在2.4GHz）。</li><li>IEEE 802.11c，符合802.1D的媒体接入控制层桥接（MAC Layer Bridging）。</li><li>IEEE 802.11d，根据各国无线电规定做的调整。</li><li>IEEE802.11e，对服务质量（Quality of Service,QoS）的支持。</li><li>IEEE 802.11f，基站的互连性（IAPP,Inter-Access Point Protocol），2006年2月被IEEE批准撤销。</li><li>IEEE802.11g，2003年，物理层补充（54Mbit/s，工作在2.4GHz）。</li><li>IEEE802.11h，2004年，无线覆盖半径的调整，室内（indoor）和室外（outdoor）信道（5GHz频段）。</li><li>IEEE802.11i，2004年，无线网络的安全方面的补充。</li><li>IEEE802.11j，2004年，根据日本规定做的升级。</li><li>IEEE 802.11l，预留及准备不使用。</li><li>IEEE 802.11m，维护标准；互斥及极限。</li><li>IEEE 802.11n，2009年9月通过正式标准，WLAN的传输速率由802.11a及802.11g提供的54Mbps、108Mbps，提高到350Mbps甚至到475Mbps。</li><li>IEEE 802.11p,2010年，这个通讯协定主要用在车用电子的无线通讯上。它设定上是从IEEE 802.11来扩充延伸，来符合智慧型运输系统（Intelligent Transportation Systems，ITS）的相关应用。应用的层面包括高速率的车辆之间以及车辆与5.9千兆赫（5.85-5.925千兆赫）波段的标准ITS路边基础设施之间的资料数据交换。</li><li>IEEE 802.11k，2008年，该协议规范规定了无线局域网络频谱测量规范。该规范的制订体现了无线局域网络对频谱资源智能化使用的需求。</li><li>IEEE 802.11r，2008年，快速基础服务转移，主要是用来解决客户端在不同无线网络AP间切换时的延迟问题。</li><li>IEEE802.11s,2007年9月.拓扑发现、路径选择与转发、信道定位、安全、流量管理和网络管理。网状网络带来一些新的术语。</li><li>IEEE 802.11w，2009年，针对802.11管理帧的保护。</li><li>IEEE 802.11x，包括802.11a/b/g等三个标准。[1] </li><li>IEEE 802.11y，2008年，针对美国3650–3700 MHz 的规定。</li><li>IEEE 802.11ac，802.11n之后的版本。工作在5G频段，理论上可以提供高达每秒1Gbit的数据传输能力。</li></ul><p>##WIFI、WLAN、802.11</p><ul><li>WLAN（Wireless Local area network）是个概念，网络技术术语。使用ISM(Industrial、Scientific、Medical)无线电广播频段通信</li><li>802.11是官方制定的标准</li><li>WIFI(WirelessFidelity，无线保真)是任何一个基于802.11标准的WLAN产品(“wireless local area network (WLAN) products that are based on the IEEE 802.11 standard.”)，目的是改善基于IEEE802.11标准的无线网路产品之间的互通性。说白了也就是wifi=采用802.11技术的WLAN</li></ul><p>##IEEE 802.11i<br>无线安全标准，WPA是其子集。<br>定义了RSN（Robust Security Network）概念从而增强WLAN的数据加密和认证性能，并且针对WEP加密机制的各种缺陷做了多方面的改进。<br>IEEE 802.11主要的标准范畴分为媒介层(MAC)与物理层(PHY)，套用过来，前者就是OSI的数据链路层中的媒体访问控制子层，后者直接就对应OSI的物理层。<br>IEEE 802.11a/b/g，主要是以PHY层的不同作为区分，所以它们的区别直接表现在工作频段及数据传输率、最大传输距离这些指标上。而工作在媒介层的标准——IEEE 802.11e/f/i则被整个IEEE 802.11族所共用。</p><blockquote><p>IEEE 802.11i采用802.1x接入控制，实现无线局域网的认证与密钥管理，并通过EAP-Key的四向握手过程与组密钥握手过程，创建、更新加密密钥，实现802.11i中定义的鲁棒安全网络（Robust Security Network，RSN）的要求。</p></blockquote><p>###加密机制（待详细拓展）<br><strong>TKIP（Temporal Key Integrity Protocol，时间密钥完整性协议）：</strong><br>采用WEP机制里的RC4作为核心加密算法，可以通过在现有的设备上升级固件和驱动程序的方法达到提高WLAN安全的目的。</p><p><strong>CCMP（Counter-Mode/CBC-MAC Protocol）：</strong><br>基于AES（Advanced Encryption Standard）加密算法和CCM（Counter-Mode/CBC-MAC）认证方式，使得WLAN的安全程度大大提高，是实现RSN的强制性要求。<br>CCMP主要由两个算法组成，分别是CTR mode以及CBC-MAC mode。</p><p>CTR mode为加密算法，CBC-MAC用于讯息完整性的运算。<br>CTR：Advanced Encryption Standard (AES) in Counter Mode。<br>CBC-MAC：Cipher Block Chaining Message Authentication Code。</p><p><strong>WRAP（Wireless Robust Authenticated Protocol）：</strong><br>基于AES加密算法和OCB（Offset Codebook），是一种可选的加密机制。</p><p>###The 4-Way Handshake：四向握手</p><p>在四向握手之前会有一些无线发现的过程。4次握手之后是组密钥协商过程。而握手的目的则是为了身份认证（其实也就是使用伪随机函数来创建和分发动态加密密钥的过程）。<br>以下的AP为Wireless access point（无线接入点），STA即连接无线网络的终端设备。</p><p><strong>有几个关键名词，先对他们进行基本介绍</strong></p><p>####PSK(Pre-Shared Key, 预共享密钥)<br>口令(passphrase)经PSK映射转换算法处理后得到的结果</p><p>####PMK(Pairwise Master Key, 成对主密钥)<br>成对主密钥。最高等级的密钥，由PSK生成。在WPA2中可以看做是ssid和口令的哈希值（也就是wifi的名称和密码，口令不同于密码，但可这样快速理解）</p><p>####PTK（The Pairwise Transient Key）<br>成对临时密钥。最终用于加密单播数据流的加密密钥<br>采用伪随机函数PRF（pseudo-random function）来生成PTK。<br>PTK的计算方法可以看作是计算PMK、ANonce、SNonce、AP的MAC地址（AA），STA的MAC地址（SPA）这一个5元数组的哈希值。<br>PTK = PRF（PMK + ANonce + SNonce + AA + SPA）</p><p>####GTK（The Group Temporal Key）<br>组临时密钥。用于加密广播和组播数据流的加密密钥</p><p>####MIC<br>消息完整性编码。它是PTK的前16个字节，如果双方的MIC一致，就说明PMK生成的一致，也就说明双方拥有的口令一致（也就是密码对了），那么AP就能确认STA的身份。</p><blockquote><p>The actual messages exchanged during the handshake are depicted in the figure and explained below (all messages are sent as EAPOL-Key frames):</p><ol><li>The AP sends a nonce-value to the STA (ANonce). The client now has all the attributes to construct the PTK.</li><li>The STA sends its own nonce-value (SNonce) to the AP together with a Message Integrity Code (MIC), including authentication, which is really a Message Authentication and Integrity Code (MAIC).</li><li>The AP constructs and sends the GTK and a sequence number together with another MIC. This sequence number will be used in the next multicast or broadcast frame, so that the receiving STA can perform basic replay detection.</li><li>The STA sends a confirmation to the AP.</li></ol></blockquote><p>在握手过程中，所有信息都以EAPOL帧发送(Extensible Authentication Protocol Over LAN，基于局域网的扩展认证协议)。</p><ol><li>AP（认证方）发起，发送一个ANonce到STA（终端）。ANonce作为重放保护，必须时这个PMK之前没用过的值</li><li>STA在收到信息后结合ANonce和自行构造的SNonce构造PTK，然后发送SNonce和MIC（消息验证码）到AP。</li><li>AP也利用（ANonce和SNonce）构造PTK，并且验证STA发过来的MIC等信息。验证成功后生成GTK并发送消息。消息包括GTK、告诉STA安装PTK和GTK、接收顺序计数器RSC（receive sequence counter， 即当前GTK的顺序号），并让STA允许检测重播的广播信息</li><li>STA接收到AP返还的消息，验证MIC，安装密钥，返还确认信息给AP。AP在收到确认后，验证MIC，安装相同的密钥。此时，双方都安装了相同的PTK和GTK。</li></ol><p>之后通信双方就可以使用进行安全的通信了。<br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/b7487b5c93477b6632d9fb0f452e70a65e7c7d70" alt="4-way handshake"><br>图片摘自<a href="https://en.wikipedia.org/wiki/IEEE_802.11i-2004" target="_blank" rel="noopener">维基百科</a></p><p><strong>所以总结一下流程也就是：AP和STA在交换随机数的同时进行数据校验，并用这个随机数以及自身已知的一些数据构建PTK、GTK。</strong></p><p>##常见的WIFI类型</p><p>###WEP<br>WEP（Wired Equivalent Privacy，有线等效保密协议）是对在两台设备间无线传输的数据进行加密的方式，用以防止非法用户窃听或侵入无线网络。它使用RC4（Rivest Cipher）对分组信息进行加密，并使用 CRC-32 验证达到资料的正确性。</p><p><strong>攻击、破解</strong><br>它使用加密密钥包括收发双发预先确定的40位或者104位通用密钥、发送方为每个分组信息所确定的24位加密密钥IV(initialization vector)。但是为了当IV密钥告诉给通信对象，IV不经加密就直接嵌入到分组信息中发送出去。如果通过无限窃听，手机到包含特定IV密钥的分组信息并对其进行解析，那么连隐秘的通用密钥都可能呗计算出来</p><p>###WPA/WPA2<br>WPA（WIFI-Protected Access），有WPA和WPA2两个标准，它是根据WEP中找到的几个严重漏洞产生的.WPA实现了IEEE 802.11i标准的大部分，是在802.11i完备之前替代WEP的过渡方案。WPA2具备完整的标准体系，但其不能被应用在某些老旧型号的网卡上。</p><p>#KRACK（Key Reinstallation Attack）</p><blockquote><p>KRACK (Key Reinstallation Attack) is a severe replay attack (a type of exploitable flaw) on the Wi-Fi Protected Access protocol that secures Wi-Fi connections. It was discovered in 2016 by the Belgian researchers Mathy Vanhoef and Frank Piessens of the University of Leuven.Vanhoef’s research group published details of the attack in October 2017.By repeatedly resetting the nonce transmitted in the third step of the WPA2 handshake, an attacker can gradually match encrypted packets seen before and learn the full keychain used to encrypt the traffic.<br>The weakness is in the Wi-Fi standard itself, and not in individual products or implementations. Therefore, any correct implementation of WPA2 is likely to be vulnerable. The vulnerability affects all major software platforms, including Microsoft Windows, macOS, iOS, Android, Windows Phone and Linux.<br>The widely used open-source implementation wpa_supplicant, utilized by Linux, Android, and OpenBSD, is especially susceptible as it can be manipulated to install an all-zeros encryption key, effectively nullifying WPA2 protection in a man-in-the-middle attack.<br>The attack targets the four-way handshake used to establish a nonce (a kind of “shared secret”) in the WPA2 protocol. The standard for WPA2 anticipates occasional WiFi disconnections, and allows reconnection using the same value for the third handshake (for quick reconnection and continuity). Because the standard does not require a different key to be used in this type of reconnection, which could be needed at any time, a replay attack is possible.<br>An attacker can repeatedly re-send the third handshake of another device’s communication to manipulate or reset the WPA2 encryption key. Each reset causes data to be encrypted using the same values, so blocks with the same content can be seen and matched, working backwards to identify parts of the keychain which were used to encrypt that block of data. Repeated resets gradually expose more of the keychain until eventually the whole key is known, and the attacker can read the target’s entire traffic on that connection.</p></blockquote><p><a href="https://en.wikipedia.org/wiki/KRACK" target="_blank" rel="noopener">摘自维基百科</a></p><p>KRACK在2016年被研究者发现并于2017年10月公布攻击细节。<br>小道消息：据说斯诺登2010年泄露NSA机密文档介绍的BADDECISION项目貌似就是KRACK攻击 : )</p><p>##影响</p><blockquote><p>In this demonstration, the attacker is able to decrypt all data that the victim transmits. For an attacker this is easy to accomplish, because our key reinstallation attack is exceptionally devastating against Linux and Android 6.0 or higher. This is because Android and Linux can be tricked into (re)installing an all-zero encryption key. </p></blockquote><p>摘自<a href="https://www.krackattacks.com/" target="_blank" rel="noopener">krackattacks.com</a></p><p>攻击者可以多次重放四向握手的第三次握手，强制重装受害者已经在用的WPA密钥，即可以把原来正确真实的WPA密码用一个全零的加密密钥替换掉，之后再建立一个同名但密码全零的AP，就能使STA连接到这个钓鱼AP上，从而完全获得用户的网络数据。</p><p>##Tip1<br>WPA2的标准中若WiFi偶尔断开连接，则允许重新使用相同的值进行第三次握手（用于建立快速的重新连接和保持连续性）进行连接。</p><p>##Tip2<br>在四向握手的第三次完成后，STA就会认为生成的PTK是正确的，安装PTK并开始使用其派生的密钥作为CCMP的会话密钥，然后通过802.1x进行通信。</p><p>##Tip3<br>协议规定：</p><ol><li>每次生成PTK后，都要重设CCMP的计数器的值</li><li>处在已经安装PTK状态下的STA要处理重传的第一和第三个握手包</li></ol><p>##Tip4<br>STA方给AP发送确认包之后并不能确认认证方是否收到了Ack，而如果AP在第三次握手完成后一直没有收到Ack确认包，则会重传第三次的握手包，同时递增其中的replay-counter值来使其有效。</p><p>##Tip5<br>Android和Linux中的wpa_supplicant基本都存在例外，允许未完整加密的EAPOL包和未验证PTK密钥来源</p><p>##Tip6<br>WPA加密协议采用的是stream cipher加密（即用一个伪随机密钥流逐字节去异或明文）。</p><blockquote><p>可简单理解为：ciphertext = plaintext xor AES(key, IV||counter)</p></blockquote><p>在正常的过程中，key和IV是不变的，counter值每次都递增，这也就导致每次生成的密钥都不同。<br>但在重安装过程中，counter值会被反复置为0，这也就导致每次生成的密钥都是一样的。<br>所以数据的结果也就变为了：使用同一密钥加密多组不同的明文。对于两组密文来说，相互异或就能抵消掉密钥，只剩加密后的明文。而如果其中一组明文对于攻击者而言已知，那么就可推出另一组明文的具体内容。</p><p>##我的理解<br>攻击者事先在STA和AP中充当中间人，通过拦截第四次握手包让AP重传第三次握手包，这样就会导致STA重装本地密钥。重装密钥之后，就能诱使STA连接到一个钓鱼AP上了（AP连接的验证机制可以简单理解为AP名+密码，密码全零即可）</p><ol><li>对于Android 6.0以上的手机来说（Linux上的wpa_supplicant版本为2.4~2.6的wifi客户端），在初始化密钥后，它们会直接将包含密钥材料的缓冲区内存清零。但程序并不知道缓冲区已经被清零，因此又会再去读取一次那块内存区域，那这个时候的密钥就一定是由全零的数据衍生来的。如Nonce为0，那么攻击者就可以直接计算出加密数据包所使用的密钥，也就能直接解析用户发送的数据了。</li><li>对于非Android6.0和Linux对应wpa_supplicant的wifi客户端来说，STA加密所用的密钥不可知，但如果攻击者知晓其中一组数据包的明文是什么，那么就可以推出其他数据包的明文（此过程不需要知晓加密密钥，直接异或）。但从<a href="https://zhuanlan.zhihu.com/p/30281357?group_id=904476874034634752" target="_blank" rel="noopener">其他文章</a>上发现，每次可推导出的明文内容有限且可能具有很大的不确定性。</li></ol><p>这个过程只能说是绕过而不能说是破解WPA2（发现者也说是bypass），因为wifi的密钥在整个流程中并没有被破解，也没有破解四向握手过程中新生成的加密密钥。</p><ul><li>Android 6.0以上和部分Linux之所以成为目标是因为它的wpa_supplicant代码实现上有问题。windows和ios因为实现不同因此不会受zero-encrypt key的攻击。</li><li>如果敏感信息进行了加密或者其他安全保护比如https，那就是安全的</li></ul><p>##关于本文</p><ul><li>有些细节及攻击实现上因为是自己的理解，并且Paper太拖沓，跳着看的，所以一些地方可能有偏差。如果以后发现有不足或者错误的地方就再修改吧。</li><li>POC据说已经有了，研究后再完善一下</li><li>一些协议的基础细节上不是很完善，之后再补充，比如CCMP、WEP、WPA/WPA2、EAP、EAPOL</li></ul><p>##引用</p><ul><li><a href="https://en.wikipedia.org/wiki/KRACK" target="_blank" rel="noopener">维基百科：https://en.wikipedia.org/wiki/KRACK</a></li><li><a href="https://www.youtube.com/watch?v=Oh4WURZoR98" target="_blank" rel="noopener">KRACK演示视频: https://www.youtube.com/watch?v=Oh4WURZoR98</a></li><li><a href="https://papers.mathyvanhoef.com/ccs2017.pdf" target="_blank" rel="noopener">KRACK Paper: https://papers.mathyvanhoef.com/ccs2017.pdf</a></li><li><a href="https://www.krackattacks.com/" target="_blank" rel="noopener">https://www.krackattacks.com/</a></li><li><a href="https://zhuanlan.zhihu.com/p/30281357?group_id=904476874034634752" target="_blank" rel="noopener">Don’t Panic! KRACK 没你想象的那么糟</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近暴露的KRACK攻击可以理解为钻了协议的空子，故本文就对其内部原理及实现做大致的剖析。因802.11协议簇所涉极广，暂做部分解析。详情可参考：&lt;a href=&quot;https://zhuanlan.zhihu.com/dot11&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;知乎：无线技术大讲堂&lt;/a&gt;， &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_802.11&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;顺便学习一下wifi相关协议&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="蓝牙" scheme="http://imlzq.com/tags/%E8%93%9D%E7%89%99/"/>
    
  </entry>
  
  <entry>
    <title>Dex文件结构分析</title>
    <link href="http://imlzq.com/2017/10/30/Dex/"/>
    <id>http://imlzq.com/2017/10/30/Dex/</id>
    <published>2017-10-29T16:00:00.000Z</published>
    <updated>2018-02-12T04:21:20.164Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://agroup.baidu.com/baseandroid/view/pdf/494458" target="_blank" rel="noopener">Dex文件结构分析</a></p><a id="more"></a>    ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://agroup.baidu.com/baseandroid/view/pdf/494458&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dex文件结构分析&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件基础和mmap</title>
    <link href="http://imlzq.com/2017/10/26/Linux%20%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80%E5%92%8Cmmap/"/>
    <id>http://imlzq.com/2017/10/26/Linux 文件基础和mmap/</id>
    <published>2017-10-25T16:00:00.000Z</published>
    <updated>2018-02-12T04:21:51.857Z</updated>
    
    <content type="html"><![CDATA[<p>脱360的壳时需要给mmap函数下断点，总结IPC的共享内存时也需要用到mmap，所以本文就先总结一下mmap相关内容。</p><a id="more"></a>    <p>#Linux文件基础</p><p>##fd</p><p>fd（File Descriptor）是内核为了管理已打开的文件所创建的索引，是一个非负整数，在open时产生。所有执行I/O操作的系统调用都会通过文件描述符。<br>| 文件描述符 | 用途   | POSIX名称       | stdio流 |<br>| —– | —- | ————- | —— |<br>| 0     | 标准输入 | STDIN_FILENO  | stdin  |<br>| 1     | 标准输出 | STDOUT_FILENO | stdout |<br>| 2     | 标准错误 | STDERR_FILENO | stderr |<br>如果打开一个新的文件，它的fd会是3。</p><p>POSIX（Portable Operating System Interface of UNIX，可移植操作系统接口）标准规定每次打开文件时必须使用当前进程中最小可用的文件描述符号码。</p><p>###限制<br>理论上系统内存有多大就可以打开多少的fd，但实际上内核允许最大的打开文件数是系统内存的10%（KB计算），如果超出这个数，就会提示“Too many open files”。可以使用sysctl -a | grep fs.file-max命令查看系统的最大打开文件数。这也就是系统级限制。<br>此外，为了防止一个进程消耗掉所有的文件资源，单个进程最大打开的文件数有限制，一般为1024，可通过ulimit -n查看。这就是用户级限制。</p><p>##fd和文件之间的关系</p><ul><li>每个fd会与一个打开的文件对应；</li><li>不同的fd也可能会指向同一个文件</li><li><p>相同的文件可以被不同的进程打开，也可以在同一个进程中被多次打开</p><p>系统为每个进程都维护了一个文件描述符表，该表的值都是从0开始， 进程凭借fd的值能通过文件描述符表快速查询对应的文件。</p></li></ul><p>所以在不同的进程中会看到相同的fd，但它们可能指向同一个文件，也可能指向不同的文件。</p><p>##内核维护的3个数据结构</p><ul><li>进程级的文件描述符表</li><li>系统级的打开文件描述符表</li><li>文件系统的i-node表</li></ul><p>###inode表<br><strong>inode是什么？</strong></p><ul><li>文件存储在硬盘上，硬盘的最小存储单位叫扇区（Sector），每个山区存储512字节（0.5KB）</li><li>操作系统在读取硬盘的时候，为了效率，会一次性连续读取多个扇区，也就是块（block）。块也就是文件存取的最小单位，它的大小最常见的为4kb，即8个连续的扇区组成一个块</li><li>因此文件的数据存储在块中，而存储文件的元信息（比如文件的创建者、创建时间、创建的大小等）的区域就叫做inode(index node， 索引节点)</li></ul><p><strong>inode的内容</strong></p><ul><li>文件的字节数</li><li>文件拥有者的User ID</li><li>文件的Group ID</li><li>文件的读、写、执行权限</li><li>文件的时间戳：ctime（inode上一次变动的时间）、mtime（文件内容上一次变动的时间）、atime（文件上一次打开的时间）</li><li>链接数，即有多少个文件名指向这个inode</li><li>文件数据block的位置</li></ul><p><strong>inode号码</strong><br>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</p><p>其实在Unix/Linux系统中在识别文件时，不使用文件名而是使用inode号码。<br>对于系统来说，文件名只是inode号码便于识别的别称或绰号。</p><p>当用户通过文件名打开文件时，系统内部分为3个流程</p><pre><code>1. 系统找到这个文件名对应的inode号码2. 通过inode号码获取inode信息3. 根据inode信息找到文件数据block的位置，读出数据</code></pre><p><strong>目录文件</strong><br>因为Linux中万物皆文件，因此目录（directory）也是一种文件。<br>目录的结构其实就是一系列目录项（dirent）的列表。<br>每个目录项的内容为：</p><ul><li>所包含文件的文件名</li><li>该文件名对应的inode号码 </li></ul><p><strong>硬链接（hard link）</strong><br>一般情况下，文件名和inode号码一一对应，每个inode号码对应一个文件名。</p><p>但Unix/Linux系统也允许多个文件名指向同一个inode号码，即可以用不同的文件名访问同样的内容。</p><p>对文件内容进行修改，会影响到所有文件名。但删除一个文件名，并不影响另一个文件名的访问。</p><p><strong>软链接（soft link）</strong><br>有一种特殊情况。<br>文件A和B的inode号码虽然不一样，但是文件A的内容是文件B的路径。即读取文件A时，系统会自动将访问者导向B。<br>因此，不论打开哪一个文件，最终读取的都是文件B。这时候文件A就称为文件B的软链接或符号链接（Symbolic link）。</p><p>这是的文件A依赖于文件B存在，如果删除文件B，那么打开文件A就会报错：『No such file or directory』。<br>这也就是软链接与硬链接最大的不同：文件A指向文件B，而不是文件B的inode号码，文件B的inode链接数不会因此发生变化</p><p>###进程级的文件描述符表<br>该表的每一条目均记录了单个文件描述符的相关信</p><pre><code>1. 控制文件描述符操作的一组标志（如close-on-exec）2. 对打开文件句柄的引用</code></pre><p>###系统级的打开文件描述符表<br>内核对所有打开的文件维护有一个系统级的<strong>描述符表格（open file description table）</strong>，也被称为<strong>打开文件表（open file table）</strong>，并将表格中各条目称为<strong>打开文件句柄（open file handle）</strong>。<br>一个打开文件句柄存储了与一个打开文件相关的全部信息</p><pre><code>1. 当前文件的偏移量（调用read()和write()时更新，或使用lseek()直接修改）2. 打开文件时所使用的状态标识（如open()的flags参数）3. 文件访问模式（调用open时的只读、只写或读写模式）4. 与信号驱动相关的设置5. 对该文件inode对象的引用6. 文件类型（如常规文件、套接字、FIFO）和访问权限7. 指向该文件所持有的锁列表的指针8. 文件的各种属性，包括文件大小、不同类型操作相关的时间戳</code></pre><p><img src="http://bos.nj.bpc.baidu.com/v1/agroup/103143f4b87f36e80404c317b2cd06cf1cccc845" alt="文件描述符、打开的文件句柄以及i-node之间的关系"><br><strong>图为：文件描述符、打开的文件句柄以及i-node之间的关系</strong></p><p>   在上图的进程A中，文件描述符1和30都指向了同一个打开的文件句柄（标号23）。这可能是通过调用dup()、dup2()、fcntl()或者对同一个文件多次调用了open()函数而形成的。</p><p>   进程A的文件描述符2和进程B的文件描述符2都指向了同一个打开的文件句柄（标号73）。这种情形可能是在调用fork()后出现的（即，进程A、B是父子进程关系），或者当某进程通过UNIX域套接字将一个打开的文件描述符传递给另一个进程时，也会发生。再者是不同的进程独自去调用open函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。</p><p>  此外，进程A的描述符0和进程B的描述符3分别指向不同的打开文件句柄，但这些句柄均指向i-node表的相同条目（1976），换言之，指向同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了open()调用。同一个进程两次打开同一个文件，也会发生类似情况。</p><p>##fd与filp<br>fd只是一个整数，起索引的作用，进程通过PCB（Process Control Block）中的文件描述符表找到该fd所指向的文件指针filp（file pointer），filp返回strcut file*结构指针。</p><p>#I/O缓冲区</p><p>###概念<br>与高速缓存（cache）产生的原理类似，在I/O过程中，读取磁盘的速度相对内存读取速度要慢的多。因此为了能够加快处理数据的速度，需要将读取过的数据缓存在内存里。而这些缓存在内存里的数据就是高速缓冲区（buffer cache），下面简称为“buffer”。</p><p>具体来说，buffer（缓冲区）是一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。一方面，通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。另一方面，可以保护硬盘或减少网络传输的次数。</p><p>###Buffer和Cache<br>buffer和cache是两个不同的概念：cache是高速缓存，用于CPU和内存之间的缓冲；buffer是I/O缓存，用于内存和硬盘的缓冲；<br>简单的说，cache是加速“读”，而buffer是缓冲“写”，前者解决读的问题，保存从磁盘上读出的数据，后者是解决写的问题，保存即将要写入到磁盘上的数据。</p><p>###Buffer Cache和 Page Cache<br>buffer cache和page cache都是为了处理设备和内存交互时高速访问的问题。buffer cache可称为块缓冲器，page cache可称为页缓冲器。</p><p>在linux不支持虚拟内存机制之前，还没有页的概念，因此缓冲区以块为单位对设备进行。在linux采用虚拟内存的机制来管理内存后，页是虚拟内存管理的最小单位，开始采用页缓冲的机制来缓冲内存。</p><p>Linux2.6之后内核将这两个缓存整合，页和块可以相互映射，同时，页缓存page cache面向的是虚拟内存，块I/O缓存Buffer cache是面向块设备。需要强调的是，页缓存和块缓存对进程来说就是一个存储系统，进程不需要关注底层的设备的读写。</p><p>buffer cache和page cache两者最大的区别是缓存的粒度。buffer cache面向的是文件系统的块。而内核的内存管理组件采用了比文件系统的块更高级别的抽象：页page，其处理的性能更高。因此和内存管理交互的缓存组件，都使用页缓存。</p><p>###页缓存Page Cache<br>页缓存是面向文件，面向内存的。通俗来说，它位于内存和文件之间缓冲区，文件IO操作实际上只和page cache交互，不直接和内存交互。page cache可以用在所有以文件为单元的场景下，比如网络文件系统等等。</p><p>##文件读写基本流程</p><p>###读文件</p><pre><code>1. 进程调用库函数向内核发起读文件请求；2. 内核通过检查进程的文件描述符定位到虚拟文件系统的已打开文件列表表项；3. 调用该文件可用的系统调用函数read()4. read()函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的inode；5. 在inode中，通过文件内容偏移量计算出要读取的页；6. 通过inode找到文件对应的address_space；7. 在address_space中访问该文件的页缓存树，查找对应的页缓存结点：  （1）如果页缓存命中，那么直接返回文件内容；    （2）如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页；重新进行第6步查找页缓存；8. 文件内容读取成功。</code></pre><p>###写文件<br>前5步和读文件一致，在address_space中查询对应页的页缓存是否存在：</p><p>  6、如果页缓存命中，直接把文件内容修改更新在页缓存的页中。写文件就结束了。这时候<br>  文件修改位于页缓存，并没有写回到磁盘文件中去。</p><p>  7、 如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页。此时缓存页命中，进行第6步。</p><p>  8、一个页缓存中的页如果被修改，那么会被标记成脏页。脏页需要写回到磁盘中的文件块。有两种方式可以把脏页写回磁盘：<br>（1）手动调用sync()或者fsync()系统调用把脏页写回<br>（2）pdflush进程会定时把脏页写回到磁盘</p><p>同时注意，脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放。</p><p>#内核空间和用户空间<br>Linux的虚拟地址与线性地址总是一致，Linux的虚拟地址空间跟线性地址一样，为0～4G。Linux内核将这4G字节的空间分为两部分。将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间）。</p><p>每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。</p><p>故，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p><p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。 </p><p><strong>其实说白了也就是：两个的权限不一样，处理的事务不一样。内核空间能调系统调用，用户空间只能调用户调用</strong></p><p>#mmap<br>mmap是内存映射文件的方法，即将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。</p><p><img src="http://bos.nj.bpc.baidu.com/v1/agroup/cd2b711165c1b5ae167e31c248539377ae7bd623" alt="进城虚拟地址空间"></p><p>从上图可以了解，进程的虚拟地址空间由多个虚拟内存区域构成。虚拟内存区域是虚拟内存空间中具有同样特性的连续地址范围。</p><p>上方的text数据段、初始数据段、bss数据段、堆、内存映射、栈，每个都是一个独立的虚拟内存区域。</p><p>为内存映射服务的地址空间处在堆在之间的空余部分。<br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/e73e69609510615c14deecc36ea1455394f2d281" alt="vm_area_struct"></p><p>Linux内核使用vm_area_struct结构表示一个独立的虚拟内存区域，每个vm_area_struct结构使用链表或者树形结构连接，方便进程快速访问。它包含区域其实和终止地址以及其他相关信息，同时也包括一个vm_ops指针，其内部可引出所有针对这个区域可以使用的系统调用函数。</p><p>因此进程对某一虚拟内存区域的任何操作需要用到的信息都可以直接从vm_area_struct中获得。</p><p>mmap也就是要创建一个新的vm_area_struct结构并将其与文件的物理磁盘相连。</p><p>##mmap内存映射的流程</p><p>###（一）进程在虚拟地址空间中创建虚拟映射区域</p><pre><code>1.  进程在用户空间调用库函数mmap2.  在当前进程句柄的虚拟地址空间中，寻找一段空闲且满足要求的连续虚拟地址3.  为此虚拟区分配一个vm_area_struct结构并初始化它4.  将新建的vm_area_struct结构插入到进程的虚拟地址区域链表或树中</code></pre><p>void <em>mmap(void </em>start, size_t length, int prot, int flags, int fd, off_t offset); </p><blockquote><p>start：映射区的开始位置<br>length：映射区的长度<br>port：期望的内存保护标志，不能与文件的打开模式冲突。可以通过or运算组合。<br>flags:指定映射对象的类型、映射选项和映射页是否可以共享。它的值可以是一个或者多个参数的组合<br>fd: 文件描述符<br>offset：被映射对象内容的起点</p></blockquote><p>port的值可以为：</p><pre><code>1. PROT_EXEC ：页内容可以被执行2. PROT_READ ：页内容可以被读取3. PROT_WRITE ：页可以被写入4. PROT_NONE ：页不可访问</code></pre><p>flag的参数类型：</p><pre><code>1. MAP_FIXED          // 使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。2.  MAP_SHARED    // 与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到msync()或者munmap()被调用，文件实际上不会被更新。3.  MAP_PRIVATE    // 建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。4.  MAP_DENYWRITE // 这个标志被忽略。5. MAP_EXECUTABLE // 同上6.  MAP_NORESERVE // 不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。7. MAP_LOCKED // 锁定映射区的页面，从而防止页面被交换出内存。8. MAP_GROWSDOWN // 用于堆栈，告诉内核VM系统，映射区可以向下扩展。9. MAP_ANONYMOUS // 匿名映射，映射区不与任何文件关联。10. MAP_ANON // MAP_ANONYMOUS的别称，不再被使用。11.  MAP_FILE // 兼容标志，被忽略。12. MAP_32BIT // 将映射区放在进程地址空间的低2GB，MAP_FIXED指定时会被忽略。当前这个标志只在x86-64平台上得到支持。13.  MAP_POPULATE // 为文件映射通过预读的方式准备好页表。随后对映射区的访问不会被页违例阻塞。14. MAP_NONBLOCK // 仅和MAP_POPULATE一起使用时才有意义。不执行预读，只为已存在于内存中的页面建立页表入口。</code></pre><p>###（二）调用内核空间的系统调用函数mmap，实现文件物理地址和进程虚拟地址的映射关系</p><pre><code>1. 通过待映射的文件指针filp，在文件描述符表中查询对应的fd，通过fd，链接到内核已打开文件表（Open file table）中该文件的文件结构体 （struct file）。每个文件结构体维护这和这个已打开文件相关的各项信息。2. 通过该文件结构体，连接到file_operations模块，调用内核函数mmap3. 内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址4. 通过remap_pfn_range函数建立页表，即实现文件地址和虚拟地址的映射关系。</code></pre><p>另外，此时的系统调用函数mmap与库函数mmap不同。它的定义如下：<br>int mmap(struct file <em>filp, struct vm_area_struct </em>vma)<br>里面两个参数的定义就是文件指针filp和虚拟空间结构体</p><p><strong>总结：其实也就是通过一系列的手段获取文件磁盘的物理地址，从而与虚拟地址映射</strong></p><p>###（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝<br>在前两步完成之后，只完成了地址映射，但没有将任何文件数据拷贝到主存。<br>当进程发起读或写操作时才会执行文件读取</p><pre><code>1. 进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。2. 缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。3. 调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。4. 之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</code></pre><p>修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。</p><p>##mmap和常规文件操作的区别</p><p>###常规文件：</p><pre><code>1. 进程发起读文件请求2. 内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到该文件的inode3. inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，直接返回4. 如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存，然后再发起读页面的过程，从而将页缓存中的数据发给用户进程。</code></pre><p>实际上呢，页缓存存在于内核空间，用户空间是不能对它直接寻址的。所以还需要将页缓存中的数据再次拷贝到内存对应的用户空间去才行。</p><p><strong>所以也就会有两次拷贝。</strong></p><p>###mmap<br>它实现了用户空间和内核空间的直接交互，就省去了额外拷贝的过程，所以就只会有一次拷贝。</p><p><strong>优点：</strong></p><pre><code>1. 对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率。2. 实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。3. 提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。 同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。4. 可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;脱360的壳时需要给mmap函数下断点，总结IPC的共享内存时也需要用到mmap，所以本文就先总结一下mmap相关内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="汇编" scheme="http://imlzq.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Dalvik虚拟机加载Dex的流程</title>
    <link href="http://imlzq.com/2017/10/11/Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A0%E8%BD%BDDex%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <id>http://imlzq.com/2017/10/11/Dalvik虚拟机加载Dex的流程/</id>
    <published>2017-10-10T16:00:00.000Z</published>
    <updated>2018-02-12T04:21:12.310Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章Android脱壳（基于第一代加壳）介绍了如何使用ida pro在运行Dalvik虚拟机的Android4.4手机上脱壳。其中有一个很重要的步骤就是给libdvm.so的_Z21dvmDexFileOpenPartialPKviPP6DvmDex函数下断点，用于确定dex在内存空间中的起始位置和大小，那这篇文章就挖一下Dalvik虚拟机是如何加载dex文件的。</p><blockquote><p><a href="https://source.android.com/source/downloading" target="_blank" rel="noopener">Android源码</a></p></blockquote><a id="more"></a>    <p>##开始</p><p><a href="www.baidu.com">Dalvik虚拟机介绍</a></p><ul><li>Dalvik虚拟机在加载dex之前，会判断本地是否存在odex文件（<a href="www.baidu.com">Dex\ELF文件格式</a>, <a href="www.baidu.com">ODex与Dex比较</a>）</li><li>如果存在，则直接加载odex</li><li>如果不存在，使用dexopt优化dex文件为odex（odex的后缀类型仍然为dex）</li><li>除此之外，dexopt还担任dex的校验功能。它会判断DexHeader中的时间戳和crc校验值，从而判断该dex是否合法（弱校验，可欺骗绕过）</li></ul><p>故从上我们可以知道，在APP运行时dexopt占有很重要的一环，因此，我们只需在dexopt中找到加载dex的那段代码即可跟踪Dalvik虚拟机加载dex的流程。</p><p>dexopt的主函数位于<a href="http://androidxref.com/4.1.1/xref/dalvik/dexopt/OptMain.cpp" target="_blank" rel="noopener">OptMain.cpp</a></p><pre><code>/* * Main entry point.  Decide where to go. */int main(int argc, char* const argv[]){    set_process_name(&quot;dexopt&quot;);    setvbuf(stdout, NULL, _IONBF, 0);    if (argc &gt; 1) {        if (strcmp(argv[1], &quot;--zip&quot;) == 0)            return fromZip(argc, argv);        else if (strcmp(argv[1], &quot;--dex&quot;) == 0)            return fromDex(argc, argv);        else if (strcmp(argv[1], &quot;--preopt&quot;) == 0)            return preopt(argc, argv);    }    fprintf(stderr,        &quot;Usage:\n\n&quot;        &quot;Short version: Don&apos;t use this.\n\n&quot;        &quot;Slightly longer version: This system-internal tool is used to\n&quot;        &quot;produce optimized dex files. See the source code for details.\n&quot;);    return 1;}</code></pre><p>跟踪14行进入fromDex<br>这里面先进行的是一些参数和环境的判断，配置<a href="www.baidu.com">dexOptMode、verifyMode</a>，初始化vm相关环境，然后进入dvmContinueOptimization函数继续接下来的优化过程。</p><pre><code>static int fromDex(int argc, char* const argv[]){    int result = -1;    bool vmStarted = false;    char* bootClassPath = NULL;    int fd, flags, vmBuildVersion;    long offset, length;    const char* debugFileName;    u4 crc, modWhen;    char* endp;    bool onlyOptVerifiedDex = false;    DexClassVerifyMode verifyMode;    DexOptimizerMode dexOptMode;if (argc &lt; 10) {    /* don&apos;t have all mandatory args */    ALOGE(&quot;Not enough arguments for --dex (found %d)&quot;, argc);    goto bail;}/* skip &quot;--dex&quot; */argc--;argv++;/* * Extract the args. */GET_ARG(vmBuildVersion, strtol, &quot;bad vm build&quot;);if (vmBuildVersion != DALVIK_VM_BUILD) {    ALOGE(&quot;DexOpt: build rev does not match VM: %d vs %d&quot;,        vmBuildVersion, DALVIK_VM_BUILD);    goto bail;}GET_ARG(fd, strtol, &quot;bad fd&quot;);GET_ARG(offset, strtol, &quot;bad offset&quot;);GET_ARG(length, strtol, &quot;bad length&quot;);debugFileName = *++argv;--argc;GET_ARG(modWhen, strtoul, &quot;bad modWhen&quot;);GET_ARG(crc, strtoul, &quot;bad crc&quot;);GET_ARG(flags, strtol, &quot;bad flags&quot;);ALOGV(&quot;Args: fd=%d off=%ld len=%ld name=&apos;%s&apos; mod=%#x crc=%#x flg=%d (argc=%d)&quot;,    fd, offset, length, debugFileName, modWhen, crc, flags, argc);assert(argc &gt; 0);if (--argc == 0) {    bootClassPath = strdup(&quot;&quot;);} else {    int i, bcpLen;    char* const* argp;    char* cp;    bcpLen = 0;    for (i = 0, argp = argv; i &lt; argc; i++) {        ++argp;        ALOGV(&quot;DEP: &apos;%s&apos;&quot;, *argp);        bcpLen += strlen(*argp) + 1;    }    cp = bootClassPath = (char*) malloc(bcpLen +1);    for (i = 0, argp = argv; i &lt; argc; i++) {        int strLen;        ++argp;        strLen = strlen(*argp);        if (i != 0)            *cp++ = &apos;:&apos;;        memcpy(cp, *argp, strLen);        cp += strLen;    }    *cp = &apos;\0&apos;;    assert((int) strlen(bootClassPath) == bcpLen-1);}ALOGV(&quot;  bootclasspath is &apos;%s&apos;&quot;, bootClassPath);/* start the VM partway *//* ugh -- upgrade these to a bit field if they get any more complex */if ((flags &amp; DEXOPT_VERIFY_ENABLED) != 0) {    if ((flags &amp; DEXOPT_VERIFY_ALL) != 0)        verifyMode = VERIFY_MODE_ALL;    else        verifyMode = VERIFY_MODE_REMOTE;} else {    verifyMode = VERIFY_MODE_NONE;}if ((flags &amp; DEXOPT_OPT_ENABLED) != 0) {    if ((flags &amp; DEXOPT_OPT_ALL) != 0)        dexOptMode = OPTIMIZE_MODE_ALL;    else        dexOptMode = OPTIMIZE_MODE_VERIFIED;} else {    dexOptMode = OPTIMIZE_MODE_NONE;}if (dvmPrepForDexOpt(bootClassPath, dexOptMode, verifyMode, flags) != 0) {    ALOGE(&quot;VM init failed&quot;);    goto bail;}vmStarted = true;/* do the optimization */if (!dvmContinueOptimization(fd, offset, length, debugFileName,        modWhen, crc, (flags &amp; DEXOPT_IS_BOOTSTRAP) != 0)){    ALOGE(&quot;Optimization failed&quot;);    goto bail;}result = 0;bail:    /*     * In theory we should gracefully shut the VM down at this point.  In     * practice that only matters if we&apos;re checking for memory leaks with     * valgrind -- simply exiting is much faster.     *     * As it turns out, the DEX optimizer plays a little fast and loose     * with class loading.  We load all of the classes from a partially-     * formed DEX file, which is unmapped when we&apos;re done.  If we want to     * do clean shutdown here, perhaps for testing with valgrind, we need     * to skip the munmap call there.     */#if 0    if (vmStarted) {        ALOGI(&quot;DexOpt shutting down, result=%d&quot;, result);        dvmShutdown();    }#endif    free(bootClassPath);    ALOGV(&quot;DexOpt command complete (result=%d)&quot;, result);    return result;}</code></pre><p>而在dvmContinueOptimization函数中，在简单判断dex是否合法之后会将整个dex文件通过<a href="www.baidu.com">mmap</a>映射到内存中，然后重写文件，包括字符的重排序、结构对齐、类验证及字节码优化等，方便对文件进行处理。</p><pre><code>/* * Do the actual optimization.  This is executed in the dexopt process. * * For best use of disk/memory, we want to extract once and perform * optimizations in place.  If the file has to expand or contract * to match local structure padding/alignment expectations, we want * to do the rewrite as part of the extract, rather than extracting * into a temp file and slurping it back out.  (The structure alignment * is currently correct for all platforms, and this isn&apos;t expected to * change, so we should be okay with having it already extracted.) * * Returns &quot;true&quot; on success. */bool dvmContinueOptimization(int fd, off_t dexOffset, long dexLength,    const char* fileName, u4 modWhen, u4 crc, bool isBootstrap){    DexClassLookup* pClassLookup = NULL;    RegisterMapBuilder* pRegMapBuilder = NULL;    assert(gDvm.optimizing);    ALOGV(&quot;Continuing optimization (%s, isb=%d)&quot;, fileName, isBootstrap);    assert(dexOffset &gt;= 0);    /* quick test so we don&apos;t blow up on empty file */    if (dexLength &lt; (int) sizeof(DexHeader)) {        ALOGE(&quot;too small to be DEX&quot;);        return false;    }    if (dexOffset &lt; (int) sizeof(DexOptHeader)) {        ALOGE(&quot;not enough room for opt header&quot;);        return false;    }    bool result = false;    /*     * Drop this into a global so we don&apos;t have to pass it around.  We could     * also add a field to DexFile, but since it only pertains to DEX     * creation that probably doesn&apos;t make sense.     */    gDvm.optimizingBootstrapClass = isBootstrap;    {        /*         * Map the entire file (so we don&apos;t have to worry about page         * alignment).  The expectation is that the output file contains         * our DEX data plus room for a small header.         */        bool success;        void* mapAddr;        mapAddr = mmap(NULL, dexOffset + dexLength, PROT_READ|PROT_WRITE,                    MAP_SHARED, fd, 0);        if (mapAddr == MAP_FAILED) {            ALOGE(&quot;unable to mmap DEX cache: %s&quot;, strerror(errno));            goto bail;        }        bool doVerify, doOpt;        if (gDvm.classVerifyMode == VERIFY_MODE_NONE) {            doVerify = false;        } else if (gDvm.classVerifyMode == VERIFY_MODE_REMOTE) {            doVerify = !gDvm.optimizingBootstrapClass;        } else /*if (gDvm.classVerifyMode == VERIFY_MODE_ALL)*/ {            doVerify = true;        }        if (gDvm.dexOptMode == OPTIMIZE_MODE_NONE) {            doOpt = false;        } else if (gDvm.dexOptMode == OPTIMIZE_MODE_VERIFIED ||                   gDvm.dexOptMode == OPTIMIZE_MODE_FULL) {            doOpt = doVerify;        } else /*if (gDvm.dexOptMode == OPTIMIZE_MODE_ALL)*/ {            doOpt = true;        }        /*         * Rewrite the file.  Byte reordering, structure realigning,         * class verification, and bytecode optimization are all performed         * here.         *         * In theory the file could change size and bits could shift around.         * In practice this would be annoying to deal with, so the file         * layout is designed so that it can always be rewritten in place.         *         * This creates the class lookup table as part of doing the processing.         */        success = rewriteDex(((u1*) mapAddr) + dexOffset, dexLength,                    doVerify, doOpt, &amp;pClassLookup, NULL);        if (success) {            DvmDex* pDvmDex = NULL;            u1* dexAddr = ((u1*) mapAddr) + dexOffset;            if (dvmDexFileOpenPartial(dexAddr, dexLength, &amp;pDvmDex) != 0) {                ALOGE(&quot;Unable to create DexFile&quot;);                success = false;            } else {                /*                 * If configured to do so, generate register map output                 * for all verified classes.  The register maps were                 * generated during verification, and will now be serialized.                 */                if (gDvm.generateRegisterMaps) {                    pRegMapBuilder = dvmGenerateRegisterMaps(pDvmDex);                    if (pRegMapBuilder == NULL) {                        ALOGE(&quot;Failed generating register maps&quot;);                        success = false;                    }                }                DexHeader* pHeader = (DexHeader*)pDvmDex-&gt;pHeader;                updateChecksum(dexAddr, dexLength, pHeader);                dvmDexFileFree(pDvmDex);            }        }      ..........}</code></pre><p>而如果重写成功，则会获取到dex在内存中的实际地址（这个地址由mmap映射的地址和dexoffset偏移量联合确定）。<br>这时就会调用dvmDexFileOpenPartial(const void<em> addr, int len, DvmDex*</em> ppDvmDex)，第一和第二个参数，就是上篇文章提到的dex起始地址和dex长度，它们分别存放在R0和R1寄存器。有了这两个参数，我们就能将dex直接从内存中抠出来。</p><p>##未完待续：继续接下来的加载流程</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章Android脱壳（基于第一代加壳）介绍了如何使用ida pro在运行Dalvik虚拟机的Android4.4手机上脱壳。其中有一个很重要的步骤就是给libdvm.so的_Z21dvmDexFileOpenPartialPKviPP6DvmDex函数下断点，用于确定dex在内存空间中的起始位置和大小，那这篇文章就挖一下Dalvik虚拟机是如何加载dex文件的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://source.android.com/source/downloading&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android源码&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="Dalvik" scheme="http://imlzq.com/tags/Dalvik/"/>
    
  </entry>
  
  <entry>
    <title>Android重构记录及其模块化</title>
    <link href="http://imlzq.com/2017/02/24/Android%E9%87%8D%E6%9E%84%E8%AE%B0%E5%BD%95%E5%8F%8A%E5%85%B6%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://imlzq.com/2017/02/24/Android重构记录及其模块化/</id>
    <published>2017-02-24T05:11:41.000Z</published>
    <updated>2018-02-12T03:30:37.108Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文仅为个人观点，不完全符合模块化的标准定义及其拓展。思路类似，仅此而已。不可当做模块化的标准理解</strong></p><p><strong>如果各位对于本博客中提到的任何思路或者架构有任何看法，欢迎讨论。以下仅是这3天的个人考虑，基于个人能力及视野的限制，很有可能不完善，欢迎批评指正，共同进步</strong></p><p><strong>转载请注明出处：<a href="http://blog.csdn.net/jonstank2013?viewmode=contents" target="_blank" rel="noopener">http://blog.csdn.net/jonstank2013?viewmode=contents</a></strong></p><a id="more"></a><p>##项目基础情况##<br>项目人群：百万日活<br>整体大小：类数量未记，Size 500+M</p><p>##起因##<br>这几天正在重构公司的项目，因为本月16日看项目源码时发现项目的内部架构极其冗余（4年前的项目，延伸至今），不管是从业务的拓展还是现有架构的维护上的体验都极其恶劣。一个接触该项目的新人很难在没有需求文档的情况下理清整体的业务流程及架构。而由于业务需求太多导致团队没有足够的时间去做全新的重构。</p><p><strong>以下为原架构的示例图：</strong><br><img src="http://img.blog.csdn.net/20170224100151701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSm9uc1RhbmsyMDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="原始架构"></p><p>这种架构也就是最原始的Activity-Fragment-Manager模式，Activity或者Fragment通过接口与各Manager沟通联系。这种模式的弊端在于Activity承担了太多的工作，随着项目的进行Activity会越来越大，导致其越来越难以维护。单从MainActivity来说，就足有2500多行。所有的业务代码和逻辑代码全都冗余在一块，甚至还包含了很多Lisenter和Callback的定义，而这些都绝对不应该是Activity的功能。为了更好的维护（当项目变得非常庞大时），我们可以从Activity中把逻辑功能分离处理，交由另外的一个逻辑管理类处理，而逻辑管理类再和其他的工具类联系。这样就可以极大的增加代码的可维护性。</p><p>而上面提到的逻辑、业务分离的方式实际上也就是MVP/MVVM的方式。</p><p>##事件总线##<br>项目中还存在着事件总线（一个自定义的EventManager），跟EventBus类似，只是更轻量级。<br>EventManager的功能为Subscribe，Send。实际上也就是一旦Event发生了事件，那么EventManager就会通知所有订阅了该事件的对象处理该事件，实现“何处订阅，何处处理”。<br>从一个第三方通用库的角度来说，这种方式是绝对可行且意义非凡的。但对于一个模块化或者MVP/MVVM来说，它的一些通用配置就有点多余了。<br>例如”何处订阅，何处处理“，在Activity-Managers-Callback的模式中，可以有多个不同的对象订阅同一个事件，发生Event后这些对象都会受到通知。但这会造成一个非常大的弊端，也就是代码的维护性非常差。因为开发者不会知道究竟是谁订阅了这个事件，而这个事件又从哪发送到了哪去解决，一旦发生问题，非常难以调试及定位。<br>而在MVP中，所有的逻辑操作都应在Presenter中处理并分发，也就是说EventBus只应与Presenter进行联系。它不行也绝对不能与其他的类绑定，因为这会违背架构的定义，以及破坏架构的原则。</p><p>因此EventManager在MVP中就变成了一个简化版的Rxbus。Rxbus相关信息可见我之前的博客：<a href="http://blog.csdn.net/jonstank2013/article/details/50574871" target="_blank" rel="noopener">http://blog.csdn.net/jonstank2013/article/details/50574871</a></p><p>Github地址为：<a href="https://github.com/CytQ/Rxbus" target="_blank" rel="noopener">https://github.com/CytQ/Rxbus</a></p><p><strong>Rxbus和EventBus在事件的处理上有着很明显的不同</strong></p><p>EventBus是针对Event做订阅，一旦发生事件，EventBus会通知所有订阅的对象进行处理。<br>而Rxbus订阅的则是事件总线，一旦事件总线上存在事件（也就是Event被触发），那么所有订阅了事件总线的对象都会收到Event的通知。</p><p>根据他们俩的性质，可以很明确的了解到，EventBus可以针对所有情况，不管是Activity-Manager-Callback模式还是MVP/MVVM。而Rxbus就有了局限性，它只能使用于MVP/MVVM等业务逻辑分离的情况。<br>但除此之外，Rxbus还具有一些EventBus不具有的特性，那就是他可以使用Rxjava带来的一系列好处。例如快速切换线程，一行代码即可。而在EventBus中，如果想要对Event切换处理线程，那么就必须人为的控制一个线程管理类或者线程池。</p><p>而将Rxbus应用于MVP中，只需处理好他的订阅及取消就可以了。因为同一时间最好只能存在一个Presenter处理逻辑事件。而如果存在多个Presenter，对效率的影响也不高，一个函数调用而已。</p><p><strong>现存在我Git中的Rxbus功能不是特别完善，但我会接下来的时间里不断的拓展它，让他更能符合开发的实际情况。例如多个Presenter同时存在时，如何正确的分发Event</strong></p><p>##定义新架构##<br>因此在经过考虑之后，我提出了以下的重构建议。<br><img src="http://img.blog.csdn.net/20170224114905196?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSm9uc1RhbmsyMDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="NewArchitecture"></p><p>MVP结合Rxjava构建全响应式架构。将逻辑代码从View层中完全剥离出来，交由Presenter处理。同时将之前存在的大量Manager和工具类交给DataManager管理。Presenter与Model之间、Presenter与Rxbus使用Observable交流。</p><p><strong>而在具体实现时，在View与Presenter之间再独立一层Contract，使View依赖于Contract中的Presenter，而Presenter依赖于Contract中的View。从而实现接口隔离：对象应关联于接口，而不应该是其具体实现类。另外还可解决一个Case：业务代码难以理清（一个新人只需了解Contract中相关的定义即可快速了解View和Presenter的功能，一目了然）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainContract</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span> <span class="keyword">extends</span> <span class="title">BasePresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">View</span> <span class="keyword">extends</span> <span class="title">BaseView</span>&lt;<span class="title">Presenter</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showMsg</span><span class="params">(String eventName)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BasePresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unSubscribe</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseView</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPresenter</span><span class="params">(T presenter)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方案可以很好的解决Activity代码冗余，整体架构耦合性高的问题。缺点在于需要控制很多的Presenter及Contract，代码的流程变复杂。但我认为在项目过大时，这种缺点比之其优势来说，不值一提。</p><p>##发现新问题##<br>在评审并通过上述新架构方案后，我开始尝试部分重构。而前天与昨天，就遇到了一个以前重构小项目时从来没遇到的问题：依赖项实在是太多。</p><p>因为依赖项众多以及需要针对每一个依赖项都做单独的模块处理（编译器不支持自动批量导入和修改），因此前天及昨天均花费了大量的时间在导入及Fix依赖类上，3个类简单类最后延伸为了150多个类，这还是我注释掉了很多业务代码的结果。总时间超过半天，这是完完全全的体力劳动，并且会极大的降低重构的效率，但对此又无可奈何。因为一个项目大了之后，势必会存在很多的业务代码及其管理类，即便架构设计得再完美，耦合性再低，也很难避免这种情况的发生。引入一个类，就意味着需要引入它的继承类、实现类、使用的工具类等等。</p><p>##模块化思路##</p><p>那么在编译器不能实现自动导入自动匹配的时候，我们是否可以采用一种编程协议去规范代码，让任何独立的功能都能快速或者直接模块化，让它与其他的功能模块松耦合，（可能？）从而避免或者减缓以上的情况。同时还可以避免65535，可支持动态加载（不更新APK的情况下完成新业务的下载及显示）</p><p><img src="http://img.blog.csdn.net/20170224120252522?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSm9uc1RhbmsyMDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Module"></p><p>这种高度模块化的结构还有一种优势，就是方便加载及快速卸载（MultiDex），还可以结合【动态加载】实现本地APP功能的快速更新（无需下载更新本地APK）。<br>【待定】如果我们以后开始一个新的项目时，可预见性的了解到该项目肯定会非常庞大或者易引起65535，不如考虑一下这种高度模块化的方式？提高项目灵活性的同时还可以为以后可能的重构铺路（假设性原则？假如会发生）</p><p><strong>方法二：</strong>创建一个AS的插件，使其支持自动导入和自动Fix。但难度较高，需要判断很多条件</p><p><strong>以上就是这段时间内重构项目时的经历及部分个人想法，如果以后有新的想法会及时更新本文。</strong></p><p><strong>另外，如果各位对于本博客中提到的任何思路或者架构有任何看法，欢迎讨论。这是这3天的个人考虑，基于个人能力及视野的限制，很有可能不完善，欢迎各位批评指正，共同进步</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文仅为个人观点，不完全符合模块化的标准定义及其拓展。思路类似，仅此而已。不可当做模块化的标准理解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果各位对于本博客中提到的任何思路或者架构有任何看法，欢迎讨论。以下仅是这3天的个人考虑，基于个人能力及视野的限制，很有可能不完善，欢迎批评指正，共同进步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转载请注明出处：&lt;a href=&quot;http://blog.csdn.net/jonstank2013?viewmode=contents&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/jonstank2013?viewmode=contents&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
      <category term="架构" scheme="http://imlzq.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>BroadcastReceiver —— 广播全解析</title>
    <link href="http://imlzq.com/2016/06/08/BroadcastReceiver/"/>
    <id>http://imlzq.com/2016/06/08/BroadcastReceiver/</id>
    <published>2016-06-07T16:00:00.000Z</published>
    <updated>2018-02-12T10:19:49.356Z</updated>
    
    <content type="html"><![CDATA[<p>广播是Android的四大组件之一，在Android的源码中也大量存在并使用了它，此外它也是一种常见的跨进程通信方式，由此可见它的重要性。</p><p>这里就对广播的底层实现进行一个解析</p><p><strong>本文中间包含了广播的代码细节，可以直接查看最后的“一句话总结”</strong></p><a id="more"></a>    <h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>首先，广播可以分为动态和静态注册两种方式。</p><p>动态注册的含义也就是在代码中注册广播，程序关闭是无效，在同等优先级下它会比静态注册的广播先调用</p><p>静态注册是指在AndroidManifest文件中注册的广播，由于APK在安装时静态注册的广播的信息会被PMS扫描并被添加到系统的表中，因此它在程序关闭时依然有效，例如开机自启就是属于检测自启的动作，如果发生该广播，就会启动自身的APP</p><p>上面的两种分类属于大分类，又可以将他们细分为普通广播、粘性广播、有序广播等等。</p><p><strong>有序广播</strong><br>使用sendOrderedBroadcast发送广播，高优先级的会先收到广播，然后由它决定是否处理、下传或者是终止该广播的传递</p><p><strong>粘性广播</strong><br>使用sendStickyBroadcast发送广播。如果发送时当前系统中并没有对应的广播接收器，那么它仍然会驻留在系统中，一旦有对应的广播接收器注册，那么就立即发送给它。</p><p>而如果它发送了多条，多条都没人接收的话怎么办呢？系统就会保存最后一条广播，因为这样就可以避免粘性广播在系统中的冗余。使用removeStickyBroadcast可以移除该Intent。</p><p>其实广播本来就是为了解耦，而粘性广播则更加解耦，因为接收方甚至可以完全不存在，这肯定是它的一个优势</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>onReceive是在主线程中被调用的，因此要注意不能在onReceive中出现耗时操作。如果一定要有，那么就最好开一个线程或者是交给service去处理</p><p>此外，只有当接受到了广播后，BroadcastReceiver这个类才会被实例化，不管它是动态还是静态注册的。<br>当内存不足时，receiver也会被系统回收掉，所以如果有长时间的任务，最好交给其他的来做，例如service</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><strong>动态注册</strong></p><ul><li>创建一个BroadcastReceiver</li><li>创建IntentFilter，并指定Action</li><li>registerReceiver(receivcer, intentFilter)</li><li>sendBroadcast(new Intent(“haha”));</li><li>unregisterReceiver(receiver);</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BroadcastReceiver </span>receiver = new <span class="keyword">BroadcastReceiver() </span>&#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onReceive(<span class="built_in">Context</span> <span class="built_in">context</span>, Intent intent) &#123;</span><br><span class="line">               Toast.makeText(MainActivity.this, <span class="string">"Receive"</span>, Toast.LENGTH_SHORT).<span class="keyword">show();</span></span><br><span class="line"><span class="keyword"> </span>          &#125;</span><br><span class="line">       &#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">       IntentFilter intentFilter = new IntentFilter()<span class="comment">;</span></span><br><span class="line">       intentFilter.<span class="keyword">addAction("haha");</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>      registerReceiver(receiver, intentFilter)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">sendBroadcast(new Intent(<span class="string">"haha"</span>))<span class="comment">;</span></span><br><span class="line">unregisterReceiver(receiver)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这样也就完成了一个广播的动态注册，但是需要注册的一点，广播注册之后一定要记得取消，一般是在onDestory中取消，其他的根据实际情况取消也是可以的。</p><p><strong>静态注册</strong><br>直接在AndroidManifest文件中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">".MyReceiver"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MY_BROADCAST"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>我们从动态注册的广播入手</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registerReceiver(<span class="name">receiver</span>, intentFilter)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这一行代码就是注册广播，那它做了什么呢？点进去看</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Intent registerReceiver(</span><br><span class="line">        BroadcastReceiver receiver, IntentFilter filter) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> mBase.<span class="title">registerReceiver</span><span class="params">(receiver, filter)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Intent registerReceiver(</span><br><span class="line">        BroadcastReceiver receiver, IntentFilter filter,</span><br><span class="line">        String broadcastPermission, Handler scheduler) &#123;</span><br><span class="line">        <span class="keyword">return</span> mBase.registerReceiver(receiver, filter, broadcastPermission,</span><br><span class="line">                scheduler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Intent registerReceiverAsUser(</span><br><span class="line">        BroadcastReceiver receiver, UserHandle user, IntentFilter filter,</span><br><span class="line">        String broadcastPermission, Handler scheduler) &#123;</span><br><span class="line">        <span class="keyword">return</span> mBase.registerReceiverAsUser(receiver, user, filter, broadcastPermission,</span><br><span class="line">                scheduler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我们就进入到了ContextWrapper文件中，而第三个方法我们暂时不用管他，因为它是被@hide标记了的，只关心前面两个方法。而前面的两个方法又分别调用了mBase也就是一个Context中对应的方法</p><p>对于ContextWarapper来说，它只是Context的一个代理类，也就是说它是为Context服务的，一些小工作也就是不是核心的东西Context都是交给它来做的。而一些核心工作最终又返还给Context来处理。这样就可以在一定程度上实现解耦以及工作职责的分离，Context完全不需要考虑那些它本来不需要也不想知道的事情。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Proxying implementation of Context that simply delegates all of its calls to</span></span><br><span class="line"><span class="comment"> * another Context.  Can be subclassed to modify behavior without changing</span></span><br><span class="line"><span class="comment"> * the original Context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ContextWrapper</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>Context:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">abstract</span> <span class="selector-tag">Intent</span> <span class="selector-tag">registerReceiver</span>(<span class="variable">@Nullable</span> BroadcastReceiver receiver,IntentFilter filter);</span><br></pre></td></tr></table></figure><p>我们的Context也是一个抽象类，它的具体实现是在ContextImpl中的。Context里面实际上就是一些资源的获取的工作，它还有几个子类就是Activity，Application和Service</p><p>ContextImpl:</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> Intent registerReceiver(BroadcastReceiver receiver, IntentFilter <span class="built_in">filter</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> registerReceiver(receiver, <span class="built_in">filter</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> Intent registerReceiver(BroadcastReceiver receiver, IntentFilter <span class="built_in">filter</span>,</span><br><span class="line">        <span class="keyword">String</span> broadcastPermission, Handler scheduler) &#123;</span><br><span class="line">    <span class="keyword">return</span> registerReceiverInternal(receiver, getUserId(),</span><br><span class="line">            <span class="built_in">filter</span>, broadcastPermission, scheduler, getOuterContext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> Intent registerReceiverAsUser(BroadcastReceiver receiver, UserHandle user,</span><br><span class="line">        IntentFilter <span class="built_in">filter</span>, <span class="keyword">String</span> broadcastPermission, Handler scheduler) &#123;</span><br><span class="line">    <span class="keyword">return</span> registerReceiverInternal(receiver, user.getIdentifier(),</span><br><span class="line">            <span class="built_in">filter</span>, broadcastPermission, scheduler, getOuterContext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Intent registerReceiverInternal(BroadcastReceiver receiver, <span class="built_in">int</span> userId,</span><br><span class="line">        IntentFilter <span class="built_in">filter</span>, <span class="keyword">String</span> broadcastPermission,</span><br><span class="line">        Handler scheduler, Context context) &#123;</span><br><span class="line">    IIntentReceiver rd = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span> &amp;&amp; context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                receiver, context, scheduler,</span><br><span class="line">                mMainThread.getInstrumentation(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = <span class="keyword">new</span> LoadedApk.ReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler, <span class="keyword">null</span>, <span class="keyword">true</span>).getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ActivityManagerNative.getDefault().registerReceiver(</span><br><span class="line">                mMainThread.getApplicationThread(), mBasePackageName,</span><br><span class="line">                rd, <span class="built_in">filter</span>, broadcastPermission, userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这下就一目了然，我们只有两个参数的registerReceiver最终也是调用了四个参数的方法，而后面的两个参数broadcastPermission以及Handler直接被设置为空。</p><p>最终的一个工作都是交给registerReceiverInternal来做的。首当其冲的就是这个IIntentReceiver类，这个类是做什么的呢？它实际上就是一个binder实体，通过这个东西我们就可以实现跨进程的信息传递了.它是由ReceiveDispather来管理的</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                    receiver, <span class="built_in">context</span>, scheduler,</span><br><span class="line">                    mMainThread.getInstrumentation(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">public IIntentReceiver getReceiverDispatcher(BroadcastReceiver r,</span><br><span class="line">            Context <span class="built_in">context</span>, Handler handler,</span><br><span class="line">            Instrumentation instrumentation, boolean registered) &#123;</span><br><span class="line">        synchronized (mReceivers) &#123;</span><br><span class="line">            LoadedApk.ReceiverDispatcher rd = null;</span><br><span class="line">            ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; <span class="built_in">map</span> = null;</span><br><span class="line">            <span class="keyword">if</span> (registered) &#123;</span><br><span class="line">                <span class="built_in">map</span> = mReceivers.<span class="built_in">get</span>(<span class="built_in">context</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">map</span> != null) &#123;</span><br><span class="line">                    rd = <span class="built_in">map</span>.<span class="built_in">get</span>(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rd == null) &#123;</span><br><span class="line">                rd = <span class="built_in">new</span> ReceiverDispatcher(r, <span class="built_in">context</span>, handler,</span><br><span class="line">                        instrumentation, registered);</span><br><span class="line">                <span class="keyword">if</span> (registered) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">map</span> == null) &#123;</span><br><span class="line">                        <span class="built_in">map</span> = <span class="built_in">new</span> ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;();</span><br><span class="line">                        mReceivers.<span class="built_in">put</span>(<span class="built_in">context</span>, <span class="built_in">map</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">map</span>.<span class="built_in">put</span>(r, rd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rd.validate(<span class="built_in">context</span>, handler);</span><br><span class="line">            &#125;</span><br><span class="line">            rd.mForgotten = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">return</span> rd.getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后，它返回了一个ActivityManagerNative.getDefault().registerReceiver()方法，继续跟进可以知道ActivityManagerNative.getDefault()实际上就是获取一个唯一的IActivityManager实例，它是一个单例模式。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieve the system's default/global activity manager.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="function">IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> gDefault.<span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="function">IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">                Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service binder = "</span> + b);</span><br><span class="line">            &#125;</span><br><span class="line">            IActivityManager am = asInterface(b);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">                Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service = "</span> + am);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> am;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T mInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mInstance = create();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么它返回的IActivityManager到底是谁呢？其实就是ActivityManagerService，简称AMS。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title">ActivityManagerNative</span></span></span><br><span class="line"><span class="class">        <span class="title">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span>, <span class="title">BatteryStatsImpl</span>.<span class="title">BatteryCallback</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>在我的博客<strong>杂谈——Android从启动到程序运行发生的事情</strong>中详解介绍到了AMS的功能，它实际上就是一个管理器，管理着非常多的东西，在系统中的作用极大。所有的Activity操作都是由Activity向他发出一个申请，它进行处理（比如向Zygote发送命令创建一个新的ActivityThread）之后返给Activity，Activity再交给Instrumentation来继续完成（例如生命周期的操作），而我们的注册广播和解除注册广播也是交给它来完成的。</p><p>由于对应的代码有点长，这里就不贴出来了，只是总括一下它以及sendBrodcast和unregister里面完成的东西。</p><h2 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h2><p>当一个广播进行发送时，它会被发送到AMS中并由它完成广播的传递，而AMS利用Binder机制，也就是上面的IIntentReceiver将他们传递到各个应用进程，应用进程再调用recevier的onReceive()的方法，这也就完成了一次广播的传递。</p><p>而对于注册广播来说，存在一个LoadApk对象，这个对象里面会包含关于本APK动态注册的所有receiver的哈希表，每当我们注册一个receiver，那么他就会被添加进入这个LoadApk的哈希表中。同时在我们注册的时候会记录用户对哪些receiver感兴趣，同一个Receiver可以注册多个IntentFilter，同样的也会使用一个ReceiverList来存储所有的IntentFilter信息。</p><p>所以当一个消息发来的时候，AMS会合并静态注册的表以及动态注册的表，同等优先级下动态注册的receiver在靠前的位置。匹配IntentFilter并查找对应的receiver哈希表，找到该Receiver，并利用Binder机制进行分发。</p><p>最后再安利一个网址，<strong><a href="https://android.googlesource.com/?format=HTML" target="_blank" rel="noopener">https://android.googlesource.com/?format=HTML</a></strong>，有很多代码Google处于安全性并没有直接暴露给开发者，所以在AndroidStudio中并不能查看到，例如上面的IIntentReceiver，如要想要查看的话就需要科学上网到上面的这个网址</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;广播是Android的四大组件之一，在Android的源码中也大量存在并使用了它，此外它也是一种常见的跨进程通信方式，由此可见它的重要性。&lt;/p&gt;
&lt;p&gt;这里就对广播的底层实现进行一个解析&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文中间包含了广播的代码细节，可以直接查看最后的“一句话总结”&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Gson</title>
    <link href="http://imlzq.com/2016/06/06/Gson/"/>
    <id>http://imlzq.com/2016/06/06/Gson/</id>
    <published>2016-06-05T16:00:00.000Z</published>
    <updated>2018-02-12T10:19:10.203Z</updated>
    
    <content type="html"><![CDATA[<p>以前写了一篇关于如何使用GSon的文章: <a href="http://imlzq.com/2015/12/07/gson/">Json数据的解析_Gson</a></p><p>这里就对Gson的内部实现原理进行一个总结</p><a id="more"></a>    <h2 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h2><p>Gson可以由两种方式创建，一种是通过Gson.Builder()的方式，另一种则是通过new Gson()来创建。</p><p>那这两种创建方式有什么不同呢？</p><p>第一种Gson.Builder()的方法没有使用反射，而new Gson()是使用了反射的。</p><p>在Gson内部存在着TypeAdapter，也就是根据不同的类型来适配，党我们使用Gson.Builder()创建时，使用的是自定义的TypeAdapter而不是默认的TypeAdapter，因此也就出现了一个为反射，一个不是反射</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Gson(Excluder excluder, FieldNamingStrategy fieldNamingPolicy, Map&lt;Type, InstanceCreator&lt;?&gt;&gt; instanceCreators, boolean serializeNulls, boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting, boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy, List&lt;TypeAdapterFactory&gt; typeAdapterFactories) &#123;</span><br><span class="line">        this.calls = new ThreadLocal();</span><br><span class="line">        this.typeTokenCache = Collections.synchronizedMap(new HashMap());</span><br><span class="line">        this.deserializationContext = new JsonDeserializationContext() &#123;</span><br><span class="line">            public &lt;T&gt; T deserialize(JsonElement json,<span class="built_in"> Type </span>typeOfT) throws JsonParseException &#123;</span><br><span class="line">                return Gson.this.fromJson(json, typeOfT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        this.serializationContext = new JsonSerializationContext() &#123;</span><br><span class="line">            public JsonElement serialize(Object src) &#123;</span><br><span class="line">                return Gson.this.toJsonTree(src);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public JsonElement serialize(Object src,<span class="built_in"> Type </span>typeOfSrc) &#123;</span><br><span class="line">                return Gson.this.toJsonTree(src, typeOfSrc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        this.constructorConstructor = new ConstructorConstructor(instanceCreators);</span><br><span class="line">        this.serializeNulls = serializeNulls;</span><br><span class="line">        this.generateNonExecutableJson = generateNonExecutableGson;</span><br><span class="line">        this.htmlSafe = htmlSafe;</span><br><span class="line">        this.prettyPrinting = prettyPrinting;</span><br><span class="line">        ArrayList factories = new ArrayList();</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.JSON_ELEMENT_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(ObjectTypeAdapter.FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(excluder);</span><br><span class="line">        factories.addAll(typeAdapterFactories);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.STRING_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.INTEGER_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.BOOLEAN_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.BYTE_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.SHORT_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.newFactory(Long.TYPE, Long.class, this.longAdapter(longSerializationPolicy)));</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.newFactory(Double.TYPE, Double.class, this.doubleAdapter(serializeSpecialFloatingPointValues)));</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.newFactory(Float.TYPE, Float.class, this.floatAdapter(serializeSpecialFloatingPointValues)));</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.NUMBER_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.CHARACTER_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.STRING_BUILDER_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.STRING_BUFFER_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.URL_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.URI_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.UUID_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.LOCALE_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.INET_ADDRESS_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.BIT_SET_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(DateTypeAdapter.FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.CALENDAR_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TimeTypeAdapter.FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(SqlDateTypeAdapter.FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.TIMESTAMP_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(ArrayTypeAdapter.FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.ENUM_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(TypeAdapters.CLASS_FACTORY);</span><br><span class="line">        factories.<span class="builtin-name">add</span>(new CollectionTypeAdapterFactory(this.constructorConstructor));</span><br><span class="line">        factories.<span class="builtin-name">add</span>(new MapTypeAdapterFactory(this.constructorConstructor, complexMapKeySerialization));</span><br><span class="line">        factories.<span class="builtin-name">add</span>(new ReflectiveTypeAdapterFactory(this.constructorConstructor, fieldNamingPolicy, excluder));</span><br><span class="line">        this.factories = Collections.unmodifiableList(factories);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那Gson如何判断我们使用的是哪一种方法创建呢？其实就是通过factories这个对象 add Factory的顺序来控制的。每次获取Adapter的时候都需要遍历Factories，而我们自定义的TypeAdapter在add时是会默认添加到靠前的位置。所以这样就避免了Gson的反射解析</p><h2 id="如何实现解析"><a href="#如何实现解析" class="headerlink" title="如何实现解析"></a>如何实现解析</h2><p>Gson中存在一个JsonParser类，它的作用就是将json串解析成JsonElement对象。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> JsonElement parse(<span class="keyword">String</span> json) throws JsonSyntaxException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.parse((Reader)(<span class="keyword">new</span> <span class="type">StringReader</span>(json)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> JsonElement parse(Reader json) throws JsonIOException, JsonSyntaxException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JsonReader e = <span class="keyword">new</span> <span class="type">JsonReader</span>(json);</span><br><span class="line">            JsonElement element = <span class="built_in">this</span>.parse(e);</span><br><span class="line">            <span class="keyword">if</span>(!element.isJsonNull() &amp;&amp; e.peek() != JsonToken.END_DOCUMENT) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonSyntaxException</span>(<span class="string">"Did not consume the entire document."</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> element;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedJsonException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonSyntaxException</span>(var4);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonIOException</span>(var5);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonSyntaxException</span>(var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> JsonElement parse(JsonReader json) throws JsonIOException, JsonSyntaxException &#123;</span><br><span class="line">        boolean lenient = json.isLenient();</span><br><span class="line">        json.setLenient(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        JsonElement e;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            e = Streams.parse(json);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (StackOverflowError var8) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonParseException</span>(<span class="string">"Failed parsing JSON source: "</span> + json + <span class="string">" to Json"</span>, var8);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonParseException</span>(<span class="string">"Failed parsing JSON source: "</span> + json + <span class="string">" to Json"</span>, var9);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            json.setLenient(lenient);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意上面的第三个方法，里面实际上返回的是Stream.parse(json)</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> JsonElement parse(JsonReader reader) throws JsonParseException &#123;</span><br><span class="line">        boolean isEmpty = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader.peek();</span><br><span class="line">            isEmpty = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> (JsonElement)TypeAdapters.JSON_ELEMENT.read(reader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EOFException var3) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isEmpty) &#123;</span><br><span class="line">                <span class="keyword">return</span> JsonNull.INSTANCE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonSyntaxException</span>(var3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedJsonException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonSyntaxException</span>(var4);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonIOException</span>(var5);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">JsonSyntaxException</span>(var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里又返回了TypeAdapters.JSON_ELEMENT.read(reader)方法，那我们就来看看read方法又返回了什么</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> JsonElement read(JsonReader <span class="keyword">in</span>) throws IOException &#123;</span><br><span class="line">                <span class="keyword">switch</span>(TypeAdapters.SyntheticClass_1.$SwitchMap$com$google$gson$stream$JsonToken[<span class="keyword">in</span>.peek().ordinal()]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:<span class="type"></span></span><br><span class="line"><span class="type">                    String number </span>= <span class="keyword">in</span>.nextString();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">JsonPrimitive</span>(<span class="keyword">new</span> <span class="type">LazilyParsedNumber</span>(number));</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:<span class="type"></span></span><br><span class="line"><span class="type">                    return new JsonPrimitive</span>(Boolean.valueOf(<span class="keyword">in</span>.nextBoolean()));</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:<span class="type"></span></span><br><span class="line"><span class="type">                    return new JsonPrimitive</span>(<span class="keyword">in</span>.nextString());</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:<span class="type"></span></span><br><span class="line"><span class="type">                    in</span>.nextNull();</span><br><span class="line">                    <span class="keyword">return</span> JsonNull.INSTANCE;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:<span class="type"></span></span><br><span class="line"><span class="type">                    JsonArray array </span>= <span class="keyword">new</span> <span class="type">JsonArray</span>();</span><br><span class="line">                    <span class="keyword">in</span>.beginArray();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(<span class="keyword">in</span>.hasNext()) &#123;</span><br><span class="line">                        array.add(<span class="built_in">this</span>.read(<span class="keyword">in</span>));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">in</span>.endArray();</span><br><span class="line">                    <span class="keyword">return</span> array;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>:<span class="type"></span></span><br><span class="line"><span class="type">                    JsonObject object </span>= <span class="keyword">new</span> <span class="type">JsonObject</span>();</span><br><span class="line">                    <span class="keyword">in</span>.beginObject();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(<span class="keyword">in</span>.hasNext()) &#123;</span><br><span class="line">                        object.add(<span class="keyword">in</span>.nextName(), <span class="built_in">this</span>.read(<span class="keyword">in</span>));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">in</span>.endObject();</span><br><span class="line">                    <span class="keyword">return</span> object;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">7</span>:<span class="type"></span></span><br><span class="line"><span class="type">                case 8</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">9</span>:<span class="type"></span></span><br><span class="line"><span class="type">                case 10</span>:</span><br><span class="line">                <span class="keyword">default</span>:<span class="type"></span></span><br><span class="line"><span class="type">                    throw new IllegalArgumentException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>从这上面的case我们不难看出，这里实际上就是根据不同的数据类型进行不同的数据解析。例如case 6,针对的是一个object类型，也就获取它的name和value放入object中，case 5则是针对的Array类型。</p><p>所以实际上就是解析Json，然后返回一个调用者想要的对象</p><h2 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h2><p>两种创建方式，区别在于一个是反射一个不是反射。如果想要避免使用反射，自定义TypeAdapter即可，factories会自动将其添加到list的前面，当使用时就会优先遍历到指定的adapter。<br>JsonParser对Json串进行解析处理，根据对应的数据类型最终返回给用户一个指定的对象。这也就是我们创建一个对象实体类的原因</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前写了一篇关于如何使用GSon的文章: &lt;a href=&quot;http://imlzq.com/2015/12/07/gson/&quot;&gt;Json数据的解析_Gson&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里就对Gson的内部实现原理进行一个总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Volley</title>
    <link href="http://imlzq.com/2016/06/04/Volley/"/>
    <id>http://imlzq.com/2016/06/04/Volley/</id>
    <published>2016-06-03T16:00:00.000Z</published>
    <updated>2018-02-12T10:20:57.958Z</updated>
    
    <content type="html"><![CDATA[<p>自从15年8月使用Volley以来，感触很多，源码也过了几次，第一篇博客<strong>三级缓存 Volley /Lrucache/DiskLrucache + AndroidStudio导出jar包 + upload to github</strong>就是使用Volley结合LruCache和DiskLruCache构建的三级缓存。其实关于Volley底层的实现在以前的博客中或多或少都有提及，例如缓存，队列等等，这篇博客就对它进行全方面的总结</p><a id="more"></a><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>首先，我们从缓存开始入手，毕竟这个算它的一个特点，也是一个优势。<br>我的第一篇博客实现三级缓存就利用的Volley的网络层缓存，LruCache的内存缓存和DiskLruCache的磁盘缓存。</p><p>Volley是实现了网络层缓存和内存缓存的。</p><h2 id="网络请求的发起流程"><a href="#网络请求的发起流程" class="headerlink" title="网络请求的发起流程"></a>网络请求的发起流程</h2><ol><li>检测是否开启缓存，如果开启，跳入２；不需要，加入网络队列中</li><li>判断是否存在该网络请求的缓存，如果存在且未过期，则直接返回该缓存结果。如果不存在，则将它加入网络队列并进入流程３<strong>【注释一】</strong></li><li>判断现有的网络队列中是否已经存在相同的网络请求，如果存在，则将该请求加入等待队列中，等待上一个相同请求的返回结果，也就是常说的请求合并</li><li>返回结果并处理</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/699911-4f50fb7c44adb5ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="volley"></p><p><strong>过期</strong><br>在上面的流程２也就是注释一的位置，Volley对于每一个缓存需要判断它们是否过期，而关于这个过期，则分为Softttl和ttl。</p><p>TTL的意思就是该缓存已经无效，必须重新从网络中获取。最终返回给调用者的是最新的那一次请求结果</p><p>而SoftTTL则会返回两次数据，第一次数据是本次的缓存数据，在返回该数据时也会将该网络请求加入到网络队列中，在请求数据返回后再次返给调用者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">byte</span>[] data;</span><br><span class="line">       <span class="keyword">public</span> String etag;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">long</span> serverDate;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">long</span> lastModified;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">long</span> ttl;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">long</span> softTtl;</span><br><span class="line">       <span class="keyword">public</span> Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.ttl &lt; System.currentTimeMillis();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refreshNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.softTtl &lt; System.currentTimeMillis();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>为什么要这么设计呢？</strong><br>个人思考：我觉得这个是对缓存的一个人性化设计。因为对于一个缓存来讲可能存在两种情况，第一种情况就是该缓存已经过期很久很久，完全不可用，所以就抛弃掉并重新获取。而软缓存就是那些过期不是特别久，也就是说在一定程度上可能还有些作用的缓存。例如现在有一个界面，刷新时可以让用户看到不久之前的信息，刷新结束后再将最新的数据呈现给用户。</p><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><p>NetWorkDispatcher类负责从网络工作队列中取出一个请求并执行。默认情况下存在４个工作线程为他服务</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NETWORK_THREAD_POOL_SIZE = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>而上面从定义的名字来说，是NetWork thread pool,但是实际上它并不是使用传统的线程池来管理的，而是使用一个NetWorkDispather数组来进行管理</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> NetworkDispatcher[] mDispatchers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> void start() &#123;</span><br><span class="line">        <span class="keyword">this</span>.stop();</span><br><span class="line">        <span class="keyword">this</span>.mCacheDispatcher = new CacheDispatcher(<span class="keyword">this</span>.mCacheQueue, <span class="keyword">this</span>.mNetworkQueue, <span class="keyword">this</span>.mCache, <span class="keyword">this</span>.mDelivery);</span><br><span class="line">        <span class="keyword">this</span>.mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.mDispatchers.length; ++i) &#123;</span><br><span class="line">            NetworkDispatcher networkDispatcher = new NetworkDispatcher(<span class="keyword">this</span>.mNetworkQueue, <span class="keyword">this</span>.mNetwork, <span class="keyword">this</span>.mCache, <span class="keyword">this</span>.mDelivery);</span><br><span class="line">            <span class="keyword">this</span>.mDispatchers[i] = networkDispatcher;</span><br><span class="line">            networkDispatcher.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是在这里就不难发现其实是存在一个问题的，因为如果工作线程发生异常退出，那么就无法生成一个新的工作线程来弥补之前这个空缺，因此这里极有可能会出现问题。当前总结的Volley版本是1.0.11，也就是第一篇博客中使用到的Volley版本，不知道现在是否已经优化</p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> compareTo(<span class="built_in">Request</span>&lt;T&gt; other) &#123;</span><br><span class="line">        <span class="built_in">Request</span>.Priority <span class="built_in">left</span> = this.getPriority();</span><br><span class="line">        <span class="built_in">Request</span>.Priority <span class="built_in">right</span> = other.getPriority();</span><br><span class="line">        return <span class="built_in">left</span> == <span class="built_in">right</span>?this.mSequence.intValue() - other.mSequence.intValue():<span class="built_in">right</span>.ordinal() - <span class="built_in">left</span>.ordinal();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的话主要就是根据每个请求的sequence来确定的，而sequence是在add的时候由进行获取，同时自增，也就是说它是由一个计数器进行管理的。也就可以保证每一次取任务取的都是队列头部的任务</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) &#123;</span><br><span class="line">        request.setRequestQueue(<span class="keyword">this</span>);</span><br><span class="line">        Set var2 = <span class="keyword">this</span>.mCurrentRequests;</span><br><span class="line">        synchronized(<span class="keyword">this</span>.mCurrentRequests) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mCurrentRequests.add(request);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        request.setSequence(<span class="keyword">this</span>.getSequenceNumber());</span><br><span class="line">        request.addMarker(<span class="string">"add-to-queue"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!request.shouldCache()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mNetworkQueue.add(request);</span><br><span class="line">            <span class="keyword">return</span> request;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Map var7 = <span class="keyword">this</span>.mWaitingRequests;</span><br><span class="line">            synchronized(<span class="keyword">this</span>.mWaitingRequests) &#123;</span><br><span class="line">                String cacheKey = request.getCacheKey();</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.mWaitingRequests.containsKey(cacheKey)) &#123;</span><br><span class="line">                    Object stagedRequests = (Queue)<span class="keyword">this</span>.mWaitingRequests.<span class="keyword">get</span>(cacheKey);</span><br><span class="line">                    <span class="keyword">if</span>(stagedRequests == <span class="literal">null</span>) &#123;</span><br><span class="line">                        stagedRequests = new LinkedList();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ((Queue)stagedRequests).add(request);</span><br><span class="line">                    <span class="keyword">this</span>.mWaitingRequests.put(cacheKey, stagedRequests);</span><br><span class="line">                    <span class="keyword">if</span>(VolleyLog.DEBUG) &#123;</span><br><span class="line">                        VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, new Object[]&#123;cacheKey&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.mWaitingRequests.put(cacheKey, (Object)<span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">this</span>.mCacheQueue.add(request);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> request;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> int getSequenceNumber() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mSequenceGenerator.incrementAndGet();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里需要注意一下，优先级高只是说明它先发出，并不能够确保它一定先返回</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Volley适合的请求为“短，小，快”，也就是说它并不适合大文件的下载操作，这是因为它存在一个内存缓存，100M的文件直接给你缓存到内存中，这样的体验就不是特别好。而如果单纯的把缓存关闭掉的话，就不如使用Retrofit + OKHttp了<br>上面还有一些超时重发请求，反序列化操作未总结，因为觉得这个不算什么吧，因此就此略过，而他们的使用其实也是可以自己再二次封装一下的，这样就可以让原来已经很简洁的代码变得更简洁</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从15年8月使用Volley以来，感触很多，源码也过了几次，第一篇博客&lt;strong&gt;三级缓存 Volley /Lrucache/DiskLrucache + AndroidStudio导出jar包 + upload to github&lt;/strong&gt;就是使用Volley结合LruCache和DiskLruCache构建的三级缓存。其实关于Volley底层的实现在以前的博客中或多或少都有提及，例如缓存，队列等等，这篇博客就对它进行全方面的总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>关于Android和Java的ClassLoader相关知识盘点</title>
    <link href="http://imlzq.com/2016/05/29/classloader/"/>
    <id>http://imlzq.com/2016/05/29/classloader/</id>
    <published>2016-05-28T16:00:00.000Z</published>
    <updated>2018-02-12T10:16:34.037Z</updated>
    
    <content type="html"><![CDATA[<p>已经很久没有写博客，就再利用这段时间把该以前总结过的又再总结一次吧，好多东西光记在脑子里也不行。那首先就用Android的ClassLoader开个头，接着就再总结一下Volley, Retrofit, OKHttp, Rxjava, HashMap，Gson,Fresco，动态加载，热点修复以及算法吧。</p><a id="more"></a>    <h2 id="Java中的Classloader"><a href="#Java中的Classloader" class="headerlink" title="Java中的Classloader"></a>Java中的Classloader</h2><p><strong>分类</strong></p><ul><li>Classloader：这个类是一个抽象类，除了Bootstrap classloader之外所有的classloader都继承它</li><li>Bootstrap Classloader：这个加载器是由C++编写的，在Java虚拟机启动后初始化，主要负责加载核心类库。它并不是Classloader的子类，而是由JVM自己实现的一个加载器，嵌在JVM当中</li><li>Extension Classloader：它是由Bootstrap classloader加载而来，同时也是它的子类，由Java编写，主要负责加载扩展的Javaclass</li><li>System Classloader：它也是由java编写，主要负责加载应用程序自身的类</li></ul><p><strong>程序加载的流程</strong><br>当运行一个程序的时候，JVM启动，然后加载Bootstrap Classloader，该ClassLoader加载Java核心API，也就在这个时候加载了ExtClassloader和AppClassloader，之后就调用ExtClassloader去加载拓展API，最后AppClassloader加载CLASSPATH目录下定义的classes</p><h2 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h2><p>当我们需要使用到一个类时，就会加载该类（也就是动态加载）。<br>首先JVM就会使用当前线程的类加载向上递归，也就是找到它的父类，如果父类能够加载，那么就由父类来加载，依次递归，如果不能，就再下传给子类。</p><p><strong>为什么会存在双亲委派模式</strong><br>在Java中，我们判断两个类是不是同一个类，实际上就是判断他们两个是不是由同一个类加载器加载而来的。如果同一个类Ａ，被两个不同的加载器加载，那么就会生成两份A的字节码，而Java就会认为这两个A并不是同一个类。java判断两个类一样的条件：　classloader id + package id + class id。</p><p>因此，双亲委派模式的意义就出来了：为了防止内存中出现多份同样的字节码。类A和类B都想加载system类，如果没有双亲委派的话，那么它们分别使用自己的加载器去加载就会产生两份一模一样的字节码。而如果使用了双亲委派模式，首先就会尝试将System类交给Bootstrap类加载，A使用它加载完毕后，当B再来请求加载时，BootStrap就可以直接返回内存中已经加载了的System类了</p><p>P.S : 在开发中是否还遇到过这样的一种情况？类A想通过类型强转的方式转换为类B，但是编译报错，提示不能转换，这个其实也就是因为他们是由不同的类加载器加载而来，存在一个壁垒</p><h2 id="Android中的Classloader"><a href="#Android中的Classloader" class="headerlink" title="Android中的Classloader"></a>Android中的Classloader</h2><p>Android虚拟机dalvik，现在已经换成ART，也是一种虚拟机，类似于JVM，他们也都实现了双亲委派模式用来防止出现多份重复的字节码，同样由于Android自身的一些特性以及虚拟机的选择，它们是存在一些区别的</p><p>Android下面的字节码文件在编译完成后会再被打包成dex类的文件，同时经过dexopt的优化（优化Class文件中的各种函数表，变量表等等）形成odex文件，它本质也还是class文件，因此加载它的话肯定就需要特殊的类加载器来加载咯</p><p>首先，最开始也是我们的Classloader抽象类，它有一个子类叫做BaseDexClassloader，而这个类呢又是DexClassloader和PathClassloader的父类。当然同时也存在着SystemLoader, BootClassloader这些其他的加载器。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">ClassLoader</span></span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> BaseDexClassLoader(<span class="keyword">String</span> dexPath, File optimizedDirectory, <span class="keyword">String</span> libraryPath, ClassLoader parent) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt; findClass(<span class="keyword">String</span> name) throws ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected URL findResource(<span class="keyword">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Enumeration&lt;URL&gt; findResources(<span class="keyword">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> findLibrary(<span class="keyword">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected synchronized Package getPackage(<span class="keyword">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> toString() &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public abstract <span class="built_in">class</span> ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The 'System' ClassLoader - <span class="keyword">the</span> one <span class="keyword">that</span> <span class="keyword">is</span> responsible <span class="keyword">for</span> loading</span><br><span class="line">     * classes <span class="keyword">from</span> <span class="keyword">the</span> classpath. It <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">equal</span> <span class="keyword">to</span> <span class="keyword">the</span> bootstrap <span class="built_in">class</span> loader -</span><br><span class="line">     * <span class="keyword">that</span> one handles <span class="keyword">the</span> built-<span class="keyword">in</span> classes.</span><br><span class="line">     *</span><br><span class="line">     * Because <span class="keyword">of</span> a potential <span class="built_in">class</span> initialization race <span class="keyword">between</span> ClassLoader <span class="keyword">and</span></span><br><span class="line">     * java.lang.System, reproducible when using JDWP <span class="keyword">with</span> <span class="string">"suspend=y"</span>, we defer</span><br><span class="line">     * creation <span class="keyword">of</span> <span class="keyword">the</span> system <span class="built_in">class</span> loader <span class="keyword">until</span> <span class="keyword">first</span> use. We use a static</span><br><span class="line">     * inner <span class="built_in">class</span> <span class="keyword">to</span> <span class="keyword">get</span> synchronization <span class="keyword">at</span> init <span class="built_in">time</span> <span class="keyword">without</span> having <span class="keyword">to</span> sync <span class="keyword">on</span></span><br><span class="line">     * <span class="keyword">every</span> access.</span><br><span class="line">     *</span><br><span class="line">     * @see <span class="comment">#getSystemClassLoader()</span></span><br><span class="line">     */</span><br><span class="line">    static private <span class="built_in">class</span> SystemClassLoader &#123;</span><br><span class="line">        public static ClassLoader loader = ClassLoader.createSystemClassLoader();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的这个是SystemClassloader，用来加载classpath中的类的。熟悉的延迟加载单例模式</p><h2 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h2><p>这个类是用来加载一些还没有被安装的字节码文件的。因此不管是动态加载还是热点修复，都是使用这个类加载器来加载从服务器获得的apk中的文件。关于动态加载和热点修复在以后的博客中会有介绍，其实本来好早之前就打算写一个动态加载的库的，github上我库都建好了，但是临时来了点事就没做了，找个时间补回来</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DexClassLoader(<span class="keyword">String</span> dexPath, <span class="keyword">String</span> optimizedDirectory, <span class="keyword">String</span> libraryPath, ClassLoader parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>((<span class="keyword">String</span>)<span class="literal">null</span>, (File)<span class="literal">null</span>, (<span class="keyword">String</span>)<span class="literal">null</span>, (ClassLoader)<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="PathClassloader"><a href="#PathClassloader" class="headerlink" title="PathClassloader"></a>PathClassloader</h2><p>这个类就是用来加载所有已经被安装被安装好了的字节码文件</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">BaseDexClassLoader</span></span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> PathClassLoader(<span class="keyword">String</span> dexPath, ClassLoader parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>((<span class="keyword">String</span>)<span class="literal">null</span>, (File)<span class="literal">null</span>, (<span class="keyword">String</span>)<span class="literal">null</span>, (ClassLoader)<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PathClassLoader(<span class="keyword">String</span> dexPath, <span class="keyword">String</span> libraryPath, ClassLoader parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>((<span class="keyword">String</span>)<span class="literal">null</span>, (File)<span class="literal">null</span>, (<span class="keyword">String</span>)<span class="literal">null</span>, (ClassLoader)<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已经很久没有写博客，就再利用这段时间把该以前总结过的又再总结一次吧，好多东西光记在脑子里也不行。那首先就用Android的ClassLoader开个头，接着就再总结一下Volley, Retrofit, OKHttp, Rxjava, HashMap，Gson,Fresco，动态加载，热点修复以及算法吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
      <category term="Java" scheme="http://imlzq.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>个人知识点总结：Java并发</title>
    <link href="http://imlzq.com/2016/04/13/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%9AJava%E5%B9%B6%E5%8F%91/"/>
    <id>http://imlzq.com/2016/04/13/个人知识点总结：Java并发/</id>
    <published>2016-04-13T09:55:08.000Z</published>
    <updated>2018-02-12T03:40:35.827Z</updated>
    
    <content type="html"><![CDATA[<p>Java并发实在是一个很深的问题，这里只简单记录一下Java并发的知识点。水太深，如果不花大量的时间感觉完全hold不住，但是目前的精力完全不够，兴趣也不在这</p><a id="more"></a>    <p>##什么是线程安全性</p><blockquote><p>某个类的行为和其规范完全一致<br>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的</p></blockquote><p>##原子操作(Atomic Operation)</p><p>原子操作是指不会被线程调度机制打断的操作，这种操作一旦开始，就会一直运行到结束，中间不会有任何的上下文切换，它是不可分割的。</p><p>举一个常见的例子：a++，这个操作就不是一个原子性的操作，那么在多个线程访问调用的时候，a的最终结果就很有可能不是我们的预期值。因为实际上a++这个操作可以分为已下三步：获取a的值，更新a的值，写回a的值。</p><p>##缓存一致性</p><p>在共享内存的多处理器体系架构中，每个处理器都拥有自己的缓存，并且定期地与主内存进行协调，在不同的处理器架构中提供了不同级别的缓存一致性。</p><p>这个缓存一致性可以通过volatile关键字来加深理解。</p><p>##Volatile关键字</p><p>Volatile是一种较弱的同步机制，用来确保将变量的更新操作通知到其他线程，当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。<br>但是有一点是需要注意的，被volatile修饰的变量的的操作也应该是原子性的，不然同样会出先问题。<br>例如：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Volatile</span> <span class="built_in">int</span> a = <span class="number">0</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 非原子性操作，使用<span class="keyword">volatile</span>不能保证同步，改用Synchronized</span><br><span class="line">a++<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>而为什么Volatile能够实现这种功能呢？<br>这个要从它的实现原理说起，在x86处理器下通过工具获取JIT编译器生成的汇编指令来看Volatile的写操作实际上做了什么吧。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x01a3de1d</span>: movb $0x0,<span class="number">0x1104800</span>(%esi);</span><br><span class="line"><span class="number">0x01a3de24</span>: lock addl $0x0,(%esp);</span><br></pre></td></tr></table></figure><p>有Volatile变量修饰的共享变量进行写操作的时候会多第二行代码，lock指令修饰。<br>而lock指令会做什么事呢？</p><ul><li>将当前处理器缓存行的数据写回到系统内存</li><li>该写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效</li></ul><p>在上面介绍缓存一致性的时候提到了，在共享内存的多处理器体系架构中，每个处理器都拥有自己的缓存，并且定期地与主内存进行协调，在不同的处理器架构中提供了不同级别的缓存一致性。<br>那么这个时候也就有了下面的事情：<br>处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存中再进行操作，但操作完成后不确定什么时候会写回到内存，如果对声明了Volatile变量进行些操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。而由于缓存一致性协议，每个处理器会通过嗅探在总线上传播的数据在来检查自己缓存的值是不是国旗了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态。当处理器要对这个数据进行修改操作的时候，就会强制从系统内存中重新读取数据到处理器缓存里。<br>这也就是Volatile实现的原理。</p><p>##重排序</p><p>刚才上面总结到了重排序的概念，那什么是重排序呢？</p><p>简单的理解就是，当程序在执行的时候，如果JVM认为两行代码之间的结果互不影响，那么在执行的过程中可能就会产生一个乱序的结果。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span>; </span><br><span class="line">b = <span class="number">4</span>;</span><br></pre></td></tr></table></figure></p><p>正常情况下我们会觉得a = 3肯定是比b=4先执行的，因为它在b的上面，但是实际上并不是这样，因为b的运行结果并不依赖上一行a的结果，因此JVM就能够对两行代码进行一个重排序，可能a先执行，也可能b先执行</p><p><strong>为什么要采用重排序？</strong><br>重排序通常是编译器或运行时环境为了优化程序性能而采取的。它可以分为两类：编译器重排序和运行时重排序。</p><p>顺序一致性模型：理想的模型是，各种指令执行的顺序是唯一且有序的，这个顺序就是它们被编写在代码中的顺序，与处理器或其他因素无关</p><p>顺序一致性模型的缺点：效率过低</p><p>编译器重排序的典型就是通过调整指令顺序，在不改变程序语义的前提下，尽可能的减少寄存器的读取、存储次数、充分服用寄存器的存储值。</p><p>假设第一条指令计算一个值赋给变量A并存放在寄存器中，第二条指令与A无关但需要占用寄存器（假设它将占用A所在的那个寄存器），第三条指令使用A的值且与第二条指令无关。那么如果按照顺序一致性模型，A在第一条指令执行过后被放入寄存器，在第二条指令执行时A不再存在，第三条指令执行时A重新被读入寄存器，而这个过程中，A的值没有发生变化。通常编译器都会交换第二和第三条指令的位置，这样第一条指令结束时A存在于寄存器中，接下来可以直接从寄存器中读取A的值，降低了重复读取的开销。</p><p>##并发时的乱序问题</p><p>上面总结的重排序可以引起乱序，同样的，在并发时对局部变量进行操作也有可能会产生乱序的问题。因为在每个线程中都拥有一个独立的栈，也就是独立的线程空间，当它运行时，会从主内存中读取该变量的值并存放到自己的线程栈中，对变量操作完成后就会把值写回主内存空间。<br>但是这里就有一个问题了，那就是变量的写回操作发生的时间并不能够确定。就算是线程A比线程B先读取数据，仍然有可能线程B先把值写回主内存，最终同样会造成一个得到的结果并不是我们想要的值。</p><p>##Happens-before（先行发生）</p><p>Java内存模型（JMM）为程序中所有的操作定义了一个偏序关系，称之为Happens-before。如果想要保证执行操作B的线程看到操作A的结果（无论A和B是否在同一个线程中执行），那么在A和B之间必须满足Happens-Before关系。如果两个操作时间缺乏Happens-Before关系，那么JVM可以对它们任意地重排序。</p><p>当一个变量被多个线程读取并且至少被一个线程写入时，如果在读写操作之间没有按照Happens-Before来排序，那么就会产生数据竞争的问题。</p><p>Happens-Before规则包括：</p><ul><li><strong>程序顺序规则</strong>：如果程序中操作A在操作B之前，那么在线程中A操作将在B操作之前执行</li><li><strong>监视器锁规则</strong>：在监视器锁上的解锁操作必须在同一个监视器锁上的加锁操作之前执行</li><li><strong>volatile变量规则</strong>：对volatile变量的写入操作必须在对该变量的读操作之前执行</li><li><strong>线程启动规则</strong>：在线程上对Thread.Start的调用必须在该县城中执行任何操作之前执行</li><li><strong>线程结束规则</strong>：县城中的任何操作都必须在其他线程检测到该线程已经结束之前执行，或者在Thread.join中成功返回，或者在调用THread.isAlive时返回false</li><li><strong>中断规则</strong>：当一个线程在另一个线程上调用interrupt时，必须在被中断线程检测到interrupt调用之前执行</li><li><strong>终结器规则</strong>：对象的构造函数必须在启动终结器之前执行</li><li><strong>传递性</strong>：操作A在B之前，B在C之前，那么A就必须在C之前执行</li></ul><p>例如线程A：y=1 -》 lock M -》 x=1 -》unlock M<br>线程B： lock M -》 i=x -》 unlock M -》 j=y</p><p>当两个线程使用同一个锁进行同步时，在它们之间的happens-Before关系就是：A的unlock M执行完成之后才能执行B的lock M方法，如果这两个线程是在不同的锁上进行同步的，那么就不能推断它们之间的动作顺序，因为在这两个线程的操作之间并不存在Happens-Before关系</p><p>##Lock / Synchronized / ReentrantLock（独占锁 / 悲观锁）</p><p><strong>Synchronized</strong><br>内置锁，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码，另一个线程必须等待当前线程执行完这个代码快以后才能执行该代码块（未执行之前，该线程被阻塞）。同时，它也是一个可重入锁（Lock均可重入）</p><p>但是这里有一个很关键的地方：当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。</p><p>之前在单例模式中总结到了双重检查锁定模式，但是由于双重检查锁定模式在一定情况下存在很严重的Bug，就没有在该博客中写出。这里就对双重检查锁定模式进行一个分析</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;    </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;    </span><br><span class="line">               <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;    </span><br><span class="line">                  singleton = <span class="keyword">new</span> Singleton();   </span><br><span class="line">               &#125;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> singleton;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为在new Singleton()的过程中，实际上是可以分为很多步的，可大致分为三件事情：</p><ul><li>给Singleton的实例分配内存</li><li>调用Singleton的构造函数，初始化字段</li><li>将singleton对象指向分配的内存空间（singleton != null）</li></ul><p>但是，Java编译器是允许处理器乱序执行的，所有有可能让第二步和第三步乱序执行，也就是说如果在第二步被乱序（安排到了最后一步执行），当他还没执行的时候切换到了线程B，这个时候就会因为singleton已经不为null而直接跳出if判断，这样的话在我们以后的代码运行过程中使用的就是一个未经构造函数初始化的一个对象。<strong>【现在好像有在JDK层面有改进因此可以正常使用，具体的不清楚，以后再修改】</strong></p><p><strong>Lock</strong></p><p>Lock是一个接口，它里面主要包含了下面的几个方法：<br>P.S.源码里的注释太多，这里就不贴了<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>Lock它与内置加锁机制不同，它提供的是一种无条件的、可轮训的、定时的以及可中断的锁获取操作，所有的加锁和解锁的方法都是显式的。</p><p>一句话总结：Synchronized算是Lock的简化版本，功能比之较少但是在程序执行完成后会自动释放锁，而Lock必须手动释放锁</p><p><strong>ReentrantLock</strong><br>ReentrantLock它实现了Lock接口，并提供了与synchronized相同的互斥性和内存可见性。<br>那为什么还要提供一种机制跟内置锁十分相似的新加锁机制呢？<br>因为内置锁在一定情况下存在局限性，例如无法中断一个正在等待获取锁的进程，或者无法在请求获取一个锁时无限地等待下去，；无法实现非阻塞结构的加锁规则。</p><p>而在ReentrantLock中，它可以实现轮询锁、定时锁、中断锁等多种加锁方式，这也让它的应用场景变的更多。</p><p>同时在性能上：如果有越多的资源被耗费在锁的管理和调度上，那么应用程序得到的资源就越少。锁的实现方式越好，就需要越少的系统调用和上下文切换，并且在共享内存总线上的内存同步通信量也越少。<br>在Java5中，ReentrantLock的性能比内置锁高了很多，但是在Java6中内置锁采取了一种类似与ReentrantLock中使用的算法来管理内置锁，有效地提高了可伸缩性，因此在Java6中，它们的吞吐量就非常接近了。</p><p>在公平性上，ReentrantLock可以创建一个非公平锁（默认）也可以创建一个公平锁。<br>公平锁：线程按照发出请求的顺序来获得锁（先到先得，不准插队）<br>非公平锁：当一个线程请求非公平锁时，如果在发出请求的同时该锁的状态变为可用，那么就跳过队列中所有的等待队列立刻获得锁（也就是允许插队。申请的时候锁为可用状态就直接获取）</p><p>而对于公平锁和非公平锁来说，它们的效率也是显而易见的：<br>公平性将由于在挂起线程和恢复线程时存在的开销而极大的降低效率。<br>而非公平性由于是在请求时锁已经为可用状态就直接获取，不需要进行什么额外的操作，因此效率更高。<br>实际上：确保被阻塞的线程能最终获得锁就已经够用了，并且实际开销也小很多。</p><p>当在一个激烈竞争的情况下，恢复一个被挂起的线程与这个线程真正开始运行之间存在着严重的延迟，这样的话就影响了效率。而如果我们采用非公平锁（也就是ReentrantLock的默认方式），线程A释放锁时，B被唤醒然后尝试获取锁，与此同时C也请求这个锁，那么C很有可能会在B被完全唤醒之前获得、使用以及释放这个锁。也就有可能会造成B获得锁的时刻并没有推迟，C也更早的获得了锁</p><p>那什么时候应该使用公平锁呢？<br>当持有锁的时间相对较长，或者请求锁的平均时间间隔较长，那么就应该使用公平锁。</p><p><strong>在Synchronize和ReentrantLock中如何选择</strong><br>上面总结了这么多，好像ReentrantLock的优点比Synchronize好太多，那为什么不直接取消掉Synchronize呢？我们自己该怎么选择呢？</p><p>Synchronize很重要的几个优点就是：</p><ul><li>无需手动释放锁，程序自动完成。如果在使用Lock的过程中忘记在finally中释放锁，那么虽然代码表面上能正式运行，但是实际上已经出了大问题，还有可能伤到其他代码。所以一般仅仅是在做一些内置锁不能完成的需求时才考虑使用ReentrantLock，例如中断锁、轮询锁等等</li><li>调试的问题：Synchronized在线程存储中能够给出在哪些调用帧中获得了哪些锁，并能够检测和识别发生死锁的进程。而ReentrantLock它只是一个对象，JVM不知道哪些线程持有这个。</li></ul><p>非阻塞同步机制（乐观锁）<br>-<br>加锁机制始终会存在一个挂起唤醒的操作，如果有多个线程同时请求锁，那么JVM就需要借助操作系统的功能，而在挂起和恢复线程等过程中存在着很大的开销，并且通常存在着较长时间的中断。如果在竞争激烈的时候，调度开销与工作开销的比值会非常高。</p><p>此外，如果一个线程正在等待锁时，它不能做任何其他事情，同时如果被阻塞线程的优先级较高，而持有锁的线程优先级较低，那么问题更严重，也就是发生了优先级反转。即：高优先级的线程必须等到低优先级的线程释放锁，从而导致它的优先级会降低至低优先级线程的级别。</p><p>而最近的很多并发算法研究都侧重于非阻塞同步的机制，例如：Lock-free算法</p><p>##Lock-free算法（无锁）</p><p>这个算法中主要使用到了一个CAS机制（Compare and swap），它包含了3个值，需要读写的内存位置V，需要进行比较的值A， 要写入的新值B。<br>它的原理就是：</p><blockquote><p>当且仅当V的值等于A时，CAS才会通过原子方式用新值B来更新V的值，否则不执行任何操作</p></blockquote><p>而当多个线程常识使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他的线程都将失败。但是失败的线程并不会被挂起，而是被告知在这次竞争中失败，并可以尝试再次尝试。由于一个线程在竞争CAS时失败不会阻塞，因此它可以决定是否重新尝试，或者执行一些恢复操作，再或者不执行任何操作，这种灵活性就大大减少了与锁相关的活跃性风险。</p><p>##结语</p><p>并发的水实在太深，不花精力实在难以hold住，这里简单记录一下Java并发的知识点</p><p>##参考</p><ul><li>《Java并发编程实战》</li><li><a href="http://ifeve.com/volatile/" target="_blank" rel="noopener">聊聊并发系列博客</a></li><li><a href="http://www.jb51.net/article/49699.htm" target="_blank" rel="noopener">JAVA中JVM的重排序详细介绍</a> ——也就是Java中为什么要使用重排序</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java并发实在是一个很深的问题，这里只简单记录一下Java并发的知识点。水太深，如果不花大量的时间感觉完全hold不住，但是目前的精力完全不够，兴趣也不在这&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://imlzq.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://imlzq.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【置顶】杂谈——Android从启动到程序运行发生的事情</title>
    <link href="http://imlzq.com/2016/04/12/EventsFromAppClick/"/>
    <id>http://imlzq.com/2016/04/12/EventsFromAppClick/</id>
    <published>2016-04-11T16:00:00.000Z</published>
    <updated>2018-03-19T11:36:42.669Z</updated>
    
    <content type="html"><![CDATA[<p>转载请注明出处<br>博客地址：imlzq.com<br>作者：李中权</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好久没有写博客了，瞬间感觉好多学了的东西不进行一个自我的总结与消化总归变不成自己的。通过博客可能还可以找到一些当初在学习的时候没有想到的问题。想了半天，从大二上学期自学Android以来还没有对Android从启动到程序运行期间进行一个完整的归纳，刚好最近又学到了一些新东西，那就以这篇博客为媒介，总结一下从Android启动到程序运行期间发生的所有事吧。包括什么ClassLoader, JVM,IPC, 消息处理机制要是总结到了就顺带BB一下。但是这里就不包含很多细节了，比如为什么PMS内部为什么要这么构造，好处是什么，如果我来设计的话我会怎么设计啊这种暂时就不总结了，因为我觉得以我现在的水平还有学习精力来说把这些细节都一个个的弄清楚有点没抓住重点。现阶段还是先能够了解整个流程，有个大局观才是最重要的。至于以后如果有需要或者是有精力的时候再一个个的突破。</p><p><strong>发现本文的错误或者遗漏后会立刻更改</strong></p><a id="more"></a><h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><p>首先，我们知道，Android是基于Linux的一个操作系统，它可以分为五层，下面是它的层次架构图，可以记一下，因为后面应该会总结到SystemServer这些Application Framework层的东西<br><img src="http://gityuan.com/images/boot/android-arch1.png" alt="img"><br>Android的五层架构从上到下依次是应用层，应用框架层，库层，运行时层以及Linux内核层。</p><p>而在Linux中，它的启动可以归为一下几个流程：<br>Boot Loader-》初始化内核-》。。。。。。<br>当初始化内核之后，就会启动一个相当重要的祖先进程，也就是init进程，在Linux中所有的进程都是由init进程直接或间接fork出来的。</p><p>而对于Android来说，前面的流程都是一样的，而当init进程创建之后，会fork出一个Zygote进程，这个进程是所有Java进程的父进程。我们知道，Linux是基于C的，而Android是基于Java的（当然底层也是C）。所以这里就会fork出一个Zygote Java进程用来fork出其他的进程。<strong>【断点1】</strong></p><p>总结到了这里就提一下之后会谈到的几个非常重要的对象以及一个很重要的概念。</p><ul><li>ActivityManagerServices（AMS）：它是一个服务端对象，负责所有的Activity的生命周期，<strong>ActivityThread会通过Binder与之交互，而AMS与Zygote之间进行交互则是通过Socket通信（IPC通信在之后会总结到）</strong></li><li>ActivityThread：它也就是我们俗称的UI线程/主线程，它里面存在一个main()方法，这也是APP的真正入口，当APP启动时，就会启动ActivityThread中的main方法，它会初始化一些对象，然后开启<strong>消息循环队列（之后总结）</strong>，之后就会Looper.loop死循环，如果有消息就执行，没有就等着，也就是事件驱动模型（edt）的原理。</li><li>ApplicationThread：它实现了IBinder接口，是Activity整个框架中客户端和服务端AMS之间通信的接口，同时也是ActivityThread的内部类。这样就有效的把ActivityThread和AMS绑定在一起了。</li><li>Instrumentation：这个东西我把它理解为ActivityThread的一个工具类，也算是一个劳动者吧，对于生命周期的所有操作例如onCreate最终都是直接由它来执行的。</li></ul><p><strong>Android系统中的客户端和服务器的概念</strong><br>在Android系统中其实也存在着服务器和客户端的概念，服务器端指的就是所有App共用的系统服务，比如上面的AMS，PackageManagerService等等，这些系统服务是被所有的App共用的，当某个App想要实现某个操作的时候，就会通知这些系统服务。</p><h2 id="继续断点1"><a href="#继续断点1" class="headerlink" title="继续断点1"></a>继续断点1</h2><p>当Zygote被初始化的时候，会fork出System Server进程，这个进程在整个的Android进程中是非常重要的一个，地位和Zygote等同，它是属于Application Framework层的，Android中的所有服务，例如AMS, WindowsManager, PackageManagerService等等都是由这个SystemServer fork出来的。所以它的地位可见一斑。</p><p>而当System Server进程开启的时候，就会初始化AMS，同时，会加载本地系统的服务库，创建系统上下文，创建ActivityThread及开启各种服务等等。而在这之后，就会开启系统的Launcher程序，完成系统界面的加载与显示。<strong>【断点2】</strong></p><h2 id="Context总结"><a href="#Context总结" class="headerlink" title="Context总结"></a>Context总结</h2><p>Context是一个抽象类，下面是它的注释信息，摘自源码。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Interface <span class="keyword">to</span> <span class="keyword">global</span> information <span class="keyword">about</span> an <span class="built_in">application</span> environment.  This <span class="keyword">is</span></span><br><span class="line"> * an abstract <span class="built_in">class</span> <span class="keyword">whose</span> implementation <span class="keyword">is</span> provided <span class="keyword">by</span></span><br><span class="line"> * <span class="keyword">the</span> Android system.  It</span><br><span class="line"> * allows access <span class="keyword">to</span> <span class="built_in">application</span>-specific resources <span class="keyword">and</span> classes, <span class="keyword">as</span> well <span class="keyword">as</span></span><br><span class="line"> * up-calls <span class="keyword">for</span> <span class="built_in">application</span>-level operations such <span class="keyword">as</span> launching activities,</span><br><span class="line"> * broadcasting <span class="keyword">and</span> receiving intents, etc.</span><br><span class="line"> */</span><br><span class="line">public abstract <span class="built_in">class</span> Context &#123;</span><br></pre></td></tr></table></figure><p>从上面的这段话可以简单理解一下，Context是一个关于应用程序环境的全局变量接口，通过它可以允许去获得资源或者类，例如启动Activity,广播，intent等等。</p><p>我的理解：Context的具体实现是Application, Activity,Service，通过Context能够有权限去做一些事情，其实我觉得就是一个运行环境的问题。</p><p><strong>需要注意的地方</strong><br>Android开发中由于很多地方都包含了Context的使用，因此就必须要注意到内存泄露或者是一些可能会引起的问题。</p><p>例如在Toast中，它的Context就最好设置为Application Context，因为如果Toast在显示东西的时候Activity关闭了，但是由于Toast仍然持有Activity的引用，那么这个Activity就不会被回收掉，也就造成了内存泄露。</p><h2 id="Toast的相关总结"><a href="#Toast的相关总结" class="headerlink" title="Toast的相关总结"></a>Toast的相关总结</h2><p>上面举例的时候举到了Toast，其实Toast也是很有意思的一个东西，它的show方法其实并不是显示一个东西这么简单。<br>Toast实际上是一个队列，会通过show方法把新的任务加入到队列当中去，列队中只要存在消息就会弹出来使用，而队列的长度据说默认是40个（这是网上搜出来的，我在源码中没找到对应的设置，感觉也没啥必要就没找了）。<br>所以这里就要注意一下show这个操作了，它并不是显示内容，而是把内容入队列。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Show the view for the specified duration.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mNextView == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"setView must have been called"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        INotificationManager service = getService();</span><br><span class="line">        String pkg = mContext.getOpPackageName();</span><br><span class="line">        TN tn = mTN;</span><br><span class="line">        tn.mNextView = mNextView;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            service.enqueueToast(pkg, tn, mDuration);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// Empty</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Handler的内存泄露"><a href="#Handler的内存泄露" class="headerlink" title="Handler的内存泄露"></a>Handler的内存泄露</h2><p>对于Handler来说，如果我们直接在AndroidStudio中创建一个非静态内部类Handler，那么Handler这一大片的区域会被AS标记为黄色，这个应该很多人都遇到过吧。实际上是因为这样设置会造成内存泄露，因为每一个非静态内部类都会持有一个外部类的引用，那么这里也就产生了一个内存泄露的可能点，如果当Activity被销毁时没有与Handler解除，那么Handler仍然会持有对该Activity的引用，那么就造成了内存泄露。</p><p><strong>解决方案</strong><br>使用static修饰Handler，这样也就成了一个静态内部类，那么就不会持有对外部类的引用了。而这个时候就可以在Handler中创建一个WeakReference（弱引用）来持有外部的对象。只要外部解除了与该引用的绑定，那么垃圾回收器就会在发现该弱引用的时候立刻回收掉它。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>关于垃圾回收的相关总结看我之前的博客，传送门：<a href="http://blog.csdn.net/jonstank2013/article/details/50922958" target="_blank" rel="noopener">JVM原理及底层探索</a></p><h2 id="四种引用方式"><a href="#四种引用方式" class="headerlink" title="四种引用方式"></a>四种引用方式</h2><p>上面扯到了弱引用，就再BB一下四种引用方式吧。</p><ul><li>强引用：垃圾回收器打死都不会回收掉一个强引用的，那怕是出现OOM也不会回收掉强引用，所有new出来的都是强引用。</li><li>软引用：垃圾回收器会在内存不足的情况下回收掉软引用，如果内存充足的话不会理它</li><li>弱引用：它跟软引用类似，但是它更脆弱，只要垃圾回收器一发现它，就会立刻回收掉它。比如一个对象持有一个强引用和弱引用，当强引用被取消时，那么只要GC发现了它，就会立刻回收掉。只是GC发现它的这个过程是不确定的，有可能不会马上发生，所以它可能还会多活一会，中间存在一个优先级。</li><li>虚引用：它跟上面3种方式都不同。我对虚引用的理解就是如果一个对象持有虚引用，那么就可以在被GC回收前进行一些设定好的工作等等。因为虚引用有个机制，因为虚引用必须和引用队列联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就回在回收对象的内存前，把这个虚引用加入到与之关联的引用队列中。而程序如果判断到引用队列中已经加入了虚引用，那么就可以了解到被引用的对象马上就要被垃圾回收了，这个时候就可以做些被回收之前的事情啦。</li></ul><h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><p>类加载器按层次从顶层到下依次为Boorsrtap ClassLoader（启动类加载器）,Extension ClassLoader（拓展类加载器），ApplicationClassLoader（应用程序类加载器）</p><p>判断两个类是否是同一个类就是看它们是否是由同一个类加载器加载而来。</p><p>这里就需要介绍一下双亲委派模式了：<br>双亲委派模式的意思就是：除了启动类加载器之外，其余的加载器都需要指定一个父类的加载器，当需要加载的时候会先让父类去试着加载，如果父类无法加载也就是找不到这个类的话就会让子类去加载</p><p>好处：防止内存中出现多份同样的字节码</p><p>比如类A和类B都要加载system类，如果不是委托的话，类A就会加载一份，B也会加载一份，那么就会出现两份SYstem字节码<br>如果使用委托机制，会递归的向父类查找，也就是首选用Bootstrap尝试加载，如果找不到再向下，如果A用这个已经加载了的话会直接返回内存中的system而不需要重新加载。那么就只会存在一份</p><h2 id="延迟加载的应用：单例模式"><a href="#延迟加载的应用：单例模式" class="headerlink" title="延迟加载的应用：单例模式"></a>延迟加载的应用：单例模式</h2><p>对于Java来说，类是需要使用到时才会加载，这里也就出现了一个延迟加载的效果。而在延迟加载的时候，会默认保持同步。这也就产生了一种单例模式的方式，具体的看我之前的博客：<a href="http://blog.csdn.net/jonstank2013/article/details/50903830" target="_blank" rel="noopener">设计模式_单例模式</a></p><p>我觉得在android所有的创建单例模式方法中里延迟加载方式是最好吧，虽然枚举比延迟加载更好，effiective java中也很推荐，但是并不怎么适用于Android，Android里枚举的消耗是static的两倍，延迟加载的话只要我们在使用延迟加载方式时做好反序列化的返回值readResolve()准备就好了。</p><h2 id="继续断点2"><a href="#继续断点2" class="headerlink" title="继续断点2"></a>继续断点2</h2><p>上面BB了太多其他的，现在有点缓不过来，下次自己看自己博客的时候会不会都被自己的思路带得乱七八糟的。</p><p>上面的时候我们就已经完成了整个Android系统的开机以及初始化。接下来就可以B一下从点击APP图标开始到APP内部程序运行起来的流程了。</p><p>当我们点击屏幕时，触摸屏的两层电极会连接在一起，也就产生了一个电压（具体的我忘了，书上有，图找不到了），当产生电压的时候，就可以通过对应的驱动把当前按压点的XY坐标传给上层，这里也就是操作系统。操作系统在获取到XY值的时候，就会对按压点的范围进行一个判断，如果确定按压点处于一个APP图标或者是Button等等的范围中时，操作系统也就会认为用户当前已经点击了这个东西，启动对应的监听。</p><p>而当系统判断我们点击的是APP图标时，该App就由Launcher开始启动了<strong>【断点3】</strong></p><h2 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h2><p>Launcher是一个继承自Activity，同时实现了点击事件，长按事件等等的一个应用程序。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> <span class="keyword">extends</span> <span class="title">Activity</span></span></span><br><span class="line"><span class="class">        <span class="title">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span>,<span class="title">OnLongClickListener</span>, <span class="title">LauncherModel</span>.<span class="title">Callbacks</span>,<span class="title">View</span>.<span class="title">OnTouchListener</span></span></span><br></pre></td></tr></table></figure><p>当我们点击一个APP的图标时，会调用Launcher内部的startActivitySafely()方法，而这个方法则会进行两件事，一个是启动目标activity，另一个功能就是捕获异常ActivityNotFoundException，也就是常见的“找不到activity,是否已经在androidmenifest文件中注册？”。而在startActivity方法中，经过一系列的转换最终会调用到startActivityForResult这个方法。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line">   public void startActivity(Intent intent, <span class="variable">@Nullable</span> Bundle options) &#123;</span><br><span class="line">       <span class="selector-tag">if</span> (options != null) &#123;</span><br><span class="line">           <span class="selector-tag">startActivityForResult</span>(intent, -<span class="number">1</span>, options);</span><br><span class="line">       &#125; <span class="selector-tag">else</span> &#123;</span><br><span class="line">           <span class="comment">// Note we want to go through this call for compatibility with</span></span><br><span class="line">           <span class="comment">// applications that may have overridden the method.</span></span><br><span class="line">           <span class="selector-tag">startActivityForResult</span>(intent, -<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>所以实际上，我对整个Android的界面是这样理解的：<br>当系统完成初始化以及各种服务的创建之后，就会启动Launcher这个应用程序（它也是继承自Activity的，包含自己对应的xml布局文件），然后再把各种图标按照一个正常APP布局的方式放在上面，当我们点击APP图标时，也就相当于在Launcher这个APP应用程序中通过startActivity（在底层最后会转为startActivityForResult）来启动这个APP。简单的讲，我觉得就是一个主要的APP（Launcher）里面启动了其他的功能APP，例如QQ、微信这些。<strong>【个人理解，如果以后发现不对再修改】</strong></p><h2 id="Android中点击事件的处理"><a href="#Android中点击事件的处理" class="headerlink" title="Android中点击事件的处理"></a>Android中点击事件的处理</h2><p>当我们手指按下时，Android是如何处理点击事件的呢？如何确定是让哪一个控件来处理呢？<br>简单一句话：层层传递-冒泡的方式处理<br>举个例子：现在公司来了个小项目，老板一看分配给经理做，经理一看分配给小组长，小组长一看好简单，分配给组员。如果在这个传递过程中（也就是还为分配到最底部时），某一层觉得我来负责这个比较好的话就会拦截掉这个消息，然后把它处理了，下面的就收不到有消息的这个通知。如果一直到了底层的话，组员如果能完成，就完成它。如果不能完成，那么就报告给组长，说组长我做不来，边学边做要影响进度。组长一看我也做不来，就给经理，经理一看我也不会，就给老板。这样也就一层层的传递了。<br>总结一下就是消息从上到下依次传递，如果在传递的过程中被拦截了就停止下传。如果没有被拦截，就一直传递到底部，如果底部不能够消耗该消息，那么就又一层层的返回来，返给上层，直到被消耗或者是到达最顶层。</p><p>在Android中，存在三个重要的方法：</p><ul><li>dispathTouchEvent(MotionEvent ev)</li><li>onInterceptTouchEvent(MotionEvent ev)</li><li>onTouchEvent(MotionEvent ev)</li></ul><p>第一个方法负责事件的分发，它的返回值就是表示是否消耗当前事件。<br>第二个方法是用于判断是否拦截该消息，如果当前View拦截了某个时间，那么在同一个事件序列中，此方法不会被再次调用。返回结果表示是否拦截当前事件<br>第三个方法就是处理事件。返回结果表示是否消耗当前事件，如果不小号，则在同一时间序列中，当前View无法再次接收到事件。</p><p>对于一个根ViewGroup来说，点击事件产生后，首先会传递给它，调用它的dispath方法。如果这个ViewGroup的onIntercept方法返回true就表示它要拦截当前事件，false就表示不拦截，这个时候事件就会继续传递给子元素，接着调用子元素的dispath方法，直到被处理。</p><h2 id="滑动冲突"><a href="#滑动冲突" class="headerlink" title="滑动冲突"></a>滑动冲突</h2><p>顺带总结一下滑动冲突的解决吧<br>View的滑动冲突一般可以分为三种：</p><ul><li>外部滑动和内部滑动方向不一致</li><li>外部滑动方向和内部滑动方向一致</li><li>嵌套上面两种情况</li></ul><p>比如说一个常见的，外部一个ListView，里面一个ScrollView。这个时候该怎么解决呢？其实这里想到了ViewPager，它里面实际上是解决了滑动冲突的，可以借鉴一下它的。</p><p><strong>滑动处理规则</strong><br>一般来说，我们可以根据用户手指滑动的方向以及角度来判断用户是要朝着哪个方向去滑动。而很多时候还可以根据项目的需求来指定一套合适的滑动方案。</p><p><strong>外部拦截法</strong><br>这种方法就是指所有的点击时间都经过父容器的拦截处理，如果父容器需要此时间就拦截，如果不需要此事件就不拦截。通过重写父容器的onInterceptTouchEvent方法：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.<span class="string">ACTION_DOWN:</span></span><br><span class="line">intercepted = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MotionEvent.<span class="string">ACTION_MOVE:</span></span><br><span class="line"><span class="keyword">if</span>(父类容器需要) &#123;</span><br><span class="line">intercepted = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">intercepted = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MotionEvent.<span class="string">ACTION_UP:</span></span><br><span class="line">intercepted = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> intercepted;</span><br></pre></td></tr></table></figure><p>这里有一点需要注意，ACTION_DOWN事件父类容器就必须返回false，因为如果父类容器拦截了的话，后面的Move等所有事件都会直接由父类容器处理，就无法传给子元素了。UP事件也要返回false，因为它本身来说没有太多的意义，但是对于子元素就不同了，如果拦截了，那么子元素的onClick事件就无法触发。</p><p><strong>内部拦截法</strong><br>这种方法指的是父容器不拦截任何时间，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交给父容器进行处理。它需要配合requestDisallowInterceptTouchEvent方法才能正常工作。我们需要重写子元素的dispatch方法</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.<span class="string">ACTION_DOWN:</span></span><br><span class="line">parent.requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">MotionEvent.<span class="string">ACTION_MOVE:</span></span><br><span class="line"><span class="keyword">if</span>(父容器需要此类点击事件) &#123;</span><br><span class="line">parent.requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br></pre></td></tr></table></figure><p>这种方法的话父类容器需要默认拦截除了ACTION_DOWN以外的其他时间，这样当子元素调用request方法的时候父元素才能继续拦截所需的事件。</p><p><strong>其他的</strong><br>如果觉得上面两个方式太复杂，看晕了，其实也可以自己根据项目的实际需要来指定自己的策略实现。例如根据你手指按的点的位置来判断你当前触碰的是哪个控件，以此来猜测用户是否是要对这个控件进行操作。如果点击的是空白的地方，就操作外部控件即可。</p><p><strong>【等有时间了就把ViewPager的处理总结一下，挺重要的】</strong></p><h2 id="继续断点3"><a href="#继续断点3" class="headerlink" title="继续断点3"></a>继续断点3</h2><ul><li>当我们点击桌面的APP图标时，Launcher进程会采用Binder的方式向AMS发出startActivity请求</li><li>AMS在接收到请求之后，就会通过Socket向Zygote进程发送创建进程的请求</li><li>Zygote进程会fork出新的子进程（APP进程）</li><li>之后APP进程会再向AMS发起一次请求，AMS收到之后经过一系列的准备工作再回传请求。</li><li>APP进程收到AMS返回的请求后，会利用Handler向主线程发送LAUNCH_ACTIVITY消息</li><li>主线程在收到消息之后，就创建目标Activity，并回调onCreate()/onStart()/onResume()等方法，UI渲染结束后便可以看到App主界面<br><strong>【断点4】</strong></li></ul><h2 id="Handler-Looper-Message-Queue-ThreadLocal机制"><a href="#Handler-Looper-Message-Queue-ThreadLocal机制" class="headerlink" title="Handler/Looper/Message Queue/ThreadLocal机制"></a>Handler/Looper/Message Queue/ThreadLocal机制</h2><p>Android的消息机制主要是指Handler的运行机制，Handler的运行需要底层的MessageQueue和Looper的支撑</p><p>虽然MessageQueue叫做消息队列，但是实际上它内部的存储结构是单链表的方式。由于Message只是一个消息的存储单元，它不能去处理消息，这个时候Looper就弥补了这个功能，Looper会以无限循环的形式去查找是否有新消息，如果有的话就处理消息，否则就一直等待（机制等会介绍）。而对于Looper来说，存在着另外的一个很重要的概念，就是ThreadLocal。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal它并不是一个线程，而是一个可以在每个线程中存储数据的数据存储类，通过它可以在指定的线程中存储数据，数据存储之后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到该线程的数据。<br>举个例子，多个线程通过同一个ThreadLocal获取到的东西是不一样的，就算有的时候出现的结果是一样的（偶然性，两个线程里分别存了两份相同的东西），但他们获取的本质是不同的。</p><p>那为什么有这种区别呢？为什么要这样设计呢？<br>先来研究一下为什么会出现这个结果。<br>在ThreadLocal中存在着两个很重要的方法，get和set方法，一个读取一个设置。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the value of this variable for the current thread. If an entry</span></span><br><span class="line"><span class="comment">    * doesn't yet exist for this variable on this thread, this method will</span></span><br><span class="line"><span class="comment">    * create an entry, populating the value with the result of</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #initialValue()&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the current value of the variable for the calling thread.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(<span class="meta-string">"unchecked"</span>)</span></span><br><span class="line">   <span class="keyword">public</span> T <span class="keyword">get</span>() &#123;</span><br><span class="line">       <span class="comment">// Optimized for the fast path.</span></span><br><span class="line">       Thread currentThread = Thread.currentThread();</span><br><span class="line">       Values values = values(currentThread);</span><br><span class="line">       <span class="keyword">if</span> (values != <span class="literal">null</span>) &#123;</span><br><span class="line">           Object[] table = values.table;</span><br><span class="line">           int index = hash &amp; values.mask;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.reference == table[index]) &#123;</span><br><span class="line">               <span class="keyword">return</span> (T) table[index + <span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           values = initializeValues(currentThread);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> (T) values.getAfterMiss(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sets the value of this variable for the current thread. If set to</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> null&#125;, the value will be set to null and the underlying entry will</span></span><br><span class="line"><span class="comment">    * still be present.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value the new value of the variable for the caller thread.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> void <span class="keyword">set</span>(T value) &#123;</span><br><span class="line">       Thread currentThread = Thread.currentThread();</span><br><span class="line">       Values values = values(currentThread);</span><br><span class="line">       <span class="keyword">if</span> (values == <span class="literal">null</span>) &#123;</span><br><span class="line">           values = initializeValues(currentThread);</span><br><span class="line">       &#125;</span><br><span class="line">       values.put(<span class="keyword">this</span>, value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>摘自源码<br>首先研究它的get方法吧，从注释上可以看出，get方法会返回一个当前线程的变量值，如果数组不存在就会创建一个新的。<br>这里有几个很重要的词，就是“当前线程”和“数组”。<br>这里提到的数组对于每个线程来说都是不同的，values.table，而values是通过当前线程获取到的一个Values对象，因此这个数组是每个线程唯一的，不能共用，而下面的几句话也更直接了，获取一个索引，再返回通过这个索引找到数组中对应的值。这也就解释了为什么多个线程通过同一个ThreadLocal返回的是不同的东西。</p><p>那这里为什么要这么设置呢？翻了一下书，搜了一下资料：</p><ul><li>ThreadLocal在日常开发中使用到的地方较少，但是在某些特殊的场景下，通过ThreadLocal可以轻松实现一些看起来很复杂的功能。一般来说，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑使用ThreadLocal。例如在Handler和Looper中。对于Handler来说，它需要获取当前线程的Looper，很显然Looper的作用域就是线程并且不同的线程具有不同的Looper，这个时候通过ThreadLocal就可以轻松的实现Looper在线程中的存取。如果不采用ThreadLocal，那么系统就必须提供一个全局的哈希表供Handler查找指定的Looper，这样就比较麻烦了，还需要一个管理类。</li><li>ThreadLocal的另一个使用场景是复杂逻辑下的对象传递，比如监听器的传递，有些时候一个线程中的任务过于复杂，就可能表现为函数调用栈比较深以及代码入口的多样性，这种情况下，我们又需要监听器能够贯穿整个线程的执行过程。这个时候就可以使用到ThreadLocal，通过ThreadLocal可以让监听器作为线程内的全局对象存在，在线程内通过get方法就可以获取到监听器。如果不采用的话，可以使用参数传递，但是这种方式在设计上不是特别好，当调用栈很深的时候，通过参数来传递监听器这个设计太糟糕。而另外一种方式就是使用static静态变量的方式，但是这种方式存在一定的局限性，拓展性并不是特别的强。比如有10个线程在执行，就需要提供10个监听器对象。</li></ul><h2 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h2><p>上面提到了Handler/Looper/Message Queue，它们实际上是一个整体，只不过我们在开发中接触更多的是Handler而已，Handler的主要作用是将一个任务切换到某个指定的线程中去执行，而Android之所以提供这个机制是因为Android规定UI只能在主线程中进程，如果在子线程中访问UI就会抛出异常。</p><p><strong>为什么Android不允许在子线程访问UI</strong><br>其实这一点不仅仅是对于Android,对于其他的所有图形界面现在都采用的是单线程模式。<br>因为对于一个多线程来说，如果子线程更改了UI，那么它的相关操作就必须对其他子线程可见，也就是Java并发中很重要的一个概念，线程可见性，Happen-before原则<strong>【下篇博客总结一下自己对Java并发的理解吧，挺重要的，总结完后再把传送门贴过来】</strong>而一般来说，对于这种并发访问，一般都是采用加锁的机制，但是加锁的机制存在很明显的问题：让UI访问间的逻辑变得复杂，同时效率也会降低。甚至有的时候还会造成死锁的情况，这个时候就麻烦了。<br>而至于究竟能不能够实现这种UI界面的多线程呢？SUN公司的某个大牛（忘了是谁，很久之前看的，好像是前副总裁）说：“行肯定是没问题，但是非常考技术，因为必须要考虑到很多种情况，这个时候就需要技术专家来设计。而这种设计出来的东西对于广大普通程序员来说又是异常头疼的，就算是实现了多线程，普通人用起来也是怨声载道的。所以建议还是单线程”。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>顺带着BB一下死锁。</p><p><strong>死锁的四个必要条件</strong></p><ol><li>互斥条件：资源不能被共享，只能被同一个进程使用</li><li>请求与保持条件：已经得到资源的进程可以申请新的资源</li><li>非剥夺条件：已经分配的资源不能从相应的进程中被强制剥夺</li><li>循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程占用的资源</li></ol><p>举个常见的死锁例子：进程A中包含资源A,进程B中包含资源B，A的下一步需要资源B，B的下一步需要资源A，所以它们就互相等待对方占有的资源释放，所以也就产生了一个循环等待死锁。</p><p><strong>处理死锁的方法</strong></p><ol><li>忽略该问题，也就是鸵鸟算法。当发生了什么问题时，不管他，直接跳过，无视它。</li><li>检测死锁并恢复</li><li>资源进行动态分配</li><li>破除上面的四种死锁条件之一</li></ol><h2 id="继续消息机制"><a href="#继续消息机制" class="headerlink" title="继续消息机制"></a>继续消息机制</h2><p>MessageQueue主要包含两个操作：插入和读取，读取操作本身会伴随着删除操作，插入和读取对应的方法分别为enqueueMessage和next，其中enqueueMessage的作用是往消息队列中插入一条消息，而next的作用是从消息队列中取出一条消息并将其从消息队列中移除。这也就是为什么使用的是一个单链表的数据结构来维护消息列表，因为它在插入和删除上比较有优势（把下一个连接的点切换一下就完成了）。</p><p>而对于MessageQueue的插入操作来说，没什么可以看的，也就这样吧，主要需要注意的是它的读取方法next。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">Message <span class="keyword">next</span>() &#123;</span><br><span class="line">       <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">       <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">       <span class="comment">// which is not supported.</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">       <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">       <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">               Binder.flushPendingCommands();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">               Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">               Message msg = mMessages;</span><br><span class="line">               <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                   <span class="keyword">do</span> &#123;</span><br><span class="line">                       prevMsg = msg;</span><br><span class="line">                       msg = msg.<span class="keyword">next</span>;</span><br><span class="line">                   &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                       <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                       nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">// Got a message.</span></span><br><span class="line">                       mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           prevMsg.<span class="keyword">next</span> = msg.<span class="keyword">next</span>;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           mMessages = msg.<span class="keyword">next</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       msg.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">                       <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                       msg.markInUse();</span><br><span class="line">                       <span class="keyword">return</span> msg;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// No more messages.</span></span><br><span class="line">                   nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">               <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                   dispose();</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">               <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">               <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">               <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                       &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                   pendingIdleHandlerCount = mIdleHandlers.<span class="keyword">size</span>();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                   mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">               &#125;</span><br><span class="line">               mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Run the idle handlers.</span></span><br><span class="line">           <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">               <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">               mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   keep = idler.queueIdle();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                   Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                       mIdleHandlers.remove(idler);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">           pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">           <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">           nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>源码有点长，总结一下就是：<br>next方法它是一个死循环，如果消息队列中没有消息，那么next方法就会一直阻塞在这里，当有新的消息来的时候，next方法就会返回这条信息并将其从单链表中移除。</p><p>而这个时候勒Looper就等着的，它也是一直循环循环，不停地从MessageQueue中查看是否有新消息，如果有新消息就会立刻处理，否则就会一直阻塞在那里。而对于Looper来说，它是只能创建一个的，这个要归功与它的prepare方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Initialize the current thread as a looper.</span></span><br><span class="line"><span class="comment">     * This gives you a chance to create handlers that then reference</span></span><br><span class="line"><span class="comment">     * this looper, before actually starting the loop. Be sure to call</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #quit()&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       prepare(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从这里我们就可以看出该prepare方法会首先检测是否已经存在looper了，如果不存在，就创建一个新的；如果存在，就抛出异常。<br>而之后使用Looper.loop()就可以开启消息循环了。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">      <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">      <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">      Binder.clearCallingIdentity();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">          <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">          Printer logging = me.mLogging;</span><br><span class="line">          <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">              logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.<span class="keyword">target</span> + <span class="string">" "</span> +</span><br><span class="line">                      msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          msg.<span class="keyword">target</span>.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">              logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.<span class="keyword">target</span> + <span class="string">" "</span> + msg.callback);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">          <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">          <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">              Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                      + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                      + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                      + msg.<span class="keyword">target</span>.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                      + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          msg.recycleUnchecked();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从这里面我们可以看到它也是个死循环，会不停的调用queue.next()方法来获取信息，如果没有，就return,如果有就处理。</p><p><strong>注意</strong><br>当然了，这里有一个很重要的点，一般可能会忘，那就是在子线程中如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程就会一直处于等待状态，而如果退出Looper之后，这个线程就会立刻终止，所以建议不需要使用的时候终止Looper。</p><p><strong>Handler</strong><br>上面总结了Looper和MessageQueue，这里就对Handler进行一个总结吧。它的工作主要包含消息的发送和接受过程，消息的发送可以通过post的一系列方法以及send的一系列方法来实现，post的一系列方法最终是通过send的一系列方法来实现的。<br>实际上它发送消息的过程仅仅是向消息队列中插入了一条消息，MessageQueue的next方法就会返回这条消息给Looper，Looper在收到消息之后就会开始处理了。最后由Looper交给Handler处理（handleMessage()方法）。</p><h2 id="IPC通信"><a href="#IPC通信" class="headerlink" title="IPC通信"></a>IPC通信</h2><p>上面总结完了Android的消息处理机制，那么就顺带总结一下IPC通信吧，毕竟上面提到过那么多次Binder和Socket。</p><p>资料：<a href="https://www.zhihu.com/question/39440766#answer-31119460" target="_blank" rel="noopener">为什么Android要采用Binder作为IPC机制？</a><br>知乎上面的回答相当的好，这个博主对系统底层也是颇有钻研，学习。</p><p>这里就结合上面的知乎回答以及加上《Linux程序设计》还有一本Linux内核剖析（书名忘了但是讲得真的非常好），掺杂一些个人的理解。</p><p><strong>进程的定义</strong><br>UNIX标准把进程定义为：“一个其中运行着一个或多个进程的地址控件和这些线程所需要的系统资源”。目前，可以简单的把进程看做正在运行的程序。</p><p>进程都会被分配一个唯一的数字编号，我们成为PID（也就是进程标识符），它通常是一个取值范围从2到32768的正整数。当进程被启动时，系统将按顺序选择下一个未被使用的数字作为PID，当数字已经回绕一圈时，新的PID重新从2开始，数字1一般是为init保留的。在进程中，存在一个自己的栈空间，用于保存函数中的局部变量和控制函数的调用与返回。进程还有自己的环境空间，包含专门为这个进程建立的环境变量，同时还必须要维护自己的程序计数器，这个计数器用来记录它执行到的位置，即在执行线程中的位置。<br>在Linux中可以通过system函数来启动一个进程</p><p><strong>守护进程</strong><br>这里就需要提到一个守护进程了，这个在所有的底层中经常都会被提到。<br>在linux或者unix操作系统中在系统引导的时候会开启很多服务，这些服务就叫做守护进程。为了增加灵活性，root可以选择系统开启的模式，这些模式叫做运行级别，每一种运行级别以一定的方式配置系统。 守护进程是脱离于终端并且在后台运行的进程。守护进程脱离于终端是为了避免进程在执行过程中的信息在任何终端上显示并且进程也不会被任何终端所产生的终端信息所打断。<br>守护进程常常在系统引导装入时启动，在系统关闭时终止。如果想要某个进程不因为用户或终端或其他的变化而受到影响，那么就必须把这个进程变成一个守护进程</p><p><strong>防止手机服务后台被杀死</strong><br>是不是在手机的设置界面看当前正在运行的服务时会发现有的APP不止存在一个服务？有的APP后台存在两个，有的存在三个？有的流氓软件也会这么设置，这样的话就可以一直运行在后台，用户你关也关不了（倒不是说所有这么设置的都是流氓软件，因为有的软件需要保持一个长期的后台在线，这是由功能决定的）。</p><p>这里有两种方法（可能还有更多，这里只总结我了解的）：</p><ul><li>第一种方法就是利用android中service的特性来设置，防止手机服务后台被杀死。通过更改onStartCommand方法的返回值，将service设置为粘性service，那么当service被kill的时候就会将服务的状态返回到最开始启动的状态，也就是运行的状态，所以这个时候也就会再次重新运行。但是需要注意一点，这个时候的intent值就为空了，获取的话需要注意一下这一点。</li><li>第二种就是fork出一个C的进程，因为在Linux中，子类进程在父类被杀死销毁的时候不会随之杀死，它会被init进程领养。所以也就可以使用这一个方法，利用主进程fork出一个C进程在后台运行，一旦检测到服务被杀死（检测的方式多种，可使用观察者模式，广播，轮询等等），就重启服务即可</li></ul><p><strong>IPC通信</strong><br>上面总结了进程的相关基础，这里就开始总结一下进程间通信（IPC<br>）的问题了。<br>现在Linux现有的所有IPC方式：</p><ol><li>管道：在创建时分配一个page大小的内存，缓存区大小有限</li><li>消息队列：信息复制两次，额外的cpu消耗，不适合频繁或信息量大的通信</li><li>共享内存：无需复制，共享缓冲区直接附加到进程虚拟地址控件，速度是在所有IPC通信中最快的。但是进程间的同步问题操作系统无法实现，必须由各进程利用同步工具解决。</li><li>Socket：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信</li><li>信号量：常作为一种锁机制。</li><li>信号：不适用于信息交换，更适用于进程件中断控制，例如kill process</li></ol><p>到了这里，就有了问题，为什么在Linux已经存在这么多优良的IPC方案时，Android还要采取一种新的Binder机制呢？<br><strong>猜测</strong>：我觉得Android采用这种新的方式（当然也大面积的同时使用Linux的IPC通信方式），最多两个原因：</p><ol><li>推广时手机厂商自定义ROM底层的保密性或者公司之间的关系。</li><li>在某些情况下更适合手机这种低配置，对效率要求极高，用户体验极其重要的设备</li></ol><p><strong>资料</strong></p><p>对于Binder来说，存在着以下的优势：</p><ul><li><strong>性能角度</strong>：Binder的数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，而共享内存是一次都不需要拷贝，因此Binder的性能仅次于共享内存</li><li><strong>稳定性来说</strong>：Binder是基于C/S架构的，也就是Client和Server组成的架构，Client端有什么需求，直接发送给Server端去完成，架构清晰，分工明确。而共享内存的实现方式复杂，需要充分考虑访问临界资源的并发同步问题，否则可能会出现死锁等问题。从稳定性来说，Binder的架构优于共享内存。</li><li><strong>从安全的角度</strong>：Linux的传统IPC方式的接收方无法获得对方进程可靠的UID（用户身份证明）/PID（进程身份证明），从而无法鉴别对方身份，而Android是一个对安全性能要求特别高的操作系统，在系统层面需要对每一个APP的权限进行管控或者监视，对于普通用户来说，绝对不希望从App商店下载偷窥隐射数据、后台造成手机耗电等问题。传统的Linux IPC无任何保护措施，完全由上层协议来确保。而在Android中，操作系统为每个安装好的应用程序分配了自己的UID，通过这个UID可以鉴别进程身份。同时Android系统对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略判断UID/PID是否满足访问权限。也就是说Binder机制对于通信双方的身份是内核进行校验支持的。例如Socket方式只需要指导地址就可以连接，他们的安全机制需要上层协议来假设</li><li><strong>从语言角度</strong>：Linux是基于C的，而Android是基于Java的，而Binder是符合面向对象思想的。它的实体位于一个进程中，而它的引用遍布与系统的各个进程之中，它是一个跨进程引用的对象，模糊了进程边界，淡化了进程通信的过程，整个系统仿佛运行于同一个面向对象的程序之中。</li><li><strong>从公司角度</strong>：Linux内核是开源的，GPL协议保护，受它保护的Linux Kernel是运行在内核控件，对于上层的任何类库、服务等只要进行系统调用，调用到底层Kernel，那么也必须遵循GPL协议。而对于Android来说，Google巧妙地将GPL协议控制在内核控件，将用户控件的协议采用Apache-2.0协议（允许基于Android的开发商不向社区反馈源码）。</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>刚才谈到Binder的时候提了一下效率的问题，那这里就不得不讲到反射了。</p><p>反射它允许一个类在运行过程中获得任意类的任意方法，这个是Java语言的一个很重要的特性。它方便了程序员的编写，但是降低了效率。</p><p>实际上，对于只要不是特别大的项目（非Android），反射对于效率的影响微乎其微，而与之对比的开发成本来说就更划算了。<br>但是，Android是一个用于手机的，它的硬件设施有限，我们必须要考虑到它的这个因素，用户体验是最重要的。以前看到过国外的一项统计。在一个APP中的Splash中使用了反射，结果运行时间增加了一秒，这个已经算是很严重的效率影响了。</p><p><strong>为什么反射影响效率呢</strong><br>这里就需要提到一个东西，JIT编译器。JIT编译器它可以把字节码文件转换为机器码，这个是可以直接让处理器使用的，经过它处理的字节码效率提升非常大，但是它有一个缺点，就是把字节码转换成机器码的过程很慢，有的时候甚至还超过了不转换的代码效率（转换之后存在一个复用的问题，对于转换了的机器码，使用的次数越多就越值的）。因此，在JVM虚拟机中，也就产生了一个机制，把常用的、使用频率高的字节码通过JIT编译器转换，而频率低的就不管它。而反射的话则是直接越过了JIT编译器，不管是常用的还是非常用的字节码一律没有经过JIT编译器的转化，所以效率就会低。<br>而在Android里面，5.0之前使用的是Davlik虚拟机，它就是上面的机制，而在Android5.0之后Google使用了一个全新的ART虚拟机全面代替Davlik虚拟机。<br>ART虚拟机会在程序安装时直接把所有的字节码全部转化为机器码，虽然这样会导致安装时间边长，但是程序运行的效率提升非常大。<br><strong>【疑问：那在Android5.0之后的系统上，反射会不会没影响了？由于现在做项目的时候更多考虑的是向下兼容，单独考虑5.0的情况还没有，等以后有需求或者是有机会的时候再深入了解一下，以后更新】</strong></p><h2 id="继续断点4"><a href="#继续断点4" class="headerlink" title="继续断点4"></a>继续断点4</h2><p>刚才总结了Android的消息处理机制和IPC通信，那么我们主线程的消息处理机制是什么时候开始的呢？因为我们知道在主线程中我们是不需要手动调用Looper.prepare()和Looper.loop()的。</p><p>Android的主线程就是ActivityThread，主线程的入口方法是main方法，在main方法中系统会通过Looper.prepareMainLooper()来创建主线程的Looper以及MessageQueue，并通过Looper.loop来开启消息循环，所以这一步实际上是系统已经为我们做了，我们就不再需要自己来做。<br>ActivityThread通过AppplicationThread和AMS进行进程件通信，AMS以进程间通信的方式完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向Handler发送消息，Handler收到消息后会将ApplicationThread中的逻辑切换到主线程中去执行，这个过程就是主线程的消息循环模型。</p><p>上面总结到了APP开始运行，依次调用onCreate/onStart/onResume等方法，那么在onCreate方法中我们经常使用的setContentView和findViewById做了什么事呢？</p><p>Activity界面显示<br>-<br>首先，就考虑到第一个问题，也就是setContentView这个东西做了什么事，这里就要对你当前继承的Activity分类了，如果是继承的Activity，那么setContentView源码是这样的：</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Set the activity content from a layout resource.  The resource will be</span><br><span class="line"> * inflated, adding all top-level views to the activity.</span><br><span class="line"> *</span><br><span class="line"> * @param layoutResID Resource ID to be inflated.</span><br><span class="line"> *</span><br><span class="line"> * @see <span class="function"><span class="keyword">#</span><span class="title">setContentView</span><span class="params">(<span class="variable">android</span>.<span class="variable">view</span>.<span class="variable">View</span>)</span></span></span><br><span class="line"> * @see <span class="function"><span class="keyword">#</span><span class="title">setContentView</span><span class="params">(<span class="variable">android</span>.<span class="variable">view</span>.<span class="variable">View</span>, <span class="variable">android</span>.<span class="variable">view</span>.<span class="variable">ViewGroup</span>.<span class="variable">LayoutParams</span>)</span></span></span><br><span class="line"> */</span><br><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Set the activity content to an explicit view.  This view is placed</span><br><span class="line"> * directly into the activity's view hierarchy.  It can itself be a complex</span><br><span class="line"> * view hierarchy.  When calling this method, the layout parameters of the</span><br><span class="line"> * specified view are ignored.  Both the width and the height of the view are</span><br><span class="line"> * set by default to &#123;@link ViewGroup.LayoutParams#MATCH_PARENT&#125;. To use</span><br><span class="line"> * your own layout parameters, invoke</span><br><span class="line"> * &#123;@link <span class="function"><span class="keyword">#</span><span class="title">setContentView</span><span class="params">(<span class="variable">android</span>.<span class="variable">view</span>.<span class="variable">View</span>, <span class="variable">android</span>.<span class="variable">view</span>.<span class="variable">ViewGroup</span>.<span class="variable">LayoutParams</span>)</span></span>&#125;</span><br><span class="line"> * instead.</span><br><span class="line"> *</span><br><span class="line"> * @param view The desired content to display.</span><br><span class="line"> *</span><br><span class="line"> * @see <span class="function"><span class="keyword">#</span><span class="title">setContentView</span><span class="params">(<span class="variable">int</span>)</span></span></span><br><span class="line"> * @see <span class="function"><span class="keyword">#</span><span class="title">setContentView</span><span class="params">(<span class="variable">android</span>.<span class="variable">view</span>.<span class="variable">View</span>, <span class="variable">android</span>.<span class="variable">view</span>.<span class="variable">ViewGroup</span>.<span class="variable">LayoutParams</span>)</span></span></span><br><span class="line"> */</span><br><span class="line">public void setContentView(View view) &#123;</span><br><span class="line">    getWindow().setContentView(view);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Set the activity content to an explicit view.  This view is placed</span><br><span class="line"> * directly into the activity's view hierarchy.  It can itself be a complex</span><br><span class="line"> * view hierarchy.</span><br><span class="line"> *</span><br><span class="line"> * @param view The desired content to display.</span><br><span class="line"> * @param params Layout parameters for the view.</span><br><span class="line"> *</span><br><span class="line"> * @see <span class="function"><span class="keyword">#</span><span class="title">setContentView</span><span class="params">(<span class="variable">android</span>.<span class="variable">view</span>.<span class="variable">View</span>)</span></span></span><br><span class="line"> * @see <span class="function"><span class="keyword">#</span><span class="title">setContentView</span><span class="params">(<span class="variable">int</span>)</span></span></span><br><span class="line"> */</span><br><span class="line">public void setContentView(View view, ViewGroup.LayoutParams params) &#123;</span><br><span class="line">    getWindow().setContentView(view, params);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面存在着3个重载函数，而不管你调用哪一个，最后都会调用到initWindowDecorActionBar()这个方法。<br>而对于新的一个AppcompatActivity，这个Activity里面包含了一些新特性，现在我做的项目里基本都是使用AppcompatActivity代替掉原来的Activity，当然也并不是一定的，还是要根据项目的实际情况来选择。<br>在AppcompatActivity中，setContentView是这样的：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line">   public void setContentView(<span class="variable">@LayoutRes</span> int layoutResID) &#123;</span><br><span class="line">       <span class="selector-tag">getDelegate</span>()<span class="selector-class">.setContentView</span>(layoutResID);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @<span class="selector-tag">Override</span></span><br><span class="line">   <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">setContentView</span>(View view) &#123;</span><br><span class="line">       <span class="selector-tag">getDelegate</span>()<span class="selector-class">.setContentView</span>(view);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @<span class="selector-tag">Override</span></span><br><span class="line">   <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">setContentView</span>(View view, ViewGroup.LayoutParams params) &#123;</span><br><span class="line">       <span class="selector-tag">getDelegate</span>()<span class="selector-class">.setContentView</span>(view, params);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>一样的3个重载函数，只是里面没有了上面的那个init方法，取而代之的是一个getDelegate().setContentView，这个delegate从字面上可以了解到它是一个委托的对象，源码是这样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> The &#123;<span class="doctag">@link</span> AppCompatDelegate&#125; being used by this Activity.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@NonNull</span></span><br><span class="line">   <span class="keyword">public</span> AppCompatDelegate getDelegate() &#123;</span><br><span class="line">       <span class="keyword">if</span> (mDelegate == <span class="literal">null</span>) &#123;</span><br><span class="line">           mDelegate = AppCompatDelegate.create(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> mDelegate;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>而在AppCompatDelegate.Create方法中，则会返回一个很有意思的东西：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a &#123;<span class="doctag">@link</span> android.support.v7.app.AppCompatDelegate&#125; to use with &#123;<span class="doctag">@code</span> activity&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callback An optional callback for AppCompat specific events</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function">AppCompatDelegate <span class="title">create</span><span class="params">(Activity activity, AppCompatCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> create(activity, activity.getWindow(), callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AppCompatDelegate create(Context context, Window window,</span><br><span class="line">            AppCompatCallback callback) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> sdk = Build.VERSION.SDK_INT;</span><br><span class="line">        <span class="keyword">if</span> (sdk &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AppCompatDelegateImplV23(context, window, callback);</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(sdk &gt;= <span class="number">14</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AppCompatDelegateImplV14(context, window, callback);</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(sdk &gt;= <span class="number">11</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AppCompatDelegateImplV11(context, window, callback);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AppCompatDelegateImplV7(context, window, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里会根据SDK的等级来返回不同的东西，这样的话就不深究了，底层的话我撇了一下，应该原理和Activity是一样的，可能存在一些区别。这里就用Activity来谈谈它的setContentView方法做了什么事。</p><p>在setContentView上面有段注释：</p><blockquote><p>Set the activity content from a layout resource. The resource will be inflated, adding all top-level views to the activity.</p></blockquote><p>这里就介绍了它的功能，它会按照一个布局资源去设置Activity的内容，而这个布局资源将会被引入然后添加所有顶级的Views到这个Activity当中。<br>这是个啥意思勒。<br>下面从网上扒了一张图：<br><img src="http://img.blog.csdn.net/20150604144532934" alt="dsa"><br>这里是整个Activity的层级，最外面一层是我们的Activity，它包含里面的所有东西。<br>再上一层是一个PhoneWindow，这个PhoneWindow是由Window类派生出来的，每一个PhoneWindow中都含有一个DecorView对象，Window是一个抽象类。<br>再上面一层就是一个DecorView，我理解这个DecorView就是一个ViewGroup，就是装View的。<br>而在DecoreView中，最上面的View就是我们的TitleActionBar，下面就是我们要设置的content。所以在上面的initWindowDecorActionBar就能猜到是什么意思了吧。</p><p>而在initWindowDecorActionBar方法中，有一段代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new ActionBar, locates the inflated ActionBarView,</span></span><br><span class="line"><span class="comment">    * initializes the ActionBar with the view, and sets mActionBar.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="built_in">void</span> initWindowDecorActionBar() &#123;</span><br><span class="line">       Window <span class="built_in">window</span> = getWindow();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Initializing the window decor can change window feature flags.</span></span><br><span class="line">       <span class="comment">// Make sure that we have the correct set before performing the test below.</span></span><br><span class="line">       <span class="built_in">window</span>.getDecorView();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (isChild() || !<span class="built_in">window</span>.hasFeature(Window.FEATURE_ACTION_BAR) || mActionBar != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mActionBar = <span class="keyword">new</span> WindowDecorActionBar(<span class="keyword">this</span>);</span><br><span class="line">       mActionBar.setDefaultDisplayHomeAsUpEnabled(mEnableDefaultActionBarUp);</span><br><span class="line"></span><br><span class="line">       mWindow.setDefaultIcon(mActivityInfo.getIconResource());</span><br><span class="line">       mWindow.setDefaultLogo(mActivityInfo.getLogoResource());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>注意上面的window.getDecoreView（）方法的注释，该方法会设置一些window的标志位，而当这个方法执行完之后，就再也不能更改了，这也就是为什么很多第三方SDK设置window的标志位时一定要求要在setContentView方法前调用。</p><h2 id="findViewById"><a href="#findViewById" class="headerlink" title="findViewById"></a>findViewById</h2><p>我们通过一个findViewById方法可以实现对象的绑定，那它底层究竟是怎么实现的呢？</p><p>findViewById根据继承的Activity类型的不同也存在着区别，老规矩，还是以Activity的来。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Finds a view that was identified by the id attribute from the XML that</span></span><br><span class="line"><span class="comment">     * was processed in &#123;@link #onCreate&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return The view if found or null otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">@Nullable</span></span><br><span class="line">    public View findViewById(<span class="variable">@IdRes</span> int id) &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">getWindow</span>()<span class="selector-class">.findViewById</span>(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从源码来看，findViewById也是经过了一层层的调用，它的功能如同它上面的注释一样，通过一个view的id属性查找view，这里也可以看到一个熟悉的getWindow方法，说明findViewById()实际上Activity把它也是交给了自己的window来做</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Finds a view that was identified by the id attribute from the XML that</span></span><br><span class="line"><span class="comment">    * was processed in &#123;@link android.app.Activity#onCreate&#125;.  This will</span></span><br><span class="line"><span class="comment">    * implicitly call &#123;@link #getDecorView&#125; for you, with all of the</span></span><br><span class="line"><span class="comment">    * associated side-effects.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @return The view if found or null otherwise.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="variable">@Nullable</span></span><br><span class="line">   public View findViewById(<span class="variable">@IdRes</span> int id) &#123;</span><br><span class="line">       <span class="selector-tag">return</span> <span class="selector-tag">getDecorView</span>()<span class="selector-class">.findViewById</span>(id);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>而在这里面，又调用了getDecorView的findViewById（）方法，这也相当于是一个层层传递的过程，因为DecorView我理解为就是一个ViewGroup，而当运行getDecorView().findViewById()方法时，就会运行View里面的findViewById方法。它会使用这个被给予的id匹配子View的Id，如果匹配，就返回这个View，完成View的绑定</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Look <span class="keyword">for</span> a child view <span class="keyword">with</span> <span class="keyword">the</span> <span class="keyword">given</span> <span class="built_in">id</span>.  If this view has <span class="keyword">the</span> <span class="keyword">given</span></span><br><span class="line">     * <span class="built_in">id</span>, <span class="literal">return</span> this view.</span><br><span class="line">     *</span><br><span class="line">     * @param <span class="built_in">id</span> The <span class="built_in">id</span> <span class="keyword">to</span> search <span class="keyword">for</span>.</span><br><span class="line">     * @<span class="literal">return</span> The view <span class="keyword">that</span> has <span class="keyword">the</span> <span class="keyword">given</span> <span class="built_in">id</span> <span class="keyword">in</span> <span class="keyword">the</span> hierarchy <span class="keyword">or</span> null</span><br><span class="line">     */</span><br><span class="line">    @Nullable</span><br><span class="line">    public final View findViewById(@IdRes int <span class="built_in">id</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">id</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">            return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">        return</span> findViewTraversal(<span class="built_in">id</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * &#123;@hide&#125;</span><br><span class="line">     * @param <span class="built_in">id</span> <span class="keyword">the</span> <span class="built_in">id</span> <span class="keyword">of</span> <span class="keyword">the</span> view <span class="keyword">to</span> be found</span><br><span class="line">     * @<span class="literal">return</span> <span class="keyword">the</span> view <span class="keyword">of</span> <span class="keyword">the</span> specified <span class="built_in">id</span>, null <span class="keyword">if</span> cannot be found</span><br><span class="line">     */</span><br><span class="line">    protected View findViewTraversal(@IdRes int <span class="built_in">id</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">id</span> == mID) &#123;</span><br><span class="line"><span class="built_in">            return</span> this;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">        return</span> null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后总结一下（Activity中），findViewById的过程是这样的：<br>Activity -&gt; Window -&gt; DecorView -&gt; View</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.zhihu.com/question/39440766#answer-31119460" target="_blank" rel="noopener">为什么Android要采用Binder作为IPC机制？</a></li><li><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287" target="_blank" rel="noopener">【凯子哥带你学Framework】Activity启动过程全解析</a></li><li><a href="http://gityuan.com/" target="_blank" rel="noopener">Gityuan</a></li><li>《Android开发艺术探索》</li><li>《Linux程序设计》</li><li>《Linux内核剖析》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载请注明出处&lt;br&gt;博客地址：imlzq.com&lt;br&gt;作者：李中权&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;好久没有写博客了，瞬间感觉好多学了的东西不进行一个自我的总结与消化总归变不成自己的。通过博客可能还可以找到一些当初在学习的时候没有想到的问题。想了半天，从大二上学期自学Android以来还没有对Android从启动到程序运行期间进行一个完整的归纳，刚好最近又学到了一些新东西，那就以这篇博客为媒介，总结一下从Android启动到程序运行期间发生的所有事吧。包括什么ClassLoader, JVM,IPC, 消息处理机制要是总结到了就顺带BB一下。但是这里就不包含很多细节了，比如为什么PMS内部为什么要这么构造，好处是什么，如果我来设计的话我会怎么设计啊这种暂时就不总结了，因为我觉得以我现在的水平还有学习精力来说把这些细节都一个个的弄清楚有点没抓住重点。现阶段还是先能够了解整个流程，有个大局观才是最重要的。至于以后如果有需要或者是有精力的时候再一个个的突破。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发现本文的错误或者遗漏后会立刻更改&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Rxjava原理探索：切换线程，变换</title>
    <link href="http://imlzq.com/2016/03/25/rxjava/"/>
    <id>http://imlzq.com/2016/03/25/rxjava/</id>
    <published>2016-03-25T08:11:30.000Z</published>
    <updated>2018-02-12T10:25:06.975Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的几篇博客中，我编写了一篇有关<a href="http://blog.csdn.net/jonstank2013/article/details/50366109" target="_blank" rel="noopener">Rxjava学习笔记</a>的，还有一个是<a href="http://blog.csdn.net/jonstank2013/article/details/50574871" target="_blank" rel="noopener">RxJava使用示例（一）： 实现Rxbus代替eventbus</a>（这篇博文其实还不算完善，因为没有对被观察者发出的时间进行一个筛选，一次发送所有订阅者都会收到，这样不太好，可以再新加一个筛选器，等以后有空或者是遇到的时候再来改一改，现在不急）。</p><p>之前在写那边Rxjava学习笔记的时候，就突出了一点是只涉及使用，不涉及原理，现在就对Rxjava的原理进行一个简单的探索。</p><a id="more"></a><p>#从整体来看</p><p>Rxjava属于一种扩展性的观察者模式，里面的四个基本概念是：Observable (可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。<br><img src="http://7xn2zf.com1.z0.glb.clouddn.com/rxjavarxjava_4_d.gif" alt=""><br>另外有一点是需要注意的，也是Rxjava很重要的一个特性，里面的onError方法，只要是发生错误的话就一定会被处理，所以可以将一些错误处理的代码直接写在onError中。</p><p>还有一点就是，Rxjava跟普通的观察者模式的区别在于如果observable没有任何Observer的话是不会发出任何事件的。</p><p>Observable负责在发生什么事件或者是订阅的对应条件产生时，就会发送事件去通知Observer，而具体的如何操作是有Observer接收到之后自己处理的，也就是说Observable只负责发，其余的处理由Observer自己来处理。</p><p>#变化的原理</p><p>在Rxjava中存在flatMap以及Map，他们可以将一些指定的要发送的对象类型转换为另一个需要的对象类型，而这一个在Rxjava中是如何实现的呢？下面是我自己的一些理解，可能会有错误或偏差，欢迎指点。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是摘自扔物线的精简后的lift代码</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; Observable&lt;R&gt; lift(Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator) &#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> <span class="type">OnSubscribe</span>&lt;R&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> void call(Subscriber subscriber) &#123;</span><br><span class="line">            Subscriber <span class="keyword">new</span><span class="type">Subscriber</span> = operator.call(subscriber);</span><br><span class="line">            <span class="keyword">new</span><span class="type">Subscriber</span>.onStart();</span><br><span class="line">            onSubscribe.call(<span class="keyword">new</span><span class="type">Subscriber</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中存在一个lift()方法，这个方法就是flatMap以及Map能够转换对象类型的关键。这里就只总结一下思路：<br>通过这个lift方法会创建一个新的observable，这个observable里面包含一个新的OnSubscribe，一个新的subscriber。</p><blockquote><p>当用户调用经过 lift() 后的 Observable 的 subscribe() 的时候，使用的是新的 Observable<br>于是它所触发的 onSubscribe.call(subscriber)，也是用的新 Observable 中的新<br>OnSubscribe。  而这个新 OnSubscribe 的 call() 方法中的 onSubscribe ，就是指的原始<br>Observable 中的原始 OnSubscribe ，在这个 call() 方法里，新 OnSubscribe 利用<br>operator.call(subscriber) 生成了一个新的 Subscriber（Operator 就是在这里，通过自己的<br>call() 方法将新 Subscriber 和原始 Subscriber 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新<br>Subscriber 向原始 Observable 进行订阅。</p></blockquote><p>也就是说，原始的onSubscribe方法会发送数据发送到这个新的Subscriber中，而在这个新的Subscriber中会对数据进行一个处理，处理完成之后再发送给目标订阅者，也就是最原始的observer。而至于为什么要先发送数据到一个新的subscriber中，上面也提到过了，observable只管发，数据的处理是在subscriber中处理，这样分工明确。而当新的这个观察者处理完数据之后，再转发给原始的观察者。</p><p>#线程切换</p><p>最开始我接触到Rxjava有三个原因：<br>第一个是代码的简洁度，链式。<br>第二个是响应式框架，观察者模式。<br>第三个就是它是一个异步的框架，线程切换功能极其强大，可任意指定观察者发生的线程以及被观察者的线程，随意调整极其强大（观察者发生的线程只能更改一次，被观察的可以随意切换）。</p><p>而之前也是一直都很好奇它的这个切换的流程是怎么样的，为什么只能观察者发生的线程只能更改一次而被观察的可以随意切换多次？</p><p>##切换的流程##<br>线程的切换其实也是使用了上面介绍到的lift方法，被观察者切换线程使用observeOn()，观察者切换线程使用subscriberOn(),可切换为多种线程，例如主线程，IO线程，新线程等等，具体的可以查看我的第一篇Rxjava博文，<a href="http://blog.csdn.net/jonstank2013/article/details/50366109" target="_blank" rel="noopener">Rxjava学习笔记</a>。</p><p><strong>observeOn()</strong><br><img src="http://7xn2zf.com1.z0.glb.clouddn.com/rxjavarxjava_11.png" alt=""><br>在lift方法后，会创建一个新onSubscribe和一个新的subscriber。新的onSubscribe会通知原始的onSubscribe，原始的在收到通知后就会把信息发送到新的subscriber中，而这个时候如果设置了切换线程的话就会发生切换线程的操作</p><p><strong>subscribeOn()</strong><br><img src="http://7xn2zf.com1.z0.glb.clouddn.com/rxjavarxjava_10.png" alt="subscribeOn() 原理图"></p><p>而subscribeOn()方法就不同了，它切换线程的位置是在新onSubscribe通知原始onSubscribe之前，这也就导致了如果设置了多个切换线程操作始终只有有第一个subscribeOn()方法切换成功，因为它切换线程是在整个的流程发生之前，而当第二个subscribeOn()方法调用时它已经是处于整个流程之中了，因此就无法设置多个。而observeOn()则不同，它的线程切换是发生在流程之中的，所以多个切换是被允许的。</p><p>##疑问##<br>总结到了这里，我产生了一个疑问，subscribeOn切换观察者的线程为什么要设置在整个流程之前而为什么observeOn方法会设置到整个流程之间？这个应该是创造者指定的一个规则吧，但是我很好奇为什么要这样设置。</p><p>————————————————— 更新<br>通过在stackOverFlow以及知乎上提问获得了想要的答案：</p><blockquote><p>我的理解是subscribeOn是影响生产者（Observable）生产数据的线程的，通常我们只需要指定生产者在某一个特定的线程生产数据就可以满足我们的需求，至少我还没遇到过需要在生产数据的过程中去切换生产者所在的线程的情况。绝大多数我们需要变化线程的场景都是在数据生产之后，Rx里面就使用observeOn来指定各种operator和subcriber的线程，因为这些本质上都是数据的消费者。消费者可以任意切换自己接受处理数据的线程，足以满足我们的需求。<br>作者：hi大头鬼hi</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的几篇博客中，我编写了一篇有关&lt;a href=&quot;http://blog.csdn.net/jonstank2013/article/details/50366109&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Rxjava学习笔记&lt;/a&gt;的，还有一个是&lt;a href=&quot;http://blog.csdn.net/jonstank2013/article/details/50574871&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RxJava使用示例（一）： 实现Rxbus代替eventbus&lt;/a&gt;（这篇博文其实还不算完善，因为没有对被观察者发出的时间进行一个筛选，一次发送所有订阅者都会收到，这样不太好，可以再新加一个筛选器，等以后有空或者是遇到的时候再来改一改，现在不急）。&lt;/p&gt;
&lt;p&gt;之前在写那边Rxjava学习笔记的时候，就突出了一点是只涉及使用，不涉及原理，现在就对Rxjava的原理进行一个简单的探索。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
      <category term="Rxjava" scheme="http://imlzq.com/tags/Rxjava/"/>
    
  </entry>
  
  <entry>
    <title>Android推送（长连接）探索</title>
    <link href="http://imlzq.com/2016/03/23/Android%E6%8E%A8%E9%80%81%EF%BC%88%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%89%E6%8E%A2%E7%B4%A2/"/>
    <id>http://imlzq.com/2016/03/23/Android推送（长连接）探索/</id>
    <published>2016-03-23T05:01:12.000Z</published>
    <updated>2018-02-12T03:55:54.853Z</updated>
    
    <content type="html"><![CDATA[<p>android推送的方式存在几种，包括轮询，长连接等方式，由于其他的方式用户体验并不是特别好（耗电或者是消耗资源），所以现在大部分的推送都使用的是socket长连接的方式。</p><a id="more"></a><p>#集成Android的推送服务</p><p>现在的第三方可推送的平台特别多，以前用过的就是极光推送，友盟的，好像mob也有一个，具体的集成方法这里就不介绍了，需要的话请自行到对应官网去查看对应API。当然如果项目有需要的话，也完全可以自己实现推送服务，这个时候就要注意处理心跳包了（具体的请见下文）。这篇文章主要探索Android推送底层的一些处理及细节。</p><p>#长连接</p><p>##运作方式##<br>客户端在与服务器建立了TCP连接之后，客户端定时向服务器发送心跳包确认，有消息的时候，服务器直接通过这个已经建立好的TCP连接通知客户端。<br>而正所谓长连接，就是大家建立连接之后不主动断开，双方互相发送数据，发完了也不主动断开连接，之后有需要发送的数据就继续通过这个连接发送。</p><p>##TCP的三次握手##<br>既然总结到了TCP,就顺带总结一下TCP的三次握手和四次挥手吧。</p><p><img src="http://hi.csdn.net/attachment/201108/7/0_1312718352k8l6.gif" alt=""></p><p>这是TCP的三次握手，也就是通过这三次握手，让客户端与服务器建立一个连接，该连接理论上是永远不会断的，但其底层存在一个保活协议（默认为2小时），如果到了指定的时间检测到客户端死了，服务器就会关闭掉与该客户端的连接。也由于保活协议默认的时间太长（2个小时），也就诞生出了心跳包的概念，用于定时检测客户端是否还是活着的，如果死了就立刻关闭掉当前客户端的连接，节省服务器的带宽资源。</p><p>首先，客户端会发送一个包给服务器，服务器接收到了之后就会把当前服务器的一个状态码+1（用于区分，之后会讲到），之后服务器发送SYN包给客户端，此时服务器的状态改变，准备建立连接。客户端接收到服务器发过来的SYN包时，向服务器发送一个确认包，表明我知道了，当服务器接受到这个包的时候，就会检测当前的状态码（第一次+1的那个状态码）是否对应，因为有可能在第一次握手的时候存在一个超时的情况，客户端的包迟迟没有发到服务器（例如网络阻塞），而之前没有发到服务器的包却有可能在本次操作的时候发到了，所以就需要检测状态码是否对应，用于区分发过来的包到底是不是客户端第二次发来的包。最后就进入到连接建立的状态。</p><p>TCP的四次挥手<br>-<br>四次挥手是用于客户端与服务器断开连接的</p><p><img src="http://hi.csdn.net/attachment/201108/7/0_1312718564tZXD.gif" alt=""></p><p>1、客户端的应用简称先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接，客户端把连接释放报文段首部的种植控制为置为1，然后进入到终止等待1状态，等待服务器的确认<br>2、服务器收到连接释放报文段后即发出确认，之后进入到关闭等待状态。而TCP服务器进程这个时候就会通知高层的应用进程，从而让客户端到服务器这个方向的连接被释放掉，这个时候的TCP连接处于一个半关闭状态（即客户端没有数据要发送了，但是服务器如果要发送数据，客户端仍然要接受，也就是服务器到客户端的连接未关闭），客户端在收到来自服务器的确认之后，就进入终止等待2状态，等待服务器发出的连接释放报文段。<br>3、如果服务器已经没有了要向客户端发送的数据，其应用进程就会通知TCP释放连接，之后服务器进入最后确认状态，等待客户端的确认<br>4、客户端在收到服务器的连接释放报文段后，就必须对此发出确认，之后进入到时间等待状态，此时的TCP连接仍然没有被释放掉，必须要经过时间等待计时器设置的时间2MSL后，客户端才进入到关闭状态。MSL被称为最长报文段寿命，可根据工程的实际情况来进行设定（RFC建议设置为2分钟但对于现在的网络来说可能过长），而经过了2MSL（以4分钟为例）之后，就进入到了关闭状态，才能开始建立下一个新的连接。</p><p>之所以要经过2MSL的时间才能关闭是因为以下两个原因：</p><ul><li>可以保证客户端发送的最后一个报文段能够到达服务器，最后的这个报文段有可能丢失，因此服务器在没收到的情况下会超时重传一次第三步的报文，而客户端就又会收到这个报文段，之后再重传，同时重新等待2MSL</li><li>用于防止上一个失效的链接请求报文段出现在本连接中。客户端在发送完最后一个报文段后，经过时间2MSL，就可以让本连接持续的时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的连接不会出现这种旧的连接请求报文段。</li></ul><p>连接中断的情况<br>-<br>由于现在我们使用的是手机，因此我们的网络状态在很多时候都不是稳定的，就很有可能会导致连接被切断（切断后就需要再次建立连接），比如说NAT设备超时（路由器就是一个NAT设备），网络状态切换，DHCP的租期等等。</p><p>心跳包<br>-<br>这里推荐一篇文章，<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207243549&amp;idx=1&amp;sn=4ebe4beb8123f1b5ab58810ac8bc5994&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">Android微信智能心跳方案</a></p><p>心跳包，顾名思义，就是用于判断当前的客户端是否还有心跳（也就是是否还活着），如果没有心跳了，服务器就会关闭掉这个连接，用于节省带宽。</p><p>在一个正常的情况下，服务器会面对很多个连接。而一旦这个连接建立之后，是不会主动断开的，就会一直占据到服务器的资源，而很有可能过了一段时间之后有的连接就已经失效了，就可以释放掉该连接，而之后如果客户端需要再连接的时候重新建立连接就好了。</p><p>而这里有个点是很重要的，如果客户端心跳间隔是固定的，那么服务器就会在连接闲置超过这个时间还没收到心跳时，可以认为对方掉线，关闭连接。如果客户端心跳会动态改变，例如在微信的心跳方案中的话，就应该在服务器设置一个最大值，超过最大值如果还没收到就认为对方掉线。</p><p>同时服务器通过TCP连接主动给客户端发消息出现写超时的时候，也可以直接认为对方掉线了。</p><p>而之所以在这一小段中提到<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207243549&amp;idx=1&amp;sn=4ebe4beb8123f1b5ab58810ac8bc5994&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">Android微信智能心跳方案</a>，是因为对于整个心跳包来说，理论是比较简单的，而重要的是这个心跳时间间隔的设定。<br>发送心跳包势必要先唤醒设备, 然后才能发送, 如果唤醒设备过于频繁, 或者直接导致设备无法休眠, 会大量消耗电量, 而且移动网络下进行网络通信, 比在wifi下耗电得多. 所以这个心跳包的时间间隔应该尽量的长, 最理想的情况就是根本没有NAT超时, 这也就是网上常说的长连接, 慢心跳.</p><p>而超时的这个情况肯定是不能避免的了，这个时候就可以参看一下上面的那篇心跳方案，它是关于如何让心跳间隔逼近NAT超时的间隔，同时自动适应NAT超时间隔的变化。</p><p>设备休眠<br>-</p><blockquote><p>首先Android手机有两个处理器，一个叫Application Processor（AP），一个叫Baseband Processor（BP）。AP是ARM架构的处理器，用于运行Linux+Android系统；BP用于运行实时操作系统（RTOS），通讯协议栈运行于BP的RTOS之上。非通话时间，BP的能耗基本上在5mA左右，而AP只要处于非休眠状态，能耗至少在50mA以上，执行图形运算时会更高。另外LCD工作时功耗在100mA左右，WIFI也在100mA左右。一般手机待机时，AP、LCD、WIFI均进入休眠状态，这时Android中应用程序的代码也会停止执行。</p><p>Android为了确保应用程序中关键代码的正确执行，提供了Wake Lock的API，使得应用程序有权限通过代码阻止AP进入休眠状态。但如果不领会Android设计者的意图而滥用Wake Lock API，为了自身程序在后台的正常工作而长时间阻止AP进入休眠状态，就会成为待机电池杀手。比如前段时间的某应用，比如现在仍然干着这事的某应用。</p><p>网上有说使用AlarmManager，因为AlarmManager 是Android 系统封装的用于管理 RTC 的模块，RTC (Real Time Clock) 是一个独立的硬件时钟，可以在 CPU 休眠时正常运行，在预设的时间到达时，通过中断唤醒 CPU。</p></blockquote><p>尤其需要注意的一点就是：如果不进行特别的设置，Android会在一定时间后屏幕变暗，在屏幕变暗后约几分钟，CPU也会休眠，大多数的程序都会停止运行，从而节省电量。而CPU休眠的话就存在一个很严重的问题了，很有可能你设置的一些程序会由于CPU休眠而无法执行，例如Timer和TimerTask，这个时候就可以使用系统的AlarmService来执行轮询。因为虽然系统让机器休眠，节省电量，但并不是完全的关机，系统有一部分优先级很高的程序还是在执行的，比如闹钟，利用AlarmService可以定时启动自己的程序，让cpu启动,执行完毕再休眠。</p><p>而对于Socket来说，同样也存在一个很严重的问题，当屏幕关了几分钟之后连接会被断开，但实际上网络又是连通的，这是因为CPU休眠了，此时就可以设置一个PARTIAL_WAKE_LOCK来保持CPU不休眠。（这是从网上找的一种解决方案，可能会有更优）</p><p>最后再补充一句，小米的MIUI系统对于原生的系统改动太大，很多地方可能需要根据该系统的情况来设定指定的方案，说多了都是泪~</p><p>参考<br>-<br><a href="http://www.cnblogs.com/kobe8/p/3819305.html" target="_blank" rel="noopener">android设备休眠</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207243549&amp;idx=1&amp;sn=4ebe4beb8123f1b5ab58810ac8bc5994&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">Android微信智能心跳方案</a><br><a href="http://www.jianshu.com/p/584707554ed7" target="_blank" rel="noopener">Android推送技术研究</a><br><a href="http://www.cnblogs.com/hanyonglu/archive/2012/03/04/2378971.html" target="_blank" rel="noopener">Android实现推送方式解决方案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;android推送的方式存在几种，包括轮询，长连接等方式，由于其他的方式用户体验并不是特别好（耗电或者是消耗资源），所以现在大部分的推送都使用的是socket长连接的方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>JVM原理及底层探索</title>
    <link href="http://imlzq.com/2016/03/18/JVM%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2/"/>
    <id>http://imlzq.com/2016/03/18/JVM原理及底层探索/</id>
    <published>2016-03-18T06:05:09.000Z</published>
    <updated>2018-02-12T03:57:07.031Z</updated>
    
    <content type="html"><![CDATA[<p>JVM是Java程序运行的环境，但是他同时也是一个操作系统的一个应用程序的一个进程，因此JVM也有他自己的运行生命周期，也有自己的代码和数据空间。</p><a id="more"></a><p>##JDK</p><p>JDK在Java的整个体系中充当一个生产加工中心，产生所有的数据输出，是所有指令和战略的执行中心。本身还提供了Java的完整方案，可以开发目前Java能支持的所有应用和系统程序。而之所以现在还会分j2me，j2ee这些类，是把他们用来简化各自领域内的开发和构建过程。JDK除了JVM之外，还有一些核心的API，用户工具，技术等等。</p><p>而JVM在JDK中就处于最底层的位置，负责操作系统的交互，用来屏蔽操作系统环境，提供一个完整的Java运行环境，也就是一个虚拟计算机。</p><p>##GC（垃圾回收）</p><p>Java堆的描述如下：<br><img src="http://hi.csdn.net/attachment/201201/6/0_1325814932X3Ts.gif" alt="这里写图片描述"><br>内存由Perm和Heap组成。<br>JVM内存模型中分两大块，其实在垃圾回收的算法中，有一个方法就是分代垃圾回收（这个在下面的时候我会归纳一下）。而JVM这里也就是一个分代的原理。一块是新生代，一块是老一代。在老一代里面，存放的东西都是应用程序生命周期较长的内存对象（老一代嘛），而新生代里面存放东西的生命周期就要短一些了（因此在垃圾回收算法中可以根据不同代的特点来指定不同的回收方案）。</p><p>在新生代中，有一个叫Eden（圣经中伊甸园的意思，这样看名字就可以猜出它大概的意思及作用了吧）的空间来存放新生的对象，还有两个Survivor Spaces它们是用来存放每次垃圾回收后存活下来的对象。</p><p>还有个Permanent Generation Space, 是指内存的永久保存区域，而一般出现OOM的时候，就是内存溢出了。而为什么会溢出呢？是因为Class在被Load的时候被放入该区域，它和存放Instance的Heap区域不同,GC不会在主程序运行期对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。<br>它其实就是一个方法区，里面主要存放了两种信息。</p><blockquote><p>1.Class的节本信息<br>Package Name<br>Super class package name<br>Class or interface<br>Type modifiers<br>Super inferface package name<br>2.其它信息<br>The constant pool for the type<br>Field information<br>Method information<br>All class (static) variables declared<br>in the type, except constants<br>A reference to class ClassLoader<br>A reference to class Class</p></blockquote><p><strong>常见的溢出</strong></p><pre><code>1. OLD段溢出  这种内存溢出是最常见的情况之一，产生的原因可能是：    1) 设置的内存参数过小(ms/mx, NewSize/MaxNewSize)    2) 程序问题    单个程序持续进行消耗内存的处理，如循环几千次的字符串处理，对字符串处理应建议使用StringBuffer。此时不会报内存溢出错，却会使系统持续垃圾收集，无法处理其它请求，单个程序所申请内存过大，有的程序会申请几十乃至几百兆内存，此时JVM也会因无法申请到资源而出现内存溢出。    当Java对象使用完毕后，其所引用的对象却没有销毁，使得JVM认为他还是活跃的对象而不进行回收，这样累计占用了大量内存而无法释放。2. Perm段溢出  通常由于Perm段装载了大量的类而导致溢出，目前的解决办法：就是增加它的空间。3. C Heap溢出   系统对C Heap没有限制，故C Heap发生问题时，Java进程所占内存会持续增长，直到占用所有可用系统内存4. 其他：  JVM有2个GC线程。第一个线程负责回收Heap的NEW区。第二个线程在Heap不足时，遍历Heap，将NEW区升级为Older区。Older区的大小等于-Xmx减去-Xmn，不能将-Xms的值设的过大，因为第二个线程被迫运行会降低JVM的性能。</code></pre><p>为什么一些程序频繁发生GC？有如下原因：</p><ol><li>程序内调用了System.gc()或Runtime.gc()。</li><li>一些中间件软件调用自己的GC方法，此时需要设置参数禁止这些GC。</li><li>Java的Heap太小，一般默认的Heap值都很小。</li><li>频繁实例化对象，Release对象。此时尽量保存并重用对象，例如使用StringBuffer和String。</li></ol><p>如果每次GC后，Heap的剩余空间会是总空间的50%，这表示你的Heap处于健康状态。许多Server端的Java程序每次GC后最好能有65%的剩余空间。</p><p>注意：</p><ol><li>增加Heap的大小虽然会降低GC的频率，但也增加了每次GC的时间。并且GC运行时，所有的用户线程将暂停，也就是GC期间，Java应用程序不做任何工作。</li><li>Heap大小并不决定进程的内存使用量。进程的内存使用量要大于-Xmx定义的值，因为Java为其他任务分配内存，例如每个线程的Stack等。</li><li>每个线程都有他自己的Stack,Stack的大小限制着线程的数量。如果Stack过大就好导致内存溢漏</li><li>硬件环境也影响GC的效率，例如机器的种类，内存，swap空间，和CPU的数量。如果你的程序需要频繁创建很多transient对象，会导致JVM频繁GC。这种情况你可以增加机器的内存，来减少Swap空间的使用</li></ol><p>垃圾回收<br>-<br>在新生代块中，垃圾回收一般用Copying的算法，速度快。每次GC的时候，存活下来的对象首先由Eden拷贝到某个Survivor Space, 当Survivor Space空间满了后, 剩下的live对象就被直接拷贝到老一代中。因此，每次GC后，Eden内存块会被清空。在老一代中，垃圾回收一般用mark-compact（标记-整理）算法，它的内存占用少，速度慢。<br>垃圾回收分多级，0级为全部(Full)的垃圾回收，会回收OLD段中的垃圾；1级或以上为部分垃圾回收，只会回收NEW中的垃圾，内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。</p><p>##什么情况下触发垃圾回收##<br>   由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC 和 Full GC<br>   Scavenge GC<br>    一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到老一代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden区能尽快空闲出来。<br>    Full GC<br>    对整个堆进行整理，包括年轻代，老一代和持久代。Full GC 因为需要对整个堆进行回收，所以比 Scavenge GC 要慢，因此应该尽可能减少 Full GC 的次数。在对JVM调优的过程中，很大一部分工作就是对于 Full GC 的调节。</p><p>   有如下原因可能导致Full GC:<br>    . 老一代被写满<br>    . 持久代被写满<br>    . System.gc()被显式调用<br>    . 上一次GC之后Heap的各域分配策略动态变化</p><p>##JVM如何判断一个对象为垃圾##<br>这个时候就要考虑JVM什么时候才把一个对象当成垃圾了，常用的有以下几种方法：</p><p><strong>引用计数器算法</strong></p><p>定义： 引用计数器算法是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，计数器-1，当计数器为0的时候，JVM就认为对象不再被使用，是“垃圾”了。</p><p>优缺点：引用计数器实现简单，效率高；但是不能解决循环引用问问题（A对象引用B对象，B对象又引用A对象，但是A,B对象已不被任何其他对象引用），同时每次计数器的增加和减少都带来了很多额外的开销，所以在JDK1.1之后，这个算法已经不再使用了。</p><p><strong>根搜索方法</strong><br>根搜索方法是通过一些“GC Roots”对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链（Reference Chain），当一个对象没有被GC Roots的引用链连接的时候，说明这个对象是不可用的。</p><p>GC Roots对象包括：</p><p>a) 虚拟机栈（栈帧中的本地变量表）中的引用的对象。<br>b) 方法区域中的类静态属性引用的对象。<br>c) 方法区域中常量引用的对象。<br>d) 本地方法栈中JNI（Native方法）的引用的对象。</p><p>##垃圾回收算法##</p><p><strong>一、按回收策略来分可分为三种</strong></p><p><strong>标记-清除法（Mark-Sweep）</strong><br>标记清除法分为两个阶段，一个是标记，另一个是清除。<br>在标记阶段，确定所有要回收的对象，并作标记<br>在清除阶段，将所有标记了的对象清除。它的操作是紧跟标记阶段的</p><p>缺点：<br>标记和清除阶段的效率不高，而且清除后回产生大量的不连续空间，这样当程序需要分配大内存对象时，可能无法找到足够的连续空间。</p><p><strong>复制算法（Coping）</strong><br>复制算法是把内存分为大小相等的两块，每次使用其中的一块，当垃圾回收的时候，把存货的对象复制到另一块上，然后把这段内存清除掉。</p><p>复制算法实现简单，运行效率高，但是由于每次只能使用其中的一半，造成内存的利用率不高。现在的JVM用复制方法收集新生代，由于新生代中大部分对象（98%）都是朝生夕死的，所以两块内存的比例不是1:1(大概是8:1)。复制算法完成后会形成连续的空间。</p><p><strong>标记整理算法（Mark-Compact）</strong><br>标记-整理算法和标记-清除算法一样，但是标记-整理算法是把存活的对象直接向内存的一端移动，然后把超过边界的内存直接清除。</p><p>标记整理算法提高了内存的利用率，适用于收集存货时间较长的老一代。这种算法完成之后也会是连续的内存空间</p><p><strong>二、按分区对待的方式来分可分为两种</strong></p><p><strong>分代收集</strong><br>这个就是根据对象的存活时间，分为老一代（存活时间上）和新一代（存活时间短），然后根据不同的年代来采用不同的算法。老一代采用标记整理算法，新一代采用复制算法。<br>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。<br>但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p><strong>增量收集</strong><br>它又被称为实时垃圾回收算法。即：在应用进行的同时进行垃圾回收。</p><p><strong>三、按系统线程可分为三种</strong></p><p><strong>串行收集</strong><br>串行收集使用单线程处理所有垃圾回收工作，因为无需多线程交互，实现容易，而且效率比较高。但是，其局限性也比较明显，即无法使用多处理器的优势，所以此收集适合单处理器机器。当然，此收集器也可以用在小数据量（100M左右）情况下的多处理器机器上。</p><p><strong>并行收集</strong><br>并行收集使用多线程处理垃圾回收工作，因而速度快，效率高。而且理论上CPU数目越多，越能体现出并行收集器的优势。（串型收集的并发版本，需要暂停jvm） 并行paralise指的是多个任务在多个cpu中一起并行执行，最后将结果合并。效率是N倍。</p><p><strong>并发收集</strong><br>相对于串行收集和并行收集而言，前面两个在进行垃圾回收工作时，需要暂停整个运行环境，而只有垃圾回收程序在运行，因此，系统在垃圾回收时会有明显的暂停，而且暂停时间会因为堆越大而越长。（和并行收集不同，并发只有在开头和结尾会暂停jvm）并发concurrent指的是多个任务在一个cpu伪同步执行，但其实是串行调度的，效率并非直接是N倍。</p><p>四种GC<br>-<br>第一种为单线程GC,也是默认的GC，适用于单CPU的机器<br>第二种为多线程GC，适用于多CPU，使用大量线程的程序。这跟第一种是类似的，这种GC在回收NEW区时是多线程的，但是在回收OLD区是跟第一种一样的，仍然采用单线程。<br>第三种为Concurrent Low Pause GC，类似于第一种，适用于多CPU，并要求缩短因GC造成程序停滞的时间。这种GC可以在Old区的回收同时，运行应用程序<br>第四种第四种为Incremental Low Pause GC，适用于要求缩短因GC造成程序停滞的时间。这种GC可以在Young区回收的同时，回收一部分Old区对象。</p><p>##JVM操作cpu与内存交互的工作原理##</p><p>在C/C++中，它们的工作原理是<br>先将语句转化为汇编，<br>再把汇编转换为二进制数据传给CPU，<br>cpu通过控制总线来控制cpu的地址总线寻找内存地址,数据总线传送数据到内存单元中。获得数据实现与内存的交互。</p><p>而在Java这一块来说的话，编译成.class文件（它是一个字节码文件）之后，这个时候cpu就相当于可以和他进行交互了，而jvm就负责在中间这一块去识别它。如果照上面的C/C++的逻辑来说，.class可以理解为cpu可以理解的语言了（JVM负责翻译）。</p><p>-—————————————————–<br>现在发现了几个很好的资源，记录一下，以后看看，传送门：<a href="http://bbs.csdn.net/topics/390251794" target="_blank" rel="noopener">http://bbs.csdn.net/topics/390251794</a></p><p>这个是介绍了happen-before以及其他重要内容的资源：<a href="http://ifeve.com/java-concurrent-hashmap-1/" target="_blank" rel="noopener">http://ifeve.com/java-concurrent-hashmap-1/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JVM是Java程序运行的环境，但是他同时也是一个操作系统的一个应用程序的一个进程，因此JVM也有他自己的运行生命周期，也有自己的代码和数据空间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://imlzq.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式_状态模式</title>
    <link href="http://imlzq.com/2016/03/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://imlzq.com/2016/03/16/设计模式_状态模式/</id>
    <published>2016-03-16T06:36:09.000Z</published>
    <updated>2018-02-12T03:50:40.095Z</updated>
    
    <content type="html"><![CDATA[<p>状态模式中的行为是由状态来决定的，不同的状态下有不同的行为。状态模式把对象的行为包装在不同的状态对象里，每一个状态对象都有一个共同的抽象状态基类。意图是让一个对象在其内部状态改变的时候，行为也随之改变。</p><a id="more"></a><p>##使用场景</p><pre><code>1. 一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为2. 代码中包含大量与对象状态有关的条件语句，例如if-else, switch-case且这些分支依赖于该对象的状态</code></pre><p>状态模式将每一个条件分支放入一个独立的类中，这使得你可以根据对象自身的情况将对象的状态作为一个对象，通过多态来去除过多的if-else</p><p>实现<br>-<br>下面代码主要是实现一个简单的例子，根据人不同的状态（坐着或躺着）来进行不同的动作，其实也就是一个简单的多态实现。<br>创建接口<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">HumanState</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人坐着时吃饭</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人躺着时睡觉</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现坐着时的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HumanSit</span> <span class="keyword">implements</span> <span class="title">HumanState</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"开始吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 不做任何操作或者是提示用户当前状态不符</span></span><br><span class="line">System.out.println(<span class="string">"我在吃饭，不能睡觉"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现躺着时的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HumanLie</span> <span class="keyword">implements</span> <span class="title">HumanState</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 不做任何操作或者提示用户状态不符</span></span><br><span class="line">System.out.println(<span class="string">"我在睡觉，不能吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"开始睡觉"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建改变状态接口<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>HumanStateControl &#123;</span><br><span class="line">public void changeIntoSit();</span><br><span class="line">public void changeIntoLie();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建控制人物行为的类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HumanControl</span> <span class="keyword">implements</span> <span class="title">HumanStateControl</span></span>&#123;</span><br><span class="line"><span class="comment">// 人默认是坐着的</span></span><br><span class="line">HumanState humanState = <span class="keyword">new</span> HumanSit();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHumanState</span><span class="params">(HumanState humanState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.humanState = humanState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeIntoSit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">setHumanState(<span class="keyword">new</span> HumanSit());</span><br><span class="line">System.out.println(<span class="string">"坐起来啦"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeIntoLie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">setHumanState(<span class="keyword">new</span> HumanLie());</span><br><span class="line">System.out.println(<span class="string">"躺下啦"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">humanState.eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">humanState.sleep();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TestModule</span> &#123;</span></span><br><span class="line"></span><br><span class="line">public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line"><span class="type">HumanControl</span> humanControl = <span class="function"><span class="keyword">new</span> <span class="title">HumanControl</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">humanControl</span>.<span class="title">changeIntoSit</span>();</span></span><br><span class="line"><span class="function"><span class="title">humanControl</span>.<span class="title">eat</span>();</span></span><br><span class="line"><span class="function"><span class="title">humanControl</span>.<span class="title">sleep</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">humanControl</span>.<span class="title">changeIntoLie</span>();</span></span><br><span class="line"><span class="function"><span class="title">humanControl</span>.<span class="title">eat</span>();</span></span><br><span class="line"><span class="function"><span class="title">humanControl</span>.<span class="title">sleep</span>();</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>由于结果是很显而易见的，这里就不贴出来了。<br>而从上面的流程来看，对于一个小的项目来说，这样的操作确实很繁琐，因为要编写很多的接口以及相关的controller类，但是对于一个中型或者是大型的需要考虑维护性和拓展性的项目来说，这种方式在编写的时候就简洁多了。如果不使用状态模式，那么我们在TestModule的Main方法中就必须要添加一大堆的if-else条件判断，少量的还好，但是如果一旦判断过多，以后维护和拓展时是要死人的。</p><p>实用场景<br>-<br>Android中一个很典型的使用了状态模式的地方就是Wifi管理。具体的可以看一下它的源码，内容有点多，就不赘述了，这里只是简单分析一下大概：<br>在wifi管理的状态中，状态存在一个层级关系，树型的，当前状态只能转换上一个状态或者是下一个状态，不能够跨越转换，这里面存在一个状态转换规则。从这里面我们也可以学习到，以后自己编的时候也可以注意一下状态的转换关系，根据项目的需要判断是否可以跨越式转换，如果不可以的话，就一定要制定好相应的状态转换规则。</p><p>##总结</p><p>状态模式其实还是挺常用的，根据用户的状态去产生不同的用户行为，代码可维护性和可拓展性都大大的提升，也避免的代码的膨胀（if-else等）。<br>缺点也倒是听明显的，对于一些小的项目来说，用处不是特别大，因为状态模式肯定会增加系统类和对象的个数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;状态模式中的行为是由状态来决定的，不同的状态下有不同的行为。状态模式把对象的行为包装在不同的状态对象里，每一个状态对象都有一个共同的抽象状态基类。意图是让一个对象在其内部状态改变的时候，行为也随之改变。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://imlzq.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式_原型模式</title>
    <link href="http://imlzq.com/2016/03/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://imlzq.com/2016/03/16/设计模式_原型模式/</id>
    <published>2016-03-16T05:46:07.000Z</published>
    <updated>2018-02-12T03:50:44.900Z</updated>
    
    <content type="html"><![CDATA[<p>原型模式： Prototype Module</p><p>顾名思义，这个模式有一个样板实例，用户从这个样板对象中复制出一个内部属性一致的对象，这个过程也就是我们俗称的克隆。被复制的实例就被成为“原型”。</p><a id="more"></a><p>#定义</p><p>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象</p><p>##使用场景</p><pre><code>1. 类初始化需要消耗非常多的资源，包括数据，硬件资源，通过原型拷贝可以避免这些消耗2. 通过new产生一个对象需要非常繁琐的数据准备或访问权限3. 一个对象需要提供给其他对象访问，并且每个调用者可能都需要修改其值时，可以通过保护性原型拷贝拷贝多个对象供调用者使用。</code></pre><p><strong>注意</strong><br>通过实现Cloneable接口的原型模式在调用clone函数构造实例时并不一定比通过new操作速度快，只有当通过new构造对象较为耗时或者是成本较高时，通过clone方法才能获得效率上的提升。</p><p>当然，原型模式除了实现Cloneable接口来实现，同样也存在这其他的实现方式.</p><p>#实现</p><p>##方法一: 实现Cloneable接口##</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.awt.List;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WordDocument</span> <span class="title">implements</span> <span class="title">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String mText;</span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;String&gt; mImages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WordDocument</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"执行构造函数"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">getImages</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> mImages;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addImages</span>(<span class="params">String img</span>)</span>&#123;</span><br><span class="line">mImages.<span class="keyword">add</span>(img);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getText</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mText;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span>(<span class="params">String mText</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mText = mText;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDocument</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"-------------文本内容----------"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"Text : "</span> + mText);</span><br><span class="line"><span class="keyword">for</span> (String <span class="keyword">string</span> : mImages) &#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"image name : "</span> + <span class="keyword">string</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"-------------内容结束----------"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">protected</span> WordDocument <span class="title">clone</span>(<span class="params"></span>) throws CloneNotSupportedException </span>&#123;</span><br><span class="line">WordDocument doc = (WordDocument) super.clone();</span><br><span class="line">doc.mText = <span class="keyword">this</span>.mText;</span><br><span class="line"><span class="keyword">return</span> doc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> PrototypeModule &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">WordDocument <span class="built_in">document</span> = <span class="keyword">new</span> WordDocument();</span><br><span class="line"><span class="built_in">document</span>.setText(<span class="string">"初始文本信息"</span>);</span><br><span class="line"><span class="built_in">document</span>.addImages(<span class="string">"img1"</span>);</span><br><span class="line"><span class="built_in">document</span>.addImages(<span class="string">"img2"</span>);</span><br><span class="line"><span class="built_in">document</span>.addImages(<span class="string">"img3"</span>);</span><br><span class="line"><span class="built_in">document</span>.showDocument();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">WordDocument documentClone = <span class="built_in">document</span>.clone();</span><br><span class="line">System.out.println(<span class="string">"修改text"</span>);</span><br><span class="line">documentClone.setText(<span class="string">" + 修改文本信息"</span>);</span><br><span class="line">documentClone.addImages(<span class="string">"增加图片"</span>);</span><br><span class="line">documentClone.showDocument();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"增加图片"</span>);</span><br><span class="line"><span class="built_in">document</span>.showDocument();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20160316125730134" alt="结果"><br>从结果中可以看出，当我们在被拷贝出来的对象中修改ArrayList中的数据时，原对象的ArrayList数据也改变了，这是因为我们这里使用的方式只是一个浅拷贝，它其实并不是将原始文档的所有字段都重新构造了一份，而是直接将副本文档的字段直接引用原始文档的字段，因此当我们改变副本文档时，原始文档也随着改变了。</p><p><strong>注意</strong><br>为什么我们也修改了text，但是原始文档的值还是没有变化？<br>String类型是一个值类型<br>String指向的对象是一个不可变的对象，String类型的每次变化其实都是创建一个新的对象，之后再将引用指向这个新的对象而已。之前的那个对象其实还是存在的，只是我们不指向它了。<br>如果将String mText更改为StringBuffer mText, setText方法更改为append(text)的话结果就一样了。</p><p>深拷贝<br>-<br>鉴于上面的浅拷贝存在的一些问题，我们可以采用深层拷贝来解决它。之所以会出现修改副本时原本会改变，是因为副本是直接指向原本的引用的。因此，我们只需要在拷贝对象时，对于引用型的字段也采用拷贝的形式，而不是单纯的引用。</p><p>修改如下：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected WordDocument clone() <span class="meta">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">WordDocument <span class="meta">doc</span> = (WordDocument) <span class="keyword">super</span>.clone();</span><br><span class="line"><span class="meta">doc</span>.mText = <span class="keyword">this</span>.mText;</span><br><span class="line"><span class="meta">doc</span>.mImages = (ArrayList&lt;String&gt;) <span class="keyword">this</span>.mImages.clone();</span><br><span class="line"><span class="keyword">return</span> <span class="meta">doc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的话副本的引用型字段就指向原本字段的拷贝了，而不是它的本身，这样就不会引起连锁反应。<br>而上面的text由于是String类型，是一个值类型，不是引用类型</p><p>实际使用<br>-<br>在Android中，Intent也是使用了一个原型模式。而Intent为什么要使用原型模式呢？就是因为这个Intent和以前的一个Intent在很多地方是一样的，我们只需要更改它的部分信息就可以了，因此先拷贝，再修改，节约资源。而在Intent中，存在一段代码，这段代码也很好的解释了之前总结的那句话：clone方法是要看情况的，需要根据构造对象的成本来决定是clone还是new一个新的。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Intent(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里并没有使用super.clone()方法来实现对象的拷贝，而是直接new的一个新的，因为考虑到成本的问题</p><p>在Bundle以及OkHttp中也是使用了原型模式，其余使用的地方自己可以多看看，多找找。</p><p><strong>—————————-华丽丽的分割线——————————</strong></p><p>在这里记录一个自己用到的地方吧：<br>在进行登陆操作时，会通过一个session来保存用户的登录信息，而这些信息会在APP模块中调用，比如说登陆失效的判断等等。在登陆时，会先获取一次之前的登录信息，登陆完成后就要从网络上获取一个新的信息，例如登陆的时间存放到session中。<br>而这个时候就可以使用原型模式了，深层拷贝的方法：<br>第一次登陆时使用拷贝出来的副本进行登陆，等网络请求结束，成功获取到当前登陆的服务器时间时就修改原本中的用户信息。</p><p>#总结</p><p>原型模式使用起来还是挺好的，而具体什么时候使用也是看项目的需求吧，看什么合适就使用什么模式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原型模式： Prototype Module&lt;/p&gt;
&lt;p&gt;顾名思义，这个模式有一个样板实例，用户从这个样板对象中复制出一个内部属性一致的对象，这个过程也就是我们俗称的克隆。被复制的实例就被成为“原型”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://imlzq.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式_Builder模式</title>
    <link href="http://imlzq.com/2016/03/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Builder%E6%A8%A1%E5%BC%8F/"/>
    <id>http://imlzq.com/2016/03/16/设计模式_Builder模式/</id>
    <published>2016-03-16T04:13:50.000Z</published>
    <updated>2018-02-12T03:51:01.620Z</updated>
    
    <content type="html"><![CDATA[<p>Builder模式是一步一步创建一个复杂对象的创建型模式，他允许用户在不知道内部构造细节的情况下，可以更精细地控制对象的构造流程。该模式是为了将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。</p><a id="more"></a><p>##使用场景</p><p>例如，在创建一个对象时，如果该对象的构造方法需要多个参数，而多个参数势必会增加开发者调用该构造方法时的难度，一两个参数还好，如果说参数有5个，甚至是更多的时候，开发者在调用方法的时候就需要一个个的比对参数的作用，而如果中途构造方法的参数改变了，就需要改动很多个地方，也就是增加了维护及拓展的难度。</p><p>而使用Builder模式，可以直接通过setMethodName()来设置参数，而如果setMethodName()返回的是Builder本身，还可以实现链式创建。这让代码变得更为的清晰，同时也容易维护及拓展。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Builder setName(<span class="keyword">String</span> name) &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Builder setAge(<span class="keyword">String</span> name) &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type">TestBuilder</span>().setName(<span class="string">"haha"</span>).setAge(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>上面介绍的这个使用场景是Builder模式使用在创建对象时，在Android中，AlertDialog.Builder就采用了这种方式，具体的各位可以查看一下相关的源码。<br>除了这个使用场景之外，Builder模式也可以用于正常的开发中，不仅仅是构造方法，但是由于它们的思路是一样的，这里就不再赘述，毕竟思想最重要 : )</p><p>##额外的</p><p>Builder模式可以将一个对象的创建分为必要参数和可选参数，这样也增加了一个组件或者是一个函数的用途。在Builder的构造方法中填入必要的参数，而可选的参数就可以使用setMethodName()这种方法来动态的添加，这在Android中相当重要，可以多使用使用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Builder模式是一步一步创建一个复杂对象的创建型模式，他允许用户在不知道内部构造细节的情况下，可以更精细地控制对象的构造流程。该模式是为了将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://imlzq.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
